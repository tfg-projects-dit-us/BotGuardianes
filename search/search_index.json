{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BotGuardianes Esta p\u00e1gina es documentaci\u00f3n del c\u00f3digo generada a partir de los comentarios del propio c\u00f3digo Para empezar, pulsa en las secciones del \u00edndice de la izquierda, para ver la documentaci\u00f3n asociada a cada m\u00f3dulo","title":"Principal"},{"location":"#botguardianes","text":"Esta p\u00e1gina es documentaci\u00f3n del c\u00f3digo generada a partir de los comentarios del propio c\u00f3digo Para empezar, pulsa en las secciones del \u00edndice de la izquierda, para ver la documentaci\u00f3n asociada a cada m\u00f3dulo","title":"BotGuardianes"},{"location":"config/","text":"config Clase para empaquetar la configuraci\u00f3n del bot de telegram Attributes: Name Type Description configfile dict Diccionario conteniendo la configuraci\u00f3n en un fichero yaml directorio str Ruta donde se encuentra el fichero de configuraci\u00f3n. Por defecto en ./data/config/config.yaml Source code in modulos\\config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class config : \"\"\" Clase para empaquetar la configuraci\u00f3n del bot de telegram Attributes: configfile (dict): Diccionario conteniendo la configuraci\u00f3n en un fichero yaml directorio (str): Ruta donde se encuentra el fichero de configuraci\u00f3n. Por defecto en ./data/config/config.yaml \"\"\" def __init__ ( self , directorio : str ): \"\"\" M\u00e9todo inicializador Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml \"\"\" self . configfile : dict = None self . directorio = directorio self . cargar_configuracion_lectura () self . crear_log () self . crear_db () def cargar_configuracion_lectura ( self , directorio : str | None = None ): \"\"\" Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n Returns: (dict): Devuelve diccionario con la configuraci\u00f3n \"\"\" locale . setlocale ( locale . LC_ALL , 'es_ES.UTF-8' ) try : if ( directorio == None and self . directorio != None ): with open ( self . directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) elif ( directorio != None ): with open ( directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return self . configfile def crear_log ( self , config : dict | None = None ): \"\"\" Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Args: config: Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n \"\"\" if ( config != None ): self . configfile = config if not os . path . exists ( './data/log' ): os . makedirs ( './data/log' ) logging . getLogger ( __name__ ) . info ( \"Directorio log creado\" ) # Comprobamos si est\u00e1 el nivel if 'level' in self . configfile [ 'log' ]: nivel_log_num = getattr ( logging , self . configfile [ 'log' ][ 'level' ] . upper ()) if not isinstance ( nivel_log_num , int ): raise ValueError ( 'Nivel de log invalido: %s ' % self . configfile [ 'log' ][ 'level' ]) logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , encoding = 'utf-8' , format = '[ %(asctime)s ] - \u00b7 %(name)s \u00b7 - %(levelname)s - %(message)s ' , level = nivel_log_num ) #En caso de que no haya nivel definido, se pone por defecto warning else : logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , enconding = 'utf-8' , format = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' , level = logging . WARNING ) logging . getLogger ( __name__ ) . debug ( str ( self . configfile )) def crear_db ( self ): \"\"\" Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n \"\"\" connection = sqlite3 . connect ( self . configfile [ 'sqlite' ][ 'path' ]) c = connection . cursor () c . execute ( '''CREATE TABLE IF NOT EXISTS oferta_demanda( ofertante TEXT NOT NULL, demandante TEXT, uid_evento TEXT NOT NULL, id_mensaje_canal_admins TEXT, id_mensaje_canal_publicaciones TEXT, accion TEXT, uid_evento_propuesta_intercambio TEXT); ''' ) connection . commit () c . execute ( '''CREATE TABLE IF NOT EXISTS propuestas( ofertante TEXT NOT NULL, demandante TEXT NOT NULL, uid_evento_ofertado TEXT NOT NULL, uid_evento_propuesto TEXT, id_mensaje_chat TEXT ); ''' ) connection . commit () c . close () connection . close () __init__ ( directorio ) M\u00e9todo inicializador Parameters: Name Type Description Default directorio str Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml required Source code in modulos\\config.py 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , directorio : str ): \"\"\" M\u00e9todo inicializador Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml \"\"\" self . configfile : dict = None self . directorio = directorio self . cargar_configuracion_lectura () self . crear_log () self . crear_db () cargar_configuracion_lectura ( directorio = None ) Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Parameters: Name Type Description Default directorio str | None Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n None Returns: Type Description dict Devuelve diccionario con la configuraci\u00f3n Source code in modulos\\config.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def cargar_configuracion_lectura ( self , directorio : str | None = None ): \"\"\" Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n Returns: (dict): Devuelve diccionario con la configuraci\u00f3n \"\"\" locale . setlocale ( locale . LC_ALL , 'es_ES.UTF-8' ) try : if ( directorio == None and self . directorio != None ): with open ( self . directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) elif ( directorio != None ): with open ( directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return self . configfile crear_db () Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n Source code in modulos\\config.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def crear_db ( self ): \"\"\" Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n \"\"\" connection = sqlite3 . connect ( self . configfile [ 'sqlite' ][ 'path' ]) c = connection . cursor () c . execute ( '''CREATE TABLE IF NOT EXISTS oferta_demanda( ofertante TEXT NOT NULL, demandante TEXT, uid_evento TEXT NOT NULL, id_mensaje_canal_admins TEXT, id_mensaje_canal_publicaciones TEXT, accion TEXT, uid_evento_propuesta_intercambio TEXT); ''' ) connection . commit () c . execute ( '''CREATE TABLE IF NOT EXISTS propuestas( ofertante TEXT NOT NULL, demandante TEXT NOT NULL, uid_evento_ofertado TEXT NOT NULL, uid_evento_propuesto TEXT, id_mensaje_chat TEXT ); ''' ) connection . commit () c . close () connection . close () crear_log ( config = None ) Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Parameters: Name Type Description Default config dict | None Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n None Source code in modulos\\config.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def crear_log ( self , config : dict | None = None ): \"\"\" Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Args: config: Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n \"\"\" if ( config != None ): self . configfile = config if not os . path . exists ( './data/log' ): os . makedirs ( './data/log' ) logging . getLogger ( __name__ ) . info ( \"Directorio log creado\" ) # Comprobamos si est\u00e1 el nivel if 'level' in self . configfile [ 'log' ]: nivel_log_num = getattr ( logging , self . configfile [ 'log' ][ 'level' ] . upper ()) if not isinstance ( nivel_log_num , int ): raise ValueError ( 'Nivel de log invalido: %s ' % self . configfile [ 'log' ][ 'level' ]) logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , encoding = 'utf-8' , format = '[ %(asctime)s ] - \u00b7 %(name)s \u00b7 - %(levelname)s - %(message)s ' , level = nivel_log_num ) #En caso de que no haya nivel definido, se pone por defecto warning else : logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , enconding = 'utf-8' , format = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' , level = logging . WARNING ) logging . getLogger ( __name__ ) . debug ( str ( self . configfile ))","title":"config"},{"location":"config/#modulos.config.config","text":"Clase para empaquetar la configuraci\u00f3n del bot de telegram Attributes: Name Type Description configfile dict Diccionario conteniendo la configuraci\u00f3n en un fichero yaml directorio str Ruta donde se encuentra el fichero de configuraci\u00f3n. Por defecto en ./data/config/config.yaml Source code in modulos\\config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class config : \"\"\" Clase para empaquetar la configuraci\u00f3n del bot de telegram Attributes: configfile (dict): Diccionario conteniendo la configuraci\u00f3n en un fichero yaml directorio (str): Ruta donde se encuentra el fichero de configuraci\u00f3n. Por defecto en ./data/config/config.yaml \"\"\" def __init__ ( self , directorio : str ): \"\"\" M\u00e9todo inicializador Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml \"\"\" self . configfile : dict = None self . directorio = directorio self . cargar_configuracion_lectura () self . crear_log () self . crear_db () def cargar_configuracion_lectura ( self , directorio : str | None = None ): \"\"\" Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n Returns: (dict): Devuelve diccionario con la configuraci\u00f3n \"\"\" locale . setlocale ( locale . LC_ALL , 'es_ES.UTF-8' ) try : if ( directorio == None and self . directorio != None ): with open ( self . directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) elif ( directorio != None ): with open ( directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return self . configfile def crear_log ( self , config : dict | None = None ): \"\"\" Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Args: config: Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n \"\"\" if ( config != None ): self . configfile = config if not os . path . exists ( './data/log' ): os . makedirs ( './data/log' ) logging . getLogger ( __name__ ) . info ( \"Directorio log creado\" ) # Comprobamos si est\u00e1 el nivel if 'level' in self . configfile [ 'log' ]: nivel_log_num = getattr ( logging , self . configfile [ 'log' ][ 'level' ] . upper ()) if not isinstance ( nivel_log_num , int ): raise ValueError ( 'Nivel de log invalido: %s ' % self . configfile [ 'log' ][ 'level' ]) logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , encoding = 'utf-8' , format = '[ %(asctime)s ] - \u00b7 %(name)s \u00b7 - %(levelname)s - %(message)s ' , level = nivel_log_num ) #En caso de que no haya nivel definido, se pone por defecto warning else : logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , enconding = 'utf-8' , format = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' , level = logging . WARNING ) logging . getLogger ( __name__ ) . debug ( str ( self . configfile )) def crear_db ( self ): \"\"\" Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n \"\"\" connection = sqlite3 . connect ( self . configfile [ 'sqlite' ][ 'path' ]) c = connection . cursor () c . execute ( '''CREATE TABLE IF NOT EXISTS oferta_demanda( ofertante TEXT NOT NULL, demandante TEXT, uid_evento TEXT NOT NULL, id_mensaje_canal_admins TEXT, id_mensaje_canal_publicaciones TEXT, accion TEXT, uid_evento_propuesta_intercambio TEXT); ''' ) connection . commit () c . execute ( '''CREATE TABLE IF NOT EXISTS propuestas( ofertante TEXT NOT NULL, demandante TEXT NOT NULL, uid_evento_ofertado TEXT NOT NULL, uid_evento_propuesto TEXT, id_mensaje_chat TEXT ); ''' ) connection . commit () c . close () connection . close ()","title":"config"},{"location":"config/#modulos.config.config.__init__","text":"M\u00e9todo inicializador Parameters: Name Type Description Default directorio str Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml required Source code in modulos\\config.py 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , directorio : str ): \"\"\" M\u00e9todo inicializador Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml \"\"\" self . configfile : dict = None self . directorio = directorio self . cargar_configuracion_lectura () self . crear_log () self . crear_db ()","title":"__init__()"},{"location":"config/#modulos.config.config.cargar_configuracion_lectura","text":"Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Parameters: Name Type Description Default directorio str | None Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n None Returns: Type Description dict Devuelve diccionario con la configuraci\u00f3n Source code in modulos\\config.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def cargar_configuracion_lectura ( self , directorio : str | None = None ): \"\"\" Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n Returns: (dict): Devuelve diccionario con la configuraci\u00f3n \"\"\" locale . setlocale ( locale . LC_ALL , 'es_ES.UTF-8' ) try : if ( directorio == None and self . directorio != None ): with open ( self . directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) elif ( directorio != None ): with open ( directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return self . configfile","title":"cargar_configuracion_lectura()"},{"location":"config/#modulos.config.config.crear_db","text":"Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n Source code in modulos\\config.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def crear_db ( self ): \"\"\" Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n \"\"\" connection = sqlite3 . connect ( self . configfile [ 'sqlite' ][ 'path' ]) c = connection . cursor () c . execute ( '''CREATE TABLE IF NOT EXISTS oferta_demanda( ofertante TEXT NOT NULL, demandante TEXT, uid_evento TEXT NOT NULL, id_mensaje_canal_admins TEXT, id_mensaje_canal_publicaciones TEXT, accion TEXT, uid_evento_propuesta_intercambio TEXT); ''' ) connection . commit () c . execute ( '''CREATE TABLE IF NOT EXISTS propuestas( ofertante TEXT NOT NULL, demandante TEXT NOT NULL, uid_evento_ofertado TEXT NOT NULL, uid_evento_propuesto TEXT, id_mensaje_chat TEXT ); ''' ) connection . commit () c . close () connection . close ()","title":"crear_db()"},{"location":"config/#modulos.config.config.crear_log","text":"Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Parameters: Name Type Description Default config dict | None Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n None Source code in modulos\\config.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def crear_log ( self , config : dict | None = None ): \"\"\" Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Args: config: Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n \"\"\" if ( config != None ): self . configfile = config if not os . path . exists ( './data/log' ): os . makedirs ( './data/log' ) logging . getLogger ( __name__ ) . info ( \"Directorio log creado\" ) # Comprobamos si est\u00e1 el nivel if 'level' in self . configfile [ 'log' ]: nivel_log_num = getattr ( logging , self . configfile [ 'log' ][ 'level' ] . upper ()) if not isinstance ( nivel_log_num , int ): raise ValueError ( 'Nivel de log invalido: %s ' % self . configfile [ 'log' ][ 'level' ]) logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , encoding = 'utf-8' , format = '[ %(asctime)s ] - \u00b7 %(name)s \u00b7 - %(levelname)s - %(message)s ' , level = nivel_log_num ) #En caso de que no haya nivel definido, se pone por defecto warning else : logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , enconding = 'utf-8' , format = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' , level = logging . WARNING ) logging . getLogger ( __name__ ) . debug ( str ( self . configfile ))","title":"crear_log()"},{"location":"gestor_calendario/","text":"M\u00f3dulo para agregar manejo de calendarios y eventos mediante un cliente calDAV Contiene las clases: Evento : Clase para envolver un evento tipo caldav.Event Calendario : Clase para ofrecer m\u00e9todos de manejo de un calendario Contiene tambi\u00e9n los atributos de m\u00f3dulo: cliente : Variable a nivel de m\u00f3dulo con el objeto de manejo de cliente calDAV Y el m\u00e9todos de m\u00f3dulo: start(url_servicio,usuario,contrasena) : Inicio del cliente calDAV Calendario Clase para manejar un calendario con cliente calDAV Attributes: Name Type Description url str Nombre del calendario calendario caldav . Calendar Calendario conectado con cliente calDAV Source code in modulos\\gestor_calendario.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 class Calendario : \"\"\" Clase para manejar un calendario con cliente calDAV Attributes: url (str): Nombre del calendario calendario (caldav.Calendar): Calendario conectado con cliente calDAV \"\"\" def __init__ ( self , url : str = None ): \"\"\" Constructor de Calendario Args: url (str): La nombre del calendario que cargaremos \"\"\" self . url : str = url self . calendario : caldav . Calendar = None self . cargar_calendario ( self . url ) def cargar_calendario ( self , nombre : str ): \"\"\" Inicializaci\u00f3n del calendario mediante cliente calDAV Args: nombre: nombre del calendario perteneciente al usuario de calDAV \"\"\" global cliente self . calendario = cliente . principal () . calendar ( cal_id = nombre ) @staticmethod def get_fecha_inicio_mes (): \"\"\" Funci\u00f3n para calcular fecha inicio mes Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'month' ) . datetime @staticmethod def get_fecha_hoy (): \"\"\" Funci\u00f3n para calcular fecha de hoy Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'hour' ) . datetime # Funci\u00f3n para calcular el timestamp del \u00faltimo d\u00eda del mes @staticmethod def get_fecha_fin_mes (): \"\"\" Funci\u00f3n para calcular fecha fin mes Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . ceil ( 'month' ) . datetime @staticmethod def ordenar_eventos ( lista_eventos : list [ Evento ]): \"\"\" Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Args: lista_eventos: Lista de eventos a ordenar por fecha Returns: (list[Evento]|None):Lista ordenada de eventos \"\"\" lista_ordenada : list [ Evento ] = lista_eventos try : lista_ordenada = sorted ( lista_eventos , key = lambda x : x . get_fecha_str ()) except BaseException as exception : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , exception )) return None finally : return lista_ordenada def get_eventos ( self , attendee : str | None = None , rol : str = \"\" , completos : bool = False ): \"\"\" Obtiene los eventos de un calendario en el periodo del mes actual. Args: attendee: Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. rol: Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante completos: Se solicitan eventos que ya se puede ejecutar una cesi\u00f3n o intercambio. Returns: (list[Evento]):Lista de Evento \"\"\" lista_eventos = [] lista_eventos_aux = [] no_pedido = False sitios_libres = 0 sin_sitio = False try : eventosmes = self . calendario . date_search ( start = self . get_fecha_hoy (), end = self . get_fecha_fin_mes (), expand = True ) for x in eventosmes : lista_eventos_aux . append ( Evento ( x )) for e in lista_eventos_aux : fecha = e . get_fecha_datetime () if self . get_fecha_fin_mes () > datetime . datetime ( fecha . year , fecha . month , fecha . day , 0 , 0 , 0 , 0 , pytz . timezone ( 'Europe/Madrid' )) > self . get_fecha_inicio_mes (): logging . getLogger ( __name__ ) . debug ( \"Evento en el periodo actual \" + str ( e )) if ( completos == True ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos para aprobar o denegar\" ) if e . get_cuenta_demandantes () == e . get_cuenta_ofertantes () and e . get_sitios_libres () == 0 : lista_eventos . append ( e ) elif ( attendee == None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos libres\" ) if e . get_sitios_libres () > 0 : lista_eventos . append ( e ) elif ( attendee != None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos de una persona\" ) if e . get_comprobar_asistente ( attendee , rol = rol ): lista_eventos . append ( e ) logging . getLogger ( __name__ ) . debug ( \"Lista de eventos en get_eventos:\" + str ( lista_eventos )) lista_ordenada = self . ordenar_eventos ( lista_eventos ) return lista_ordenada except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) print ( \"Error cargando eventos: \" + str ( e )) return None def get_evento ( self , uid_evento : str ): \"\"\" Obtiene un evento a partir de la uid del evento Args: uid_evento: identificador \u00fanico del evento Returns: (Evento|None):Evento con uid=uid_evento o None en caso de no encontrarse \"\"\" try : return Evento ( self . calendario . event_by_uid ( uid = uid_evento )) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def asentar_cambios ( self , uid_evento : str ): \"\"\" Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Args: uid_evento: Identificador \u00fanico del evento Returns: (tuple[list[str],list[str],Evento]): Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento \"\"\" try : evento = self . get_evento ( uid_evento ) ( borrados , asentados ) = evento . asienta_asistentes () return ( borrados , asentados , evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ([],[], None ) def set_evento ( self , evento : Evento ): \"\"\" Guarda un evento en el calendario Args: evento: (gestor_calendario.Evento) Evento a guardar Returns: (bool):Verdadero si pudo hacerlo, falso si no \"\"\" try : evento_encontrado = self . calendario . event_by_uid ( uid = evento . get_uid ()) if isinstance ( evento_encontrado , caldav . Event ): evento_encontrado . data = evento . Event . data self . calendario . save_event ( evento_encontrado . data ) return True except caldav . lib . error . NotFoundError as e : logging . getLogger ( __name__ ) . info ( \"Evento {} no existente en calendario. Funci\u00f3n ejecutada {} \" . format ( evento . get_uid (), sys . _getframe ( 1 ) . f_code . co_name )) logging . getLogger ( __name__ ) . info ( \"Evento a introducir {} en calendario {} con data {} \" . format ( str ( evento ), str ( self . calendario . canonical_url ), str ( evento . Event . data ))) self . calendario . save_event ( evento . Event . data ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def ofertar_evento ( self , correo_usuario : str , uid_evento : str , tipo : str = 'INDIVIDUAL' , evento : Evento = None ): \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT, el tipo a INDIVIDUAL y guarda el evento en el calendario Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: (Evento|None):Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ): evento_buscado . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" , tipo = tipo ) evento_cedido = self . set_evento ( evento_buscado ) if evento_cedido == True : return evento_buscado if isinstance ( evento , Evento ) and not isinstance ( evento_buscado , Evento ) : if evento . get_comprobar_asistente ( correo_usuario ): evento . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" , tipo = tipo ) evento_cedido = self . set_evento ( evento ) if evento_cedido == True : return self . get_evento ( uid_evento = uid_evento ) except Exception as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception def cancelar_evento ( self , correo_usuario : str , uid_evento : str ): \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario Returns: (Evento|None): Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" evento_cancelado = False try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento_cancelado ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): rol_asistente = evento_buscado . get_rol_asistente ( asistente = correo_usuario ) if rol_asistente == \"OPT-PARTICIPANT\" : ofertantes = evento_buscado . get_cuenta_ofertantes () demandantes = evento_buscado . get_cuenta_demandantes () asistentes = evento_buscado . get_cuenta_asistentes () if ofertantes > demandantes : evento_buscado . set_asistente ( correo_usuario , rol = \"REQ-PARTICIPANT\" ) evento_cancelado = self . set_evento ( evento_buscado ) \"\"\"Se env\u00eda un mensaje al usuario indicando que no puede realizar esta acci\u00f3n\"\"\" ofertantes = evento_buscado . get_cuenta_ofertantes () if ofertantes == 0 : evento_buscado . Event . delete () evento_cancelado = True if rol_asistente == \"NON-PARTICIPANT\" : evento_buscado . borrar_asistente ( correo_usuario ) evento_cancelado = self . set_evento ( evento_buscado ) if evento_cancelado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def borrar_evento ( self , uid_evento : str ) -> bool : \"\"\" Borra el evento del calendario con la uid correspondiente Args: uid_evento: uid del evento que se desea borrar Returns: Devuelve True si lo borr\u00f3, False si no \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): evento_buscado . Event . delete () return True else : return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def tomar_evento ( self , correo_usuario : str , uid_evento : str , tipo = 'INDIVIDUAL' ) -> Evento | None : \"\"\" Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Args: correo_usuario: Correo del usuario que tomar\u00e1 la plaza libre del evento uid_evento: Identificador \u00fanico del evento Returns: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ) != True and evento_buscado . get_sitios_libres () > 0 : evento_buscado . set_asistente ( correo_usuario , rol = \"NON-PARTICIPANT\" , tipo = tipo ) evento_tomado = self . set_evento ( evento_buscado ) if evento_tomado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None __init__ ( url = None ) Constructor de Calendario Parameters: Name Type Description Default url str La nombre del calendario que cargaremos None Source code in modulos\\gestor_calendario.py 467 468 469 470 471 472 473 474 475 476 def __init__ ( self , url : str = None ): \"\"\" Constructor de Calendario Args: url (str): La nombre del calendario que cargaremos \"\"\" self . url : str = url self . calendario : caldav . Calendar = None self . cargar_calendario ( self . url ) asentar_cambios ( uid_evento ) Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Parameters: Name Type Description Default uid_evento str Identificador \u00fanico del evento required Returns: Type Description tuple [ list [ str ], list [ str ], Evento ] Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento Source code in modulos\\gestor_calendario.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def asentar_cambios ( self , uid_evento : str ): \"\"\" Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Args: uid_evento: Identificador \u00fanico del evento Returns: (tuple[list[str],list[str],Evento]): Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento \"\"\" try : evento = self . get_evento ( uid_evento ) ( borrados , asentados ) = evento . asienta_asistentes () return ( borrados , asentados , evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ([],[], None ) borrar_evento ( uid_evento ) Borra el evento del calendario con la uid correspondiente Parameters: Name Type Description Default uid_evento str uid del evento que se desea borrar required Returns: Type Description bool Devuelve True si lo borr\u00f3, False si no Source code in modulos\\gestor_calendario.py 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def borrar_evento ( self , uid_evento : str ) -> bool : \"\"\" Borra el evento del calendario con la uid correspondiente Args: uid_evento: uid del evento que se desea borrar Returns: Devuelve True si lo borr\u00f3, False si no \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): evento_buscado . Event . delete () return True else : return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False cancelar_evento ( correo_usuario , uid_evento ) Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default correo_usuario str Correo del usuario que se est\u00e1 tratando de cambiar el rol required uid_evento str UID del evento que se est\u00e1 buscando en el calendario required Returns: Type Description Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 def cancelar_evento ( self , correo_usuario : str , uid_evento : str ): \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario Returns: (Evento|None): Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" evento_cancelado = False try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento_cancelado ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): rol_asistente = evento_buscado . get_rol_asistente ( asistente = correo_usuario ) if rol_asistente == \"OPT-PARTICIPANT\" : ofertantes = evento_buscado . get_cuenta_ofertantes () demandantes = evento_buscado . get_cuenta_demandantes () asistentes = evento_buscado . get_cuenta_asistentes () if ofertantes > demandantes : evento_buscado . set_asistente ( correo_usuario , rol = \"REQ-PARTICIPANT\" ) evento_cancelado = self . set_evento ( evento_buscado ) \"\"\"Se env\u00eda un mensaje al usuario indicando que no puede realizar esta acci\u00f3n\"\"\" ofertantes = evento_buscado . get_cuenta_ofertantes () if ofertantes == 0 : evento_buscado . Event . delete () evento_cancelado = True if rol_asistente == \"NON-PARTICIPANT\" : evento_buscado . borrar_asistente ( correo_usuario ) evento_cancelado = self . set_evento ( evento_buscado ) if evento_cancelado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None cargar_calendario ( nombre ) Inicializaci\u00f3n del calendario mediante cliente calDAV Parameters: Name Type Description Default nombre str nombre del calendario perteneciente al usuario de calDAV required Source code in modulos\\gestor_calendario.py 478 479 480 481 482 483 484 485 486 487 def cargar_calendario ( self , nombre : str ): \"\"\" Inicializaci\u00f3n del calendario mediante cliente calDAV Args: nombre: nombre del calendario perteneciente al usuario de calDAV \"\"\" global cliente self . calendario = cliente . principal () . calendar ( cal_id = nombre ) get_evento ( uid_evento ) Obtiene un evento a partir de la uid del evento Parameters: Name Type Description Default uid_evento str identificador \u00fanico del evento required Returns: Type Description Evento | None Evento con uid=uid_evento o None en caso de no encontrarse Source code in modulos\\gestor_calendario.py 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def get_evento ( self , uid_evento : str ): \"\"\" Obtiene un evento a partir de la uid del evento Args: uid_evento: identificador \u00fanico del evento Returns: (Evento|None):Evento con uid=uid_evento o None en caso de no encontrarse \"\"\" try : return Evento ( self . calendario . event_by_uid ( uid = uid_evento )) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None get_eventos ( attendee = None , rol = '' , completos = False ) Obtiene los eventos de un calendario en el periodo del mes actual. Parameters: Name Type Description Default attendee str | None Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. None rol str Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante '' completos bool Se solicitan eventos que ya se puede ejecutar una cesi\u00f3n o intercambio. False Returns: Type Description list [ Evento ] Lista de Evento Source code in modulos\\gestor_calendario.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def get_eventos ( self , attendee : str | None = None , rol : str = \"\" , completos : bool = False ): \"\"\" Obtiene los eventos de un calendario en el periodo del mes actual. Args: attendee: Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. rol: Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante completos: Se solicitan eventos que ya se puede ejecutar una cesi\u00f3n o intercambio. Returns: (list[Evento]):Lista de Evento \"\"\" lista_eventos = [] lista_eventos_aux = [] no_pedido = False sitios_libres = 0 sin_sitio = False try : eventosmes = self . calendario . date_search ( start = self . get_fecha_hoy (), end = self . get_fecha_fin_mes (), expand = True ) for x in eventosmes : lista_eventos_aux . append ( Evento ( x )) for e in lista_eventos_aux : fecha = e . get_fecha_datetime () if self . get_fecha_fin_mes () > datetime . datetime ( fecha . year , fecha . month , fecha . day , 0 , 0 , 0 , 0 , pytz . timezone ( 'Europe/Madrid' )) > self . get_fecha_inicio_mes (): logging . getLogger ( __name__ ) . debug ( \"Evento en el periodo actual \" + str ( e )) if ( completos == True ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos para aprobar o denegar\" ) if e . get_cuenta_demandantes () == e . get_cuenta_ofertantes () and e . get_sitios_libres () == 0 : lista_eventos . append ( e ) elif ( attendee == None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos libres\" ) if e . get_sitios_libres () > 0 : lista_eventos . append ( e ) elif ( attendee != None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos de una persona\" ) if e . get_comprobar_asistente ( attendee , rol = rol ): lista_eventos . append ( e ) logging . getLogger ( __name__ ) . debug ( \"Lista de eventos en get_eventos:\" + str ( lista_eventos )) lista_ordenada = self . ordenar_eventos ( lista_eventos ) return lista_ordenada except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) print ( \"Error cargando eventos: \" + str ( e )) return None get_fecha_fin_mes () staticmethod Funci\u00f3n para calcular fecha fin mes Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 509 510 511 512 513 514 515 516 517 @staticmethod def get_fecha_fin_mes (): \"\"\" Funci\u00f3n para calcular fecha fin mes Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . ceil ( 'month' ) . datetime get_fecha_hoy () staticmethod Funci\u00f3n para calcular fecha de hoy Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 499 500 501 502 503 504 505 506 507 @staticmethod def get_fecha_hoy (): \"\"\" Funci\u00f3n para calcular fecha de hoy Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'hour' ) . datetime get_fecha_inicio_mes () staticmethod Funci\u00f3n para calcular fecha inicio mes Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 489 490 491 492 493 494 495 496 497 @staticmethod def get_fecha_inicio_mes (): \"\"\" Funci\u00f3n para calcular fecha inicio mes Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'month' ) . datetime ofertar_evento ( correo_usuario , uid_evento , tipo = 'INDIVIDUAL' , evento = None ) Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT, el tipo a INDIVIDUAL y guarda el evento en el calendario Parameters: Name Type Description Default correo_usuario str Correo del usuario que se est\u00e1 tratando de cambiar el rol required uid_evento str UID del evento que se est\u00e1 buscando en el calendario required evento Evento Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento None Returns: Type Description Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 def ofertar_evento ( self , correo_usuario : str , uid_evento : str , tipo : str = 'INDIVIDUAL' , evento : Evento = None ): \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT, el tipo a INDIVIDUAL y guarda el evento en el calendario Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: (Evento|None):Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ): evento_buscado . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" , tipo = tipo ) evento_cedido = self . set_evento ( evento_buscado ) if evento_cedido == True : return evento_buscado if isinstance ( evento , Evento ) and not isinstance ( evento_buscado , Evento ) : if evento . get_comprobar_asistente ( correo_usuario ): evento . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" , tipo = tipo ) evento_cedido = self . set_evento ( evento ) if evento_cedido == True : return self . get_evento ( uid_evento = uid_evento ) except Exception as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception ordenar_eventos ( lista_eventos ) staticmethod Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Parameters: Name Type Description Default lista_eventos list [ Evento ] Lista de eventos a ordenar por fecha required Returns: Type Description list [ Evento ] | None Lista ordenada de eventos Source code in modulos\\gestor_calendario.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 @staticmethod def ordenar_eventos ( lista_eventos : list [ Evento ]): \"\"\" Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Args: lista_eventos: Lista de eventos a ordenar por fecha Returns: (list[Evento]|None):Lista ordenada de eventos \"\"\" lista_ordenada : list [ Evento ] = lista_eventos try : lista_ordenada = sorted ( lista_eventos , key = lambda x : x . get_fecha_str ()) except BaseException as exception : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , exception )) return None finally : return lista_ordenada set_evento ( evento ) Guarda un evento en el calendario Parameters: Name Type Description Default evento Evento (gestor_calendario.Evento) Evento a guardar required Returns: Type Description bool Verdadero si pudo hacerlo, falso si no Source code in modulos\\gestor_calendario.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 def set_evento ( self , evento : Evento ): \"\"\" Guarda un evento en el calendario Args: evento: (gestor_calendario.Evento) Evento a guardar Returns: (bool):Verdadero si pudo hacerlo, falso si no \"\"\" try : evento_encontrado = self . calendario . event_by_uid ( uid = evento . get_uid ()) if isinstance ( evento_encontrado , caldav . Event ): evento_encontrado . data = evento . Event . data self . calendario . save_event ( evento_encontrado . data ) return True except caldav . lib . error . NotFoundError as e : logging . getLogger ( __name__ ) . info ( \"Evento {} no existente en calendario. Funci\u00f3n ejecutada {} \" . format ( evento . get_uid (), sys . _getframe ( 1 ) . f_code . co_name )) logging . getLogger ( __name__ ) . info ( \"Evento a introducir {} en calendario {} con data {} \" . format ( str ( evento ), str ( self . calendario . canonical_url ), str ( evento . Event . data ))) self . calendario . save_event ( evento . Event . data ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False tomar_evento ( correo_usuario , uid_evento , tipo = 'INDIVIDUAL' ) Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Parameters: Name Type Description Default correo_usuario str Correo del usuario que tomar\u00e1 la plaza libre del evento required uid_evento str Identificador \u00fanico del evento required Returns: Type Description Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 def tomar_evento ( self , correo_usuario : str , uid_evento : str , tipo = 'INDIVIDUAL' ) -> Evento | None : \"\"\" Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Args: correo_usuario: Correo del usuario que tomar\u00e1 la plaza libre del evento uid_evento: Identificador \u00fanico del evento Returns: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ) != True and evento_buscado . get_sitios_libres () > 0 : evento_buscado . set_asistente ( correo_usuario , rol = \"NON-PARTICIPANT\" , tipo = tipo ) evento_tomado = self . set_evento ( evento_buscado ) if evento_tomado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None Evento Clase que envuelve a un objeto de clase caldav.Event Genera m\u00e9todos que permitan operar con este objeto con m\u00e1s facilidad En el objeto caldav.Event Attendee es un diccionario de diccionarios. La clave es el correo del asistente, y da como resultado un diccionario que contiene rol y tipo de asistente. Los envuelve en listas, pero con esta clase vamos a convertirlo en un diccionario de diccionarios. Los roles del asistente son: REQ-PARTICIPANT: Significa asistente obligatorio al calendario OPT-PARTICIPANT: Empleado que pretende ceder este turno NON-PARTICIPANT: Empleado que quiere tomar este turno Los tipos del asistente son: INDIVIDUAL: Se usa para indicar cesiones. GROUP: Se usa para indicar intercambio. RESOURCE: Sin uso. ROOM: Sin uso. Ejemplos: { correo1: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE}, correo2: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE} } Attributes: Name Type Description Event caldav . Event Evento tipo caldav.Event asistentes dict [ dict ] Diccionario de asistentes Source code in modulos\\gestor_calendario.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 class Evento : \"\"\" Clase que envuelve a un objeto de clase caldav.Event Genera m\u00e9todos que permitan operar con este objeto con m\u00e1s facilidad En el objeto caldav.Event Attendee es un diccionario de diccionarios. La clave es el correo del asistente, y da como resultado un diccionario que contiene rol y tipo de asistente. Los envuelve en listas, pero con esta clase vamos a convertirlo en un diccionario de diccionarios. ``` Los roles del asistente son: REQ-PARTICIPANT: Significa asistente obligatorio al calendario OPT-PARTICIPANT: Empleado que pretende ceder este turno NON-PARTICIPANT: Empleado que quiere tomar este turno Los tipos del asistente son: INDIVIDUAL: Se usa para indicar cesiones. GROUP: Se usa para indicar intercambio. RESOURCE: Sin uso. ROOM: Sin uso. Ejemplos: { correo1: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE}, correo2: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE} } ``` Attributes: Event (caldav.Event): Evento tipo caldav.Event asistentes (dict[dict]): Diccionario de asistentes \"\"\" def __init__ ( self , evento : caldav . Event ): \"\"\" Constructor de Evento. Crea atributos: - Event: caldav.Event - asistentes: diccionario de asistentes {correo1,correo2,...} Args: evento: Evento tipo caldav.Event \"\"\" self . Event = evento self . asistentes = {} self . get_asistentes () def get_summary ( self ): \"\"\" Obtiene nombre de evento o summary Returns: (str):Cadena con nombre del evento \"\"\" return str ( self . Event . vobject_instance . vevent . summary . value ) def get_uid ( self ): \"\"\" Obtiene uid del evento Returns: (str):Uid del evento \"\"\" return str ( self . Event . vobject_instance . vevent . uid . value ) def get_asistentes ( self , rol : str = \"\" , tipo = \"\" ): \"\"\" Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Args: rol: El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT tipo: TIpo de asistente que se quiere obtener. Puede ser INDIVIDUAL or GROUP Returns: (dict[dict]):Devuelve un diccionario de diccionarios con clave principal el correo del usuario. \"\"\" if self . asistentes == {}: if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): for asistente in self . Event . vobject_instance . vevent . contents [ 'attendee' ]: if 'ROLE' in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) elif 'ROLE' in asistente . params . keys () and 'CUTYPE' not in asistente . params . keys (): if asistente . params [ 'ROLE' ] == [ 'null' ]: self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) else : self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : 'INDIVIDUAL' }}) elif 'ROLE' not in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) else : self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) if rol != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == rol : diccionario_aux . update ({ asistente : self . asistentes [ asistente ]}) cuenta_aux += 1 return diccionario_aux if tipo != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'tipo' ] == tipo : diccionario_aux . update ({ asistente : self . asistentes [ asistente ]}) cuenta_aux += 1 return diccionario_aux else : return self . asistentes def set_asistente ( self , correo_asistente : str , rol : str = \"\" , tipo : str = 'INDIVIDUAL' ): \"\"\" Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Args: correo_asistente: Correo del asistente que estamos queriendo actualizar rol: Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba tipo: Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. Returns: (int): 0 si es correcto, -1 si sucede una Excepci\u00f3n \"\"\" try : asistente = self . asistentes [ correo_asistente ] except KeyError as k : self . asistentes [ correo_asistente ] = {} except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 finally : if rol != \"\" : self . asistentes [ correo_asistente ][ 'rol' ] = rol self . asistentes [ correo_asistente ][ 'tipo' ] = tipo if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == correo_asistente : self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'ROLE' : [ asistente [ 'rol' ]]}) self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'CUTYPE' : [ asistente [ 'tipo' ]]}) existente = True if not existente : try : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 else : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) return 0 def borrar_asistente ( self , asistente : str ): \"\"\" Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Args: asistente: correo del asistente a borrar Returns: (bool):True si lo borra con \u00e9xito, False si no \"\"\" result = False try : del self . asistentes [ asistente ] existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == asistente : del self . Event . vobject_instance . vevent . attendee_list [ i ] existente = True result = True except KeyError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} . El correo del asistente no est\u00e1 incluido en el evento\" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def asienta_asistentes ( self , ofertante : str = \"\" , demandante : str = \"\" ): \"\"\" Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: (tuple[bool,list[str],list[str]]):Tupla que contiene un bool indicando si se hizo el cambio bien y dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados \"\"\" lista_asentados = [] para_borrar = [] lista_borrados = [] try : if ofertante == \"\" and demandante == \"\" : for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : self . set_asistente ( asistente , rol = 'REQ-PARTICIPANT' ) lista_asentados . append ( asistente ) if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : para_borrar . append ( asistente ) for asistente in para_borrar : self . borrar_asistente ( asistente ) lista_borrados . append ( asistente ) return ( True , lista_borrados , lista_asentados ) else : self . borrar_asistente ( ofertante ) self . set_asistente ( demandante , rol = 'REQ-PARTICIPANT' , tipo = 'INDIVIDUAL' ) return ( True ,) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ( False ,) def negar_cambio_asistentes ( self , ofertante : str , demandante : str ): \"\"\" Niega el cambio de una guardia, borrando al demandante del evento y poniendo al ofertante de REQ-PARTICIPANT Args: ofertante: Correo del ofertante demandante: Correo del demandante Returns: (bool): True si realiza la negaci\u00f3n, False si no \"\"\" try : self . set_asistente ( ofertante , rol = 'REQ-PARTICIPANT' ) self . borrar_asistente ( demandante ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def get_rol_asistente ( self , asistente : str ): \"\"\" Devuelve el rol del asistente que se pasa por par\u00e1metro Args: asistente: Correo del asistente Returns: (str):rol del asistente en cadena \"\"\" return self . asistentes [ asistente ][ 'rol' ] def get_cuenta_asistentes ( self ): \"\"\" Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: (int):Cantidad de asistentes requeridos a un evento. \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"REQ-PARTICIPANT\" : cuenta += 1 return cuenta def get_cuenta_ofertantes ( self ): \"\"\" Obtiene cuenta de ofertantes de un evento Returns: (int):Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"OPT-PARTICIPANT\" : cuenta += 1 return cuenta def get_cuenta_demandantes ( self ): \"\"\" Obtiene cantidad de demandantes de un evento Returns: (int):Obtiene cantidad de asistentes con el rol NON-PARTICIPANT \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"NON-PARTICIPANT\" : cuenta += 1 return cuenta def get_fecha_str ( self ): \"\"\" Obtiene la fecha de inicio del evento en formato cadena Returns: (str): Fecha en formato [dia-mes-a\u00f1o horas-minutos] \"\"\" fecha : datetime . datetime = self . Event . vobject_instance . vevent . dtstart . value fecha_madrid = fecha . astimezone ( tz = pytz . timezone ( 'Europe/Madrid' )) return fecha_madrid . strftime ( ' %d -%m-%Y %H:%M' ) def get_fecha_datetime ( self ): \"\"\" Obtiene la fecha de inicio del evento en formato datetime Returns: (datetime.datetime):Fecha de inicio del evento \"\"\" fecha : datetime . datetime = self . Event . vobject_instance . vevent . dtstart . value fecha_madrid = fecha . astimezone ( tz = pytz . timezone ( 'Europe/Madrid' )) return fecha_madrid def get_sitios_libres ( self ): \"\"\" Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: (int):Cantidad de puestos libres \"\"\" sitios_libres = 0 if self . asistentes != {}: for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'Optativo' en un evento. Significa que ya alguien pidi\u00f3 ceder el evento\" ) sitios_libres += 1 if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'No Participante' en un evento. Significa que ya alguien pidi\u00f3 obtener el evento que alguien cedi\u00f3\" ) sitios_libres -= 1 return sitios_libres def get_comprobar_asistente ( self , asistente : str , rol : str = \"\" ): \"\"\" Comprueba si un asistente est\u00e1 en un evento Args: asistente: Correo del asistente que se comprueba rol: Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento Returns: (bool):True si est\u00e1 ( con el rol en concreto si es especificado), False si no \"\"\" resultado = False for attendee in self . asistentes : if ( asistente == attendee ): logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido Atendee {} \" . format ( str ( asistente ))) if rol == \"\" : resultado = True elif self . asistentes [ asistente ][ 'rol' ] == rol : resultado = True return resultado def get_data ( self ): \"\"\" Obtiene los datos del evento en una cadena con formato ical Returns: (str): String con el evento en formato ical \"\"\" return self . Event . data __init__ ( evento ) Constructor de Evento. Crea atributos Event: caldav.Event asistentes: diccionario de asistentes {correo1,correo2,...} Parameters: Name Type Description Default evento caldav . Event Evento tipo caldav.Event required Source code in modulos\\gestor_calendario.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def __init__ ( self , evento : caldav . Event ): \"\"\" Constructor de Evento. Crea atributos: - Event: caldav.Event - asistentes: diccionario de asistentes {correo1,correo2,...} Args: evento: Evento tipo caldav.Event \"\"\" self . Event = evento self . asistentes = {} self . get_asistentes () asienta_asistentes ( ofertante = '' , demandante = '' ) Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: Type Description tuple [ bool , list [ str ], list [ str ]] Tupla que contiene un bool indicando si se hizo el cambio bien y dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados Source code in modulos\\gestor_calendario.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def asienta_asistentes ( self , ofertante : str = \"\" , demandante : str = \"\" ): \"\"\" Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: (tuple[bool,list[str],list[str]]):Tupla que contiene un bool indicando si se hizo el cambio bien y dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados \"\"\" lista_asentados = [] para_borrar = [] lista_borrados = [] try : if ofertante == \"\" and demandante == \"\" : for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : self . set_asistente ( asistente , rol = 'REQ-PARTICIPANT' ) lista_asentados . append ( asistente ) if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : para_borrar . append ( asistente ) for asistente in para_borrar : self . borrar_asistente ( asistente ) lista_borrados . append ( asistente ) return ( True , lista_borrados , lista_asentados ) else : self . borrar_asistente ( ofertante ) self . set_asistente ( demandante , rol = 'REQ-PARTICIPANT' , tipo = 'INDIVIDUAL' ) return ( True ,) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ( False ,) borrar_asistente ( asistente ) Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Parameters: Name Type Description Default asistente str correo del asistente a borrar required Returns: Type Description bool True si lo borra con \u00e9xito, False si no Source code in modulos\\gestor_calendario.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def borrar_asistente ( self , asistente : str ): \"\"\" Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Args: asistente: correo del asistente a borrar Returns: (bool):True si lo borra con \u00e9xito, False si no \"\"\" result = False try : del self . asistentes [ asistente ] existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == asistente : del self . Event . vobject_instance . vevent . attendee_list [ i ] existente = True result = True except KeyError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} . El correo del asistente no est\u00e1 incluido en el evento\" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False get_asistentes ( rol = '' , tipo = '' ) Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Parameters: Name Type Description Default rol str El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT '' tipo TIpo de asistente que se quiere obtener. Puede ser INDIVIDUAL or GROUP '' Returns: Type Description dict [ dict ] Devuelve un diccionario de diccionarios con clave principal el correo del usuario. Source code in modulos\\gestor_calendario.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_asistentes ( self , rol : str = \"\" , tipo = \"\" ): \"\"\" Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Args: rol: El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT tipo: TIpo de asistente que se quiere obtener. Puede ser INDIVIDUAL or GROUP Returns: (dict[dict]):Devuelve un diccionario de diccionarios con clave principal el correo del usuario. \"\"\" if self . asistentes == {}: if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): for asistente in self . Event . vobject_instance . vevent . contents [ 'attendee' ]: if 'ROLE' in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) elif 'ROLE' in asistente . params . keys () and 'CUTYPE' not in asistente . params . keys (): if asistente . params [ 'ROLE' ] == [ 'null' ]: self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) else : self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : 'INDIVIDUAL' }}) elif 'ROLE' not in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) else : self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) if rol != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == rol : diccionario_aux . update ({ asistente : self . asistentes [ asistente ]}) cuenta_aux += 1 return diccionario_aux if tipo != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'tipo' ] == tipo : diccionario_aux . update ({ asistente : self . asistentes [ asistente ]}) cuenta_aux += 1 return diccionario_aux else : return self . asistentes get_comprobar_asistente ( asistente , rol = '' ) Comprueba si un asistente est\u00e1 en un evento Parameters: Name Type Description Default asistente str Correo del asistente que se comprueba required rol str Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento '' Returns: Type Description bool True si est\u00e1 ( con el rol en concreto si es especificado), False si no Source code in modulos\\gestor_calendario.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def get_comprobar_asistente ( self , asistente : str , rol : str = \"\" ): \"\"\" Comprueba si un asistente est\u00e1 en un evento Args: asistente: Correo del asistente que se comprueba rol: Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento Returns: (bool):True si est\u00e1 ( con el rol en concreto si es especificado), False si no \"\"\" resultado = False for attendee in self . asistentes : if ( asistente == attendee ): logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido Atendee {} \" . format ( str ( asistente ))) if rol == \"\" : resultado = True elif self . asistentes [ asistente ][ 'rol' ] == rol : resultado = True return resultado get_cuenta_asistentes () Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: Type Description int Cantidad de asistentes requeridos a un evento. Source code in modulos\\gestor_calendario.py 338 339 340 341 342 343 344 345 346 347 348 349 350 def get_cuenta_asistentes ( self ): \"\"\" Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: (int):Cantidad de asistentes requeridos a un evento. \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"REQ-PARTICIPANT\" : cuenta += 1 return cuenta get_cuenta_demandantes () Obtiene cantidad de demandantes de un evento Returns: Type Description int Obtiene cantidad de asistentes con el rol NON-PARTICIPANT Source code in modulos\\gestor_calendario.py 365 366 367 368 369 370 371 372 373 374 375 376 377 def get_cuenta_demandantes ( self ): \"\"\" Obtiene cantidad de demandantes de un evento Returns: (int):Obtiene cantidad de asistentes con el rol NON-PARTICIPANT \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"NON-PARTICIPANT\" : cuenta += 1 return cuenta get_cuenta_ofertantes () Obtiene cuenta de ofertantes de un evento Returns: Type Description int Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento Source code in modulos\\gestor_calendario.py 351 352 353 354 355 356 357 358 359 360 361 362 363 def get_cuenta_ofertantes ( self ): \"\"\" Obtiene cuenta de ofertantes de un evento Returns: (int):Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"OPT-PARTICIPANT\" : cuenta += 1 return cuenta get_data () Obtiene los datos del evento en una cadena con formato ical Returns: Type Description str String con el evento en formato ical Source code in modulos\\gestor_calendario.py 448 449 450 451 452 453 454 455 456 def get_data ( self ): \"\"\" Obtiene los datos del evento en una cadena con formato ical Returns: (str): String con el evento en formato ical \"\"\" return self . Event . data get_fecha_datetime () Obtiene la fecha de inicio del evento en formato datetime Returns: Type Description datetime . datetime Fecha de inicio del evento Source code in modulos\\gestor_calendario.py 390 391 392 393 394 395 396 397 398 399 def get_fecha_datetime ( self ): \"\"\" Obtiene la fecha de inicio del evento en formato datetime Returns: (datetime.datetime):Fecha de inicio del evento \"\"\" fecha : datetime . datetime = self . Event . vobject_instance . vevent . dtstart . value fecha_madrid = fecha . astimezone ( tz = pytz . timezone ( 'Europe/Madrid' )) return fecha_madrid get_fecha_str () Obtiene la fecha de inicio del evento en formato cadena Returns: Type Description str Fecha en formato [dia-mes-a\u00f1o horas-minutos] Source code in modulos\\gestor_calendario.py 379 380 381 382 383 384 385 386 387 388 def get_fecha_str ( self ): \"\"\" Obtiene la fecha de inicio del evento en formato cadena Returns: (str): Fecha en formato [dia-mes-a\u00f1o horas-minutos] \"\"\" fecha : datetime . datetime = self . Event . vobject_instance . vevent . dtstart . value fecha_madrid = fecha . astimezone ( tz = pytz . timezone ( 'Europe/Madrid' )) return fecha_madrid . strftime ( ' %d -%m-%Y %H:%M' ) get_rol_asistente ( asistente ) Devuelve el rol del asistente que se pasa por par\u00e1metro Parameters: Name Type Description Default asistente str Correo del asistente required Returns: Type Description str rol del asistente en cadena Source code in modulos\\gestor_calendario.py 326 327 328 329 330 331 332 333 334 335 336 337 def get_rol_asistente ( self , asistente : str ): \"\"\" Devuelve el rol del asistente que se pasa por par\u00e1metro Args: asistente: Correo del asistente Returns: (str):rol del asistente en cadena \"\"\" return self . asistentes [ asistente ][ 'rol' ] get_sitios_libres () Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: Type Description int Cantidad de puestos libres Source code in modulos\\gestor_calendario.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def get_sitios_libres ( self ): \"\"\" Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: (int):Cantidad de puestos libres \"\"\" sitios_libres = 0 if self . asistentes != {}: for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'Optativo' en un evento. Significa que ya alguien pidi\u00f3 ceder el evento\" ) sitios_libres += 1 if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'No Participante' en un evento. Significa que ya alguien pidi\u00f3 obtener el evento que alguien cedi\u00f3\" ) sitios_libres -= 1 return sitios_libres get_summary () Obtiene nombre de evento o summary Returns: Type Description str Cadena con nombre del evento Source code in modulos\\gestor_calendario.py 111 112 113 114 115 116 117 118 def get_summary ( self ): \"\"\" Obtiene nombre de evento o summary Returns: (str):Cadena con nombre del evento \"\"\" return str ( self . Event . vobject_instance . vevent . summary . value ) get_uid () Obtiene uid del evento Returns: Type Description str Uid del evento Source code in modulos\\gestor_calendario.py 120 121 122 123 124 125 126 127 def get_uid ( self ): \"\"\" Obtiene uid del evento Returns: (str):Uid del evento \"\"\" return str ( self . Event . vobject_instance . vevent . uid . value ) negar_cambio_asistentes ( ofertante , demandante ) Niega el cambio de una guardia, borrando al demandante del evento y poniendo al ofertante de REQ-PARTICIPANT Parameters: Name Type Description Default ofertante str Correo del ofertante required demandante str Correo del demandante required Returns: Type Description bool True si realiza la negaci\u00f3n, False si no Source code in modulos\\gestor_calendario.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def negar_cambio_asistentes ( self , ofertante : str , demandante : str ): \"\"\" Niega el cambio de una guardia, borrando al demandante del evento y poniendo al ofertante de REQ-PARTICIPANT Args: ofertante: Correo del ofertante demandante: Correo del demandante Returns: (bool): True si realiza la negaci\u00f3n, False si no \"\"\" try : self . set_asistente ( ofertante , rol = 'REQ-PARTICIPANT' ) self . borrar_asistente ( demandante ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False set_asistente ( correo_asistente , rol = '' , tipo = 'INDIVIDUAL' ) Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Parameters: Name Type Description Default correo_asistente str Correo del asistente que estamos queriendo actualizar required rol str Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba '' tipo str Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. 'INDIVIDUAL' Returns: Type Description int 0 si es correcto, -1 si sucede una Excepci\u00f3n Source code in modulos\\gestor_calendario.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def set_asistente ( self , correo_asistente : str , rol : str = \"\" , tipo : str = 'INDIVIDUAL' ): \"\"\" Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Args: correo_asistente: Correo del asistente que estamos queriendo actualizar rol: Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba tipo: Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. Returns: (int): 0 si es correcto, -1 si sucede una Excepci\u00f3n \"\"\" try : asistente = self . asistentes [ correo_asistente ] except KeyError as k : self . asistentes [ correo_asistente ] = {} except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 finally : if rol != \"\" : self . asistentes [ correo_asistente ][ 'rol' ] = rol self . asistentes [ correo_asistente ][ 'tipo' ] = tipo if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == correo_asistente : self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'ROLE' : [ asistente [ 'rol' ]]}) self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'CUTYPE' : [ asistente [ 'tipo' ]]}) existente = True if not existente : try : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 else : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) return 0 start ( url_servicio , usuario = None , contrasena = None ) M\u00e9todo de m\u00f3dulo para cargar el cliente caldav en una variable de m\u00e9todo Parameters: Name Type Description Default url_servicio str url donde se encuentra el servidor caldav required usuario str usuario para acceder al servicio caldav None contrasena str contrase\u00f1a del servicio None Source code in modulos\\gestor_calendario.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def start ( url_servicio : str , usuario : str = None , contrasena : str = None ): \"\"\" M\u00e9todo de m\u00f3dulo para cargar el cliente caldav en una variable de m\u00e9todo Args: url_servicio: url donde se encuentra el servidor caldav usuario: usuario para acceder al servicio caldav contrasena: contrase\u00f1a del servicio \"\"\" global cliente try : cliente = caldav . DAVClient ( url = url_servicio , username = usuario , password = contrasena ) logging . getLogger ( __name__ ) . debug ( \"Iniciado url_servicio CALDAV\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e ))","title":"gestor_calendario"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario","text":"Clase para manejar un calendario con cliente calDAV Attributes: Name Type Description url str Nombre del calendario calendario caldav . Calendar Calendario conectado con cliente calDAV Source code in modulos\\gestor_calendario.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 class Calendario : \"\"\" Clase para manejar un calendario con cliente calDAV Attributes: url (str): Nombre del calendario calendario (caldav.Calendar): Calendario conectado con cliente calDAV \"\"\" def __init__ ( self , url : str = None ): \"\"\" Constructor de Calendario Args: url (str): La nombre del calendario que cargaremos \"\"\" self . url : str = url self . calendario : caldav . Calendar = None self . cargar_calendario ( self . url ) def cargar_calendario ( self , nombre : str ): \"\"\" Inicializaci\u00f3n del calendario mediante cliente calDAV Args: nombre: nombre del calendario perteneciente al usuario de calDAV \"\"\" global cliente self . calendario = cliente . principal () . calendar ( cal_id = nombre ) @staticmethod def get_fecha_inicio_mes (): \"\"\" Funci\u00f3n para calcular fecha inicio mes Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'month' ) . datetime @staticmethod def get_fecha_hoy (): \"\"\" Funci\u00f3n para calcular fecha de hoy Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'hour' ) . datetime # Funci\u00f3n para calcular el timestamp del \u00faltimo d\u00eda del mes @staticmethod def get_fecha_fin_mes (): \"\"\" Funci\u00f3n para calcular fecha fin mes Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . ceil ( 'month' ) . datetime @staticmethod def ordenar_eventos ( lista_eventos : list [ Evento ]): \"\"\" Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Args: lista_eventos: Lista de eventos a ordenar por fecha Returns: (list[Evento]|None):Lista ordenada de eventos \"\"\" lista_ordenada : list [ Evento ] = lista_eventos try : lista_ordenada = sorted ( lista_eventos , key = lambda x : x . get_fecha_str ()) except BaseException as exception : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , exception )) return None finally : return lista_ordenada def get_eventos ( self , attendee : str | None = None , rol : str = \"\" , completos : bool = False ): \"\"\" Obtiene los eventos de un calendario en el periodo del mes actual. Args: attendee: Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. rol: Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante completos: Se solicitan eventos que ya se puede ejecutar una cesi\u00f3n o intercambio. Returns: (list[Evento]):Lista de Evento \"\"\" lista_eventos = [] lista_eventos_aux = [] no_pedido = False sitios_libres = 0 sin_sitio = False try : eventosmes = self . calendario . date_search ( start = self . get_fecha_hoy (), end = self . get_fecha_fin_mes (), expand = True ) for x in eventosmes : lista_eventos_aux . append ( Evento ( x )) for e in lista_eventos_aux : fecha = e . get_fecha_datetime () if self . get_fecha_fin_mes () > datetime . datetime ( fecha . year , fecha . month , fecha . day , 0 , 0 , 0 , 0 , pytz . timezone ( 'Europe/Madrid' )) > self . get_fecha_inicio_mes (): logging . getLogger ( __name__ ) . debug ( \"Evento en el periodo actual \" + str ( e )) if ( completos == True ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos para aprobar o denegar\" ) if e . get_cuenta_demandantes () == e . get_cuenta_ofertantes () and e . get_sitios_libres () == 0 : lista_eventos . append ( e ) elif ( attendee == None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos libres\" ) if e . get_sitios_libres () > 0 : lista_eventos . append ( e ) elif ( attendee != None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos de una persona\" ) if e . get_comprobar_asistente ( attendee , rol = rol ): lista_eventos . append ( e ) logging . getLogger ( __name__ ) . debug ( \"Lista de eventos en get_eventos:\" + str ( lista_eventos )) lista_ordenada = self . ordenar_eventos ( lista_eventos ) return lista_ordenada except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) print ( \"Error cargando eventos: \" + str ( e )) return None def get_evento ( self , uid_evento : str ): \"\"\" Obtiene un evento a partir de la uid del evento Args: uid_evento: identificador \u00fanico del evento Returns: (Evento|None):Evento con uid=uid_evento o None en caso de no encontrarse \"\"\" try : return Evento ( self . calendario . event_by_uid ( uid = uid_evento )) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def asentar_cambios ( self , uid_evento : str ): \"\"\" Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Args: uid_evento: Identificador \u00fanico del evento Returns: (tuple[list[str],list[str],Evento]): Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento \"\"\" try : evento = self . get_evento ( uid_evento ) ( borrados , asentados ) = evento . asienta_asistentes () return ( borrados , asentados , evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ([],[], None ) def set_evento ( self , evento : Evento ): \"\"\" Guarda un evento en el calendario Args: evento: (gestor_calendario.Evento) Evento a guardar Returns: (bool):Verdadero si pudo hacerlo, falso si no \"\"\" try : evento_encontrado = self . calendario . event_by_uid ( uid = evento . get_uid ()) if isinstance ( evento_encontrado , caldav . Event ): evento_encontrado . data = evento . Event . data self . calendario . save_event ( evento_encontrado . data ) return True except caldav . lib . error . NotFoundError as e : logging . getLogger ( __name__ ) . info ( \"Evento {} no existente en calendario. Funci\u00f3n ejecutada {} \" . format ( evento . get_uid (), sys . _getframe ( 1 ) . f_code . co_name )) logging . getLogger ( __name__ ) . info ( \"Evento a introducir {} en calendario {} con data {} \" . format ( str ( evento ), str ( self . calendario . canonical_url ), str ( evento . Event . data ))) self . calendario . save_event ( evento . Event . data ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def ofertar_evento ( self , correo_usuario : str , uid_evento : str , tipo : str = 'INDIVIDUAL' , evento : Evento = None ): \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT, el tipo a INDIVIDUAL y guarda el evento en el calendario Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: (Evento|None):Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ): evento_buscado . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" , tipo = tipo ) evento_cedido = self . set_evento ( evento_buscado ) if evento_cedido == True : return evento_buscado if isinstance ( evento , Evento ) and not isinstance ( evento_buscado , Evento ) : if evento . get_comprobar_asistente ( correo_usuario ): evento . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" , tipo = tipo ) evento_cedido = self . set_evento ( evento ) if evento_cedido == True : return self . get_evento ( uid_evento = uid_evento ) except Exception as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception def cancelar_evento ( self , correo_usuario : str , uid_evento : str ): \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario Returns: (Evento|None): Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" evento_cancelado = False try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento_cancelado ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): rol_asistente = evento_buscado . get_rol_asistente ( asistente = correo_usuario ) if rol_asistente == \"OPT-PARTICIPANT\" : ofertantes = evento_buscado . get_cuenta_ofertantes () demandantes = evento_buscado . get_cuenta_demandantes () asistentes = evento_buscado . get_cuenta_asistentes () if ofertantes > demandantes : evento_buscado . set_asistente ( correo_usuario , rol = \"REQ-PARTICIPANT\" ) evento_cancelado = self . set_evento ( evento_buscado ) \"\"\"Se env\u00eda un mensaje al usuario indicando que no puede realizar esta acci\u00f3n\"\"\" ofertantes = evento_buscado . get_cuenta_ofertantes () if ofertantes == 0 : evento_buscado . Event . delete () evento_cancelado = True if rol_asistente == \"NON-PARTICIPANT\" : evento_buscado . borrar_asistente ( correo_usuario ) evento_cancelado = self . set_evento ( evento_buscado ) if evento_cancelado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def borrar_evento ( self , uid_evento : str ) -> bool : \"\"\" Borra el evento del calendario con la uid correspondiente Args: uid_evento: uid del evento que se desea borrar Returns: Devuelve True si lo borr\u00f3, False si no \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): evento_buscado . Event . delete () return True else : return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def tomar_evento ( self , correo_usuario : str , uid_evento : str , tipo = 'INDIVIDUAL' ) -> Evento | None : \"\"\" Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Args: correo_usuario: Correo del usuario que tomar\u00e1 la plaza libre del evento uid_evento: Identificador \u00fanico del evento Returns: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ) != True and evento_buscado . get_sitios_libres () > 0 : evento_buscado . set_asistente ( correo_usuario , rol = \"NON-PARTICIPANT\" , tipo = tipo ) evento_tomado = self . set_evento ( evento_buscado ) if evento_tomado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"Calendario"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.__init__","text":"Constructor de Calendario Parameters: Name Type Description Default url str La nombre del calendario que cargaremos None Source code in modulos\\gestor_calendario.py 467 468 469 470 471 472 473 474 475 476 def __init__ ( self , url : str = None ): \"\"\" Constructor de Calendario Args: url (str): La nombre del calendario que cargaremos \"\"\" self . url : str = url self . calendario : caldav . Calendar = None self . cargar_calendario ( self . url )","title":"__init__()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.asentar_cambios","text":"Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Parameters: Name Type Description Default uid_evento str Identificador \u00fanico del evento required Returns: Type Description tuple [ list [ str ], list [ str ], Evento ] Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento Source code in modulos\\gestor_calendario.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def asentar_cambios ( self , uid_evento : str ): \"\"\" Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Args: uid_evento: Identificador \u00fanico del evento Returns: (tuple[list[str],list[str],Evento]): Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento \"\"\" try : evento = self . get_evento ( uid_evento ) ( borrados , asentados ) = evento . asienta_asistentes () return ( borrados , asentados , evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ([],[], None )","title":"asentar_cambios()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.borrar_evento","text":"Borra el evento del calendario con la uid correspondiente Parameters: Name Type Description Default uid_evento str uid del evento que se desea borrar required Returns: Type Description bool Devuelve True si lo borr\u00f3, False si no Source code in modulos\\gestor_calendario.py 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def borrar_evento ( self , uid_evento : str ) -> bool : \"\"\" Borra el evento del calendario con la uid correspondiente Args: uid_evento: uid del evento que se desea borrar Returns: Devuelve True si lo borr\u00f3, False si no \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): evento_buscado . Event . delete () return True else : return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"borrar_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.cancelar_evento","text":"Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default correo_usuario str Correo del usuario que se est\u00e1 tratando de cambiar el rol required uid_evento str UID del evento que se est\u00e1 buscando en el calendario required Returns: Type Description Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 def cancelar_evento ( self , correo_usuario : str , uid_evento : str ): \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario Returns: (Evento|None): Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" evento_cancelado = False try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento_cancelado ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): rol_asistente = evento_buscado . get_rol_asistente ( asistente = correo_usuario ) if rol_asistente == \"OPT-PARTICIPANT\" : ofertantes = evento_buscado . get_cuenta_ofertantes () demandantes = evento_buscado . get_cuenta_demandantes () asistentes = evento_buscado . get_cuenta_asistentes () if ofertantes > demandantes : evento_buscado . set_asistente ( correo_usuario , rol = \"REQ-PARTICIPANT\" ) evento_cancelado = self . set_evento ( evento_buscado ) \"\"\"Se env\u00eda un mensaje al usuario indicando que no puede realizar esta acci\u00f3n\"\"\" ofertantes = evento_buscado . get_cuenta_ofertantes () if ofertantes == 0 : evento_buscado . Event . delete () evento_cancelado = True if rol_asistente == \"NON-PARTICIPANT\" : evento_buscado . borrar_asistente ( correo_usuario ) evento_cancelado = self . set_evento ( evento_buscado ) if evento_cancelado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"cancelar_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.cargar_calendario","text":"Inicializaci\u00f3n del calendario mediante cliente calDAV Parameters: Name Type Description Default nombre str nombre del calendario perteneciente al usuario de calDAV required Source code in modulos\\gestor_calendario.py 478 479 480 481 482 483 484 485 486 487 def cargar_calendario ( self , nombre : str ): \"\"\" Inicializaci\u00f3n del calendario mediante cliente calDAV Args: nombre: nombre del calendario perteneciente al usuario de calDAV \"\"\" global cliente self . calendario = cliente . principal () . calendar ( cal_id = nombre )","title":"cargar_calendario()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_evento","text":"Obtiene un evento a partir de la uid del evento Parameters: Name Type Description Default uid_evento str identificador \u00fanico del evento required Returns: Type Description Evento | None Evento con uid=uid_evento o None en caso de no encontrarse Source code in modulos\\gestor_calendario.py 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def get_evento ( self , uid_evento : str ): \"\"\" Obtiene un evento a partir de la uid del evento Args: uid_evento: identificador \u00fanico del evento Returns: (Evento|None):Evento con uid=uid_evento o None en caso de no encontrarse \"\"\" try : return Evento ( self . calendario . event_by_uid ( uid = uid_evento )) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"get_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_eventos","text":"Obtiene los eventos de un calendario en el periodo del mes actual. Parameters: Name Type Description Default attendee str | None Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. None rol str Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante '' completos bool Se solicitan eventos que ya se puede ejecutar una cesi\u00f3n o intercambio. False Returns: Type Description list [ Evento ] Lista de Evento Source code in modulos\\gestor_calendario.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def get_eventos ( self , attendee : str | None = None , rol : str = \"\" , completos : bool = False ): \"\"\" Obtiene los eventos de un calendario en el periodo del mes actual. Args: attendee: Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. rol: Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante completos: Se solicitan eventos que ya se puede ejecutar una cesi\u00f3n o intercambio. Returns: (list[Evento]):Lista de Evento \"\"\" lista_eventos = [] lista_eventos_aux = [] no_pedido = False sitios_libres = 0 sin_sitio = False try : eventosmes = self . calendario . date_search ( start = self . get_fecha_hoy (), end = self . get_fecha_fin_mes (), expand = True ) for x in eventosmes : lista_eventos_aux . append ( Evento ( x )) for e in lista_eventos_aux : fecha = e . get_fecha_datetime () if self . get_fecha_fin_mes () > datetime . datetime ( fecha . year , fecha . month , fecha . day , 0 , 0 , 0 , 0 , pytz . timezone ( 'Europe/Madrid' )) > self . get_fecha_inicio_mes (): logging . getLogger ( __name__ ) . debug ( \"Evento en el periodo actual \" + str ( e )) if ( completos == True ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos para aprobar o denegar\" ) if e . get_cuenta_demandantes () == e . get_cuenta_ofertantes () and e . get_sitios_libres () == 0 : lista_eventos . append ( e ) elif ( attendee == None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos libres\" ) if e . get_sitios_libres () > 0 : lista_eventos . append ( e ) elif ( attendee != None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos de una persona\" ) if e . get_comprobar_asistente ( attendee , rol = rol ): lista_eventos . append ( e ) logging . getLogger ( __name__ ) . debug ( \"Lista de eventos en get_eventos:\" + str ( lista_eventos )) lista_ordenada = self . ordenar_eventos ( lista_eventos ) return lista_ordenada except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) print ( \"Error cargando eventos: \" + str ( e )) return None","title":"get_eventos()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_fecha_fin_mes","text":"Funci\u00f3n para calcular fecha fin mes Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 509 510 511 512 513 514 515 516 517 @staticmethod def get_fecha_fin_mes (): \"\"\" Funci\u00f3n para calcular fecha fin mes Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . ceil ( 'month' ) . datetime","title":"get_fecha_fin_mes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_fecha_hoy","text":"Funci\u00f3n para calcular fecha de hoy Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 499 500 501 502 503 504 505 506 507 @staticmethod def get_fecha_hoy (): \"\"\" Funci\u00f3n para calcular fecha de hoy Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'hour' ) . datetime","title":"get_fecha_hoy()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_fecha_inicio_mes","text":"Funci\u00f3n para calcular fecha inicio mes Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 489 490 491 492 493 494 495 496 497 @staticmethod def get_fecha_inicio_mes (): \"\"\" Funci\u00f3n para calcular fecha inicio mes Returns: (datetime.datetime):Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'month' ) . datetime","title":"get_fecha_inicio_mes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.ofertar_evento","text":"Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT, el tipo a INDIVIDUAL y guarda el evento en el calendario Parameters: Name Type Description Default correo_usuario str Correo del usuario que se est\u00e1 tratando de cambiar el rol required uid_evento str UID del evento que se est\u00e1 buscando en el calendario required evento Evento Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento None Returns: Type Description Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 def ofertar_evento ( self , correo_usuario : str , uid_evento : str , tipo : str = 'INDIVIDUAL' , evento : Evento = None ): \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT, el tipo a INDIVIDUAL y guarda el evento en el calendario Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: (Evento|None):Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ): evento_buscado . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" , tipo = tipo ) evento_cedido = self . set_evento ( evento_buscado ) if evento_cedido == True : return evento_buscado if isinstance ( evento , Evento ) and not isinstance ( evento_buscado , Evento ) : if evento . get_comprobar_asistente ( correo_usuario ): evento . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" , tipo = tipo ) evento_cedido = self . set_evento ( evento ) if evento_cedido == True : return self . get_evento ( uid_evento = uid_evento ) except Exception as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception","title":"ofertar_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.ordenar_eventos","text":"Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Parameters: Name Type Description Default lista_eventos list [ Evento ] Lista de eventos a ordenar por fecha required Returns: Type Description list [ Evento ] | None Lista ordenada de eventos Source code in modulos\\gestor_calendario.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 @staticmethod def ordenar_eventos ( lista_eventos : list [ Evento ]): \"\"\" Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Args: lista_eventos: Lista de eventos a ordenar por fecha Returns: (list[Evento]|None):Lista ordenada de eventos \"\"\" lista_ordenada : list [ Evento ] = lista_eventos try : lista_ordenada = sorted ( lista_eventos , key = lambda x : x . get_fecha_str ()) except BaseException as exception : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , exception )) return None finally : return lista_ordenada","title":"ordenar_eventos()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.set_evento","text":"Guarda un evento en el calendario Parameters: Name Type Description Default evento Evento (gestor_calendario.Evento) Evento a guardar required Returns: Type Description bool Verdadero si pudo hacerlo, falso si no Source code in modulos\\gestor_calendario.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 def set_evento ( self , evento : Evento ): \"\"\" Guarda un evento en el calendario Args: evento: (gestor_calendario.Evento) Evento a guardar Returns: (bool):Verdadero si pudo hacerlo, falso si no \"\"\" try : evento_encontrado = self . calendario . event_by_uid ( uid = evento . get_uid ()) if isinstance ( evento_encontrado , caldav . Event ): evento_encontrado . data = evento . Event . data self . calendario . save_event ( evento_encontrado . data ) return True except caldav . lib . error . NotFoundError as e : logging . getLogger ( __name__ ) . info ( \"Evento {} no existente en calendario. Funci\u00f3n ejecutada {} \" . format ( evento . get_uid (), sys . _getframe ( 1 ) . f_code . co_name )) logging . getLogger ( __name__ ) . info ( \"Evento a introducir {} en calendario {} con data {} \" . format ( str ( evento ), str ( self . calendario . canonical_url ), str ( evento . Event . data ))) self . calendario . save_event ( evento . Event . data ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"set_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.tomar_evento","text":"Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Parameters: Name Type Description Default correo_usuario str Correo del usuario que tomar\u00e1 la plaza libre del evento required uid_evento str Identificador \u00fanico del evento required Returns: Type Description Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 def tomar_evento ( self , correo_usuario : str , uid_evento : str , tipo = 'INDIVIDUAL' ) -> Evento | None : \"\"\" Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Args: correo_usuario: Correo del usuario que tomar\u00e1 la plaza libre del evento uid_evento: Identificador \u00fanico del evento Returns: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ) != True and evento_buscado . get_sitios_libres () > 0 : evento_buscado . set_asistente ( correo_usuario , rol = \"NON-PARTICIPANT\" , tipo = tipo ) evento_tomado = self . set_evento ( evento_buscado ) if evento_tomado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"tomar_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento","text":"Clase que envuelve a un objeto de clase caldav.Event Genera m\u00e9todos que permitan operar con este objeto con m\u00e1s facilidad En el objeto caldav.Event Attendee es un diccionario de diccionarios. La clave es el correo del asistente, y da como resultado un diccionario que contiene rol y tipo de asistente. Los envuelve en listas, pero con esta clase vamos a convertirlo en un diccionario de diccionarios. Los roles del asistente son: REQ-PARTICIPANT: Significa asistente obligatorio al calendario OPT-PARTICIPANT: Empleado que pretende ceder este turno NON-PARTICIPANT: Empleado que quiere tomar este turno Los tipos del asistente son: INDIVIDUAL: Se usa para indicar cesiones. GROUP: Se usa para indicar intercambio. RESOURCE: Sin uso. ROOM: Sin uso. Ejemplos: { correo1: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE}, correo2: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE} } Attributes: Name Type Description Event caldav . Event Evento tipo caldav.Event asistentes dict [ dict ] Diccionario de asistentes Source code in modulos\\gestor_calendario.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 class Evento : \"\"\" Clase que envuelve a un objeto de clase caldav.Event Genera m\u00e9todos que permitan operar con este objeto con m\u00e1s facilidad En el objeto caldav.Event Attendee es un diccionario de diccionarios. La clave es el correo del asistente, y da como resultado un diccionario que contiene rol y tipo de asistente. Los envuelve en listas, pero con esta clase vamos a convertirlo en un diccionario de diccionarios. ``` Los roles del asistente son: REQ-PARTICIPANT: Significa asistente obligatorio al calendario OPT-PARTICIPANT: Empleado que pretende ceder este turno NON-PARTICIPANT: Empleado que quiere tomar este turno Los tipos del asistente son: INDIVIDUAL: Se usa para indicar cesiones. GROUP: Se usa para indicar intercambio. RESOURCE: Sin uso. ROOM: Sin uso. Ejemplos: { correo1: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE}, correo2: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE} } ``` Attributes: Event (caldav.Event): Evento tipo caldav.Event asistentes (dict[dict]): Diccionario de asistentes \"\"\" def __init__ ( self , evento : caldav . Event ): \"\"\" Constructor de Evento. Crea atributos: - Event: caldav.Event - asistentes: diccionario de asistentes {correo1,correo2,...} Args: evento: Evento tipo caldav.Event \"\"\" self . Event = evento self . asistentes = {} self . get_asistentes () def get_summary ( self ): \"\"\" Obtiene nombre de evento o summary Returns: (str):Cadena con nombre del evento \"\"\" return str ( self . Event . vobject_instance . vevent . summary . value ) def get_uid ( self ): \"\"\" Obtiene uid del evento Returns: (str):Uid del evento \"\"\" return str ( self . Event . vobject_instance . vevent . uid . value ) def get_asistentes ( self , rol : str = \"\" , tipo = \"\" ): \"\"\" Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Args: rol: El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT tipo: TIpo de asistente que se quiere obtener. Puede ser INDIVIDUAL or GROUP Returns: (dict[dict]):Devuelve un diccionario de diccionarios con clave principal el correo del usuario. \"\"\" if self . asistentes == {}: if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): for asistente in self . Event . vobject_instance . vevent . contents [ 'attendee' ]: if 'ROLE' in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) elif 'ROLE' in asistente . params . keys () and 'CUTYPE' not in asistente . params . keys (): if asistente . params [ 'ROLE' ] == [ 'null' ]: self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) else : self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : 'INDIVIDUAL' }}) elif 'ROLE' not in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) else : self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) if rol != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == rol : diccionario_aux . update ({ asistente : self . asistentes [ asistente ]}) cuenta_aux += 1 return diccionario_aux if tipo != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'tipo' ] == tipo : diccionario_aux . update ({ asistente : self . asistentes [ asistente ]}) cuenta_aux += 1 return diccionario_aux else : return self . asistentes def set_asistente ( self , correo_asistente : str , rol : str = \"\" , tipo : str = 'INDIVIDUAL' ): \"\"\" Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Args: correo_asistente: Correo del asistente que estamos queriendo actualizar rol: Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba tipo: Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. Returns: (int): 0 si es correcto, -1 si sucede una Excepci\u00f3n \"\"\" try : asistente = self . asistentes [ correo_asistente ] except KeyError as k : self . asistentes [ correo_asistente ] = {} except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 finally : if rol != \"\" : self . asistentes [ correo_asistente ][ 'rol' ] = rol self . asistentes [ correo_asistente ][ 'tipo' ] = tipo if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == correo_asistente : self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'ROLE' : [ asistente [ 'rol' ]]}) self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'CUTYPE' : [ asistente [ 'tipo' ]]}) existente = True if not existente : try : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 else : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) return 0 def borrar_asistente ( self , asistente : str ): \"\"\" Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Args: asistente: correo del asistente a borrar Returns: (bool):True si lo borra con \u00e9xito, False si no \"\"\" result = False try : del self . asistentes [ asistente ] existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == asistente : del self . Event . vobject_instance . vevent . attendee_list [ i ] existente = True result = True except KeyError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} . El correo del asistente no est\u00e1 incluido en el evento\" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def asienta_asistentes ( self , ofertante : str = \"\" , demandante : str = \"\" ): \"\"\" Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: (tuple[bool,list[str],list[str]]):Tupla que contiene un bool indicando si se hizo el cambio bien y dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados \"\"\" lista_asentados = [] para_borrar = [] lista_borrados = [] try : if ofertante == \"\" and demandante == \"\" : for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : self . set_asistente ( asistente , rol = 'REQ-PARTICIPANT' ) lista_asentados . append ( asistente ) if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : para_borrar . append ( asistente ) for asistente in para_borrar : self . borrar_asistente ( asistente ) lista_borrados . append ( asistente ) return ( True , lista_borrados , lista_asentados ) else : self . borrar_asistente ( ofertante ) self . set_asistente ( demandante , rol = 'REQ-PARTICIPANT' , tipo = 'INDIVIDUAL' ) return ( True ,) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ( False ,) def negar_cambio_asistentes ( self , ofertante : str , demandante : str ): \"\"\" Niega el cambio de una guardia, borrando al demandante del evento y poniendo al ofertante de REQ-PARTICIPANT Args: ofertante: Correo del ofertante demandante: Correo del demandante Returns: (bool): True si realiza la negaci\u00f3n, False si no \"\"\" try : self . set_asistente ( ofertante , rol = 'REQ-PARTICIPANT' ) self . borrar_asistente ( demandante ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def get_rol_asistente ( self , asistente : str ): \"\"\" Devuelve el rol del asistente que se pasa por par\u00e1metro Args: asistente: Correo del asistente Returns: (str):rol del asistente en cadena \"\"\" return self . asistentes [ asistente ][ 'rol' ] def get_cuenta_asistentes ( self ): \"\"\" Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: (int):Cantidad de asistentes requeridos a un evento. \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"REQ-PARTICIPANT\" : cuenta += 1 return cuenta def get_cuenta_ofertantes ( self ): \"\"\" Obtiene cuenta de ofertantes de un evento Returns: (int):Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"OPT-PARTICIPANT\" : cuenta += 1 return cuenta def get_cuenta_demandantes ( self ): \"\"\" Obtiene cantidad de demandantes de un evento Returns: (int):Obtiene cantidad de asistentes con el rol NON-PARTICIPANT \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"NON-PARTICIPANT\" : cuenta += 1 return cuenta def get_fecha_str ( self ): \"\"\" Obtiene la fecha de inicio del evento en formato cadena Returns: (str): Fecha en formato [dia-mes-a\u00f1o horas-minutos] \"\"\" fecha : datetime . datetime = self . Event . vobject_instance . vevent . dtstart . value fecha_madrid = fecha . astimezone ( tz = pytz . timezone ( 'Europe/Madrid' )) return fecha_madrid . strftime ( ' %d -%m-%Y %H:%M' ) def get_fecha_datetime ( self ): \"\"\" Obtiene la fecha de inicio del evento en formato datetime Returns: (datetime.datetime):Fecha de inicio del evento \"\"\" fecha : datetime . datetime = self . Event . vobject_instance . vevent . dtstart . value fecha_madrid = fecha . astimezone ( tz = pytz . timezone ( 'Europe/Madrid' )) return fecha_madrid def get_sitios_libres ( self ): \"\"\" Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: (int):Cantidad de puestos libres \"\"\" sitios_libres = 0 if self . asistentes != {}: for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'Optativo' en un evento. Significa que ya alguien pidi\u00f3 ceder el evento\" ) sitios_libres += 1 if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'No Participante' en un evento. Significa que ya alguien pidi\u00f3 obtener el evento que alguien cedi\u00f3\" ) sitios_libres -= 1 return sitios_libres def get_comprobar_asistente ( self , asistente : str , rol : str = \"\" ): \"\"\" Comprueba si un asistente est\u00e1 en un evento Args: asistente: Correo del asistente que se comprueba rol: Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento Returns: (bool):True si est\u00e1 ( con el rol en concreto si es especificado), False si no \"\"\" resultado = False for attendee in self . asistentes : if ( asistente == attendee ): logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido Atendee {} \" . format ( str ( asistente ))) if rol == \"\" : resultado = True elif self . asistentes [ asistente ][ 'rol' ] == rol : resultado = True return resultado def get_data ( self ): \"\"\" Obtiene los datos del evento en una cadena con formato ical Returns: (str): String con el evento en formato ical \"\"\" return self . Event . data","title":"Evento"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.__init__","text":"Constructor de Evento. Crea atributos Event: caldav.Event asistentes: diccionario de asistentes {correo1,correo2,...} Parameters: Name Type Description Default evento caldav . Event Evento tipo caldav.Event required Source code in modulos\\gestor_calendario.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def __init__ ( self , evento : caldav . Event ): \"\"\" Constructor de Evento. Crea atributos: - Event: caldav.Event - asistentes: diccionario de asistentes {correo1,correo2,...} Args: evento: Evento tipo caldav.Event \"\"\" self . Event = evento self . asistentes = {} self . get_asistentes ()","title":"__init__()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.asienta_asistentes","text":"Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: Type Description tuple [ bool , list [ str ], list [ str ]] Tupla que contiene un bool indicando si se hizo el cambio bien y dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados Source code in modulos\\gestor_calendario.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def asienta_asistentes ( self , ofertante : str = \"\" , demandante : str = \"\" ): \"\"\" Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: (tuple[bool,list[str],list[str]]):Tupla que contiene un bool indicando si se hizo el cambio bien y dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados \"\"\" lista_asentados = [] para_borrar = [] lista_borrados = [] try : if ofertante == \"\" and demandante == \"\" : for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : self . set_asistente ( asistente , rol = 'REQ-PARTICIPANT' ) lista_asentados . append ( asistente ) if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : para_borrar . append ( asistente ) for asistente in para_borrar : self . borrar_asistente ( asistente ) lista_borrados . append ( asistente ) return ( True , lista_borrados , lista_asentados ) else : self . borrar_asistente ( ofertante ) self . set_asistente ( demandante , rol = 'REQ-PARTICIPANT' , tipo = 'INDIVIDUAL' ) return ( True ,) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ( False ,)","title":"asienta_asistentes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.borrar_asistente","text":"Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Parameters: Name Type Description Default asistente str correo del asistente a borrar required Returns: Type Description bool True si lo borra con \u00e9xito, False si no Source code in modulos\\gestor_calendario.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def borrar_asistente ( self , asistente : str ): \"\"\" Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Args: asistente: correo del asistente a borrar Returns: (bool):True si lo borra con \u00e9xito, False si no \"\"\" result = False try : del self . asistentes [ asistente ] existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == asistente : del self . Event . vobject_instance . vevent . attendee_list [ i ] existente = True result = True except KeyError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} . El correo del asistente no est\u00e1 incluido en el evento\" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"borrar_asistente()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_asistentes","text":"Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Parameters: Name Type Description Default rol str El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT '' tipo TIpo de asistente que se quiere obtener. Puede ser INDIVIDUAL or GROUP '' Returns: Type Description dict [ dict ] Devuelve un diccionario de diccionarios con clave principal el correo del usuario. Source code in modulos\\gestor_calendario.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_asistentes ( self , rol : str = \"\" , tipo = \"\" ): \"\"\" Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Args: rol: El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT tipo: TIpo de asistente que se quiere obtener. Puede ser INDIVIDUAL or GROUP Returns: (dict[dict]):Devuelve un diccionario de diccionarios con clave principal el correo del usuario. \"\"\" if self . asistentes == {}: if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): for asistente in self . Event . vobject_instance . vevent . contents [ 'attendee' ]: if 'ROLE' in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) elif 'ROLE' in asistente . params . keys () and 'CUTYPE' not in asistente . params . keys (): if asistente . params [ 'ROLE' ] == [ 'null' ]: self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) else : self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : 'INDIVIDUAL' }}) elif 'ROLE' not in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) else : self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) if rol != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == rol : diccionario_aux . update ({ asistente : self . asistentes [ asistente ]}) cuenta_aux += 1 return diccionario_aux if tipo != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'tipo' ] == tipo : diccionario_aux . update ({ asistente : self . asistentes [ asistente ]}) cuenta_aux += 1 return diccionario_aux else : return self . asistentes","title":"get_asistentes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_comprobar_asistente","text":"Comprueba si un asistente est\u00e1 en un evento Parameters: Name Type Description Default asistente str Correo del asistente que se comprueba required rol str Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento '' Returns: Type Description bool True si est\u00e1 ( con el rol en concreto si es especificado), False si no Source code in modulos\\gestor_calendario.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def get_comprobar_asistente ( self , asistente : str , rol : str = \"\" ): \"\"\" Comprueba si un asistente est\u00e1 en un evento Args: asistente: Correo del asistente que se comprueba rol: Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento Returns: (bool):True si est\u00e1 ( con el rol en concreto si es especificado), False si no \"\"\" resultado = False for attendee in self . asistentes : if ( asistente == attendee ): logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido Atendee {} \" . format ( str ( asistente ))) if rol == \"\" : resultado = True elif self . asistentes [ asistente ][ 'rol' ] == rol : resultado = True return resultado","title":"get_comprobar_asistente()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_cuenta_asistentes","text":"Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: Type Description int Cantidad de asistentes requeridos a un evento. Source code in modulos\\gestor_calendario.py 338 339 340 341 342 343 344 345 346 347 348 349 350 def get_cuenta_asistentes ( self ): \"\"\" Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: (int):Cantidad de asistentes requeridos a un evento. \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"REQ-PARTICIPANT\" : cuenta += 1 return cuenta","title":"get_cuenta_asistentes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_cuenta_demandantes","text":"Obtiene cantidad de demandantes de un evento Returns: Type Description int Obtiene cantidad de asistentes con el rol NON-PARTICIPANT Source code in modulos\\gestor_calendario.py 365 366 367 368 369 370 371 372 373 374 375 376 377 def get_cuenta_demandantes ( self ): \"\"\" Obtiene cantidad de demandantes de un evento Returns: (int):Obtiene cantidad de asistentes con el rol NON-PARTICIPANT \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"NON-PARTICIPANT\" : cuenta += 1 return cuenta","title":"get_cuenta_demandantes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_cuenta_ofertantes","text":"Obtiene cuenta de ofertantes de un evento Returns: Type Description int Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento Source code in modulos\\gestor_calendario.py 351 352 353 354 355 356 357 358 359 360 361 362 363 def get_cuenta_ofertantes ( self ): \"\"\" Obtiene cuenta de ofertantes de un evento Returns: (int):Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"OPT-PARTICIPANT\" : cuenta += 1 return cuenta","title":"get_cuenta_ofertantes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_data","text":"Obtiene los datos del evento en una cadena con formato ical Returns: Type Description str String con el evento en formato ical Source code in modulos\\gestor_calendario.py 448 449 450 451 452 453 454 455 456 def get_data ( self ): \"\"\" Obtiene los datos del evento en una cadena con formato ical Returns: (str): String con el evento en formato ical \"\"\" return self . Event . data","title":"get_data()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_fecha_datetime","text":"Obtiene la fecha de inicio del evento en formato datetime Returns: Type Description datetime . datetime Fecha de inicio del evento Source code in modulos\\gestor_calendario.py 390 391 392 393 394 395 396 397 398 399 def get_fecha_datetime ( self ): \"\"\" Obtiene la fecha de inicio del evento en formato datetime Returns: (datetime.datetime):Fecha de inicio del evento \"\"\" fecha : datetime . datetime = self . Event . vobject_instance . vevent . dtstart . value fecha_madrid = fecha . astimezone ( tz = pytz . timezone ( 'Europe/Madrid' )) return fecha_madrid","title":"get_fecha_datetime()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_fecha_str","text":"Obtiene la fecha de inicio del evento en formato cadena Returns: Type Description str Fecha en formato [dia-mes-a\u00f1o horas-minutos] Source code in modulos\\gestor_calendario.py 379 380 381 382 383 384 385 386 387 388 def get_fecha_str ( self ): \"\"\" Obtiene la fecha de inicio del evento en formato cadena Returns: (str): Fecha en formato [dia-mes-a\u00f1o horas-minutos] \"\"\" fecha : datetime . datetime = self . Event . vobject_instance . vevent . dtstart . value fecha_madrid = fecha . astimezone ( tz = pytz . timezone ( 'Europe/Madrid' )) return fecha_madrid . strftime ( ' %d -%m-%Y %H:%M' )","title":"get_fecha_str()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_rol_asistente","text":"Devuelve el rol del asistente que se pasa por par\u00e1metro Parameters: Name Type Description Default asistente str Correo del asistente required Returns: Type Description str rol del asistente en cadena Source code in modulos\\gestor_calendario.py 326 327 328 329 330 331 332 333 334 335 336 337 def get_rol_asistente ( self , asistente : str ): \"\"\" Devuelve el rol del asistente que se pasa por par\u00e1metro Args: asistente: Correo del asistente Returns: (str):rol del asistente en cadena \"\"\" return self . asistentes [ asistente ][ 'rol' ]","title":"get_rol_asistente()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_sitios_libres","text":"Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: Type Description int Cantidad de puestos libres Source code in modulos\\gestor_calendario.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def get_sitios_libres ( self ): \"\"\" Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: (int):Cantidad de puestos libres \"\"\" sitios_libres = 0 if self . asistentes != {}: for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'Optativo' en un evento. Significa que ya alguien pidi\u00f3 ceder el evento\" ) sitios_libres += 1 if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'No Participante' en un evento. Significa que ya alguien pidi\u00f3 obtener el evento que alguien cedi\u00f3\" ) sitios_libres -= 1 return sitios_libres","title":"get_sitios_libres()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_summary","text":"Obtiene nombre de evento o summary Returns: Type Description str Cadena con nombre del evento Source code in modulos\\gestor_calendario.py 111 112 113 114 115 116 117 118 def get_summary ( self ): \"\"\" Obtiene nombre de evento o summary Returns: (str):Cadena con nombre del evento \"\"\" return str ( self . Event . vobject_instance . vevent . summary . value )","title":"get_summary()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_uid","text":"Obtiene uid del evento Returns: Type Description str Uid del evento Source code in modulos\\gestor_calendario.py 120 121 122 123 124 125 126 127 def get_uid ( self ): \"\"\" Obtiene uid del evento Returns: (str):Uid del evento \"\"\" return str ( self . Event . vobject_instance . vevent . uid . value )","title":"get_uid()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.negar_cambio_asistentes","text":"Niega el cambio de una guardia, borrando al demandante del evento y poniendo al ofertante de REQ-PARTICIPANT Parameters: Name Type Description Default ofertante str Correo del ofertante required demandante str Correo del demandante required Returns: Type Description bool True si realiza la negaci\u00f3n, False si no Source code in modulos\\gestor_calendario.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def negar_cambio_asistentes ( self , ofertante : str , demandante : str ): \"\"\" Niega el cambio de una guardia, borrando al demandante del evento y poniendo al ofertante de REQ-PARTICIPANT Args: ofertante: Correo del ofertante demandante: Correo del demandante Returns: (bool): True si realiza la negaci\u00f3n, False si no \"\"\" try : self . set_asistente ( ofertante , rol = 'REQ-PARTICIPANT' ) self . borrar_asistente ( demandante ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"negar_cambio_asistentes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.set_asistente","text":"Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Parameters: Name Type Description Default correo_asistente str Correo del asistente que estamos queriendo actualizar required rol str Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba '' tipo str Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. 'INDIVIDUAL' Returns: Type Description int 0 si es correcto, -1 si sucede una Excepci\u00f3n Source code in modulos\\gestor_calendario.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def set_asistente ( self , correo_asistente : str , rol : str = \"\" , tipo : str = 'INDIVIDUAL' ): \"\"\" Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Args: correo_asistente: Correo del asistente que estamos queriendo actualizar rol: Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba tipo: Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. Returns: (int): 0 si es correcto, -1 si sucede una Excepci\u00f3n \"\"\" try : asistente = self . asistentes [ correo_asistente ] except KeyError as k : self . asistentes [ correo_asistente ] = {} except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 finally : if rol != \"\" : self . asistentes [ correo_asistente ][ 'rol' ] = rol self . asistentes [ correo_asistente ][ 'tipo' ] = tipo if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == correo_asistente : self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'ROLE' : [ asistente [ 'rol' ]]}) self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'CUTYPE' : [ asistente [ 'tipo' ]]}) existente = True if not existente : try : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 else : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) return 0","title":"set_asistente()"},{"location":"gestor_calendario/#modulos.gestor_calendario.start","text":"M\u00e9todo de m\u00f3dulo para cargar el cliente caldav en una variable de m\u00e9todo Parameters: Name Type Description Default url_servicio str url donde se encuentra el servidor caldav required usuario str usuario para acceder al servicio caldav None contrasena str contrase\u00f1a del servicio None Source code in modulos\\gestor_calendario.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def start ( url_servicio : str , usuario : str = None , contrasena : str = None ): \"\"\" M\u00e9todo de m\u00f3dulo para cargar el cliente caldav en una variable de m\u00e9todo Args: url_servicio: url donde se encuentra el servidor caldav usuario: usuario para acceder al servicio caldav contrasena: contrase\u00f1a del servicio \"\"\" global cliente try : cliente = caldav . DAVClient ( url = url_servicio , username = usuario , password = contrasena ) logging . getLogger ( __name__ ) . debug ( \"Iniciado url_servicio CALDAV\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e ))","title":"start()"},{"location":"servicio_rest/","text":"M\u00f3dulo para agregar manejo del servicio REST para obtener datos del servicio Guardianes Contiene las variables de m\u00f3dulo: url_inserta : Contiene la URL para insertar la ID de telegram utilizando la ID de usuario en la BBDD del servicio REST url_getID : Contiene la URL para obtener la ID del doctor en la BBDD del servicio REST a partir del email url_getnombre : Contiene la URL para obtener el nombre y apellido del doctor a partir de la ID del doctor en la BBDD del servicio REST url_getIDrestporIDtel : Contiene la URL para obtener la ID del doctor en la BBDD del servicio REST a partir de la ID de usuario de Telegram url_getroles : Contiene la URL para obtener los roles de un doctor a partir del correo del doctor url_getIDtelporIDrest : Contiene la URL para obtener la ID de usuario de Telegram del doctor a partir de la ID en la BBDD del servicio REST usuario : Usuario para el servicio REST password : Password para el servicio REST Estas variables son con acceso de lectura desde cualquier funci\u00f3n del m\u00f3dulo. Para poder escribir en ellas, es necesario declararla como global dentro de la funci\u00f3n GetAdmins () Obtiene una lista de administradores en la BBDD del servicio REST Returns: Type Description list [ str ] Lista con los correos de los administradores, o lista vac\u00eda si no los encuentra. Source code in modulos\\servicio_rest.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def GetAdmins () -> list [ str ]: \"\"\" Obtiene una lista de administradores en la BBDD del servicio REST Returns: Lista con los correos de los administradores, o lista vac\u00eda si no los encuentra. \"\"\" respuesta = None admines = [] try : #Obtenemos la respuesta de solicitar los roles respuesta = requests . get ( url_getroles , auth = HTTPBasicAuth ( usuario , password ), params = { 'rol' : \"Administrador\" } ) if respuesta . status_code == 200 : admines = respuesta . text . strip ( '][' ) . split ( ', ' ) return admines except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Error obteniendo roles del doctor \" + str ( e )) raise Exception except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return admines GetEmailPorID ( id ) Obtiene el correo de un usuario a partir de su ID del servicio REST Parameters: Name Type Description Default id str | int ID del servicio REST del usuario required Returns: Type Description str | None Correo del usuario o None en caso contrario Source code in modulos\\servicio_rest.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def GetEmailPorID ( id : str | int ) -> str | None : \"\"\" Obtiene el correo de un usuario a partir de su ID del servicio REST Args: id: ID del servicio REST del usuario Returns: Correo del usuario o None en caso contrario \"\"\" respuesta = None email = None try : respuesta = requests . get ( url_getnombre + '/' + str ( id ), auth = HTTPBasicAuth ( usuario , password ) ) respuestajson = respuesta . json () logging . getLogger ( __name__ ) . debug ( \"Respuesta de NombrePorID: \" + str ( respuestajson )) email = str ( respuestajson . get ( 'email' )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception return email GetIDPorEmail ( email ) Obteiene la ID del usuario en el servicio REST a partir de su correo electr\u00f3nico Parameters: Name Type Description Default email str Correo electr\u00f3nico del usuario required Returns: Type Description str Devuelve la cadena Email not found si no encuentra el correo, o la ID en el servicio REST si lo encontr\u00f3 Source code in modulos\\servicio_rest.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def GetIDPorEmail ( email : str ) -> str : \"\"\" Obteiene la ID del usuario en el servicio REST a partir de su correo electr\u00f3nico Args: email: Correo electr\u00f3nico del usuario Returns: Devuelve la cadena `Email not found` si no encuentra el correo, o la ID en el servicio REST si lo encontr\u00f3 \"\"\" try : respuesta = requests . get ( url_getID , auth = HTTPBasicAuth ( usuario , password ), params = { 'email' : email }) logging . getLogger ( __name__ ) . debug ( respuesta . text ) idrest = str ( respuesta . text ) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idrest if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" GetNombrePorID ( id ) Obtiene el nombre y apellido de un usuario en el servicio REST a partir de su ID Parameters: Name Type Description Default id str | int ID del usuario en el servicio REST required Returns: Type Description str El nombre y apellido en caso de encontrar al doctor o el mensaje \"Email not found\" Source code in modulos\\servicio_rest.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def GetNombrePorID ( id : str | int ) -> str : \"\"\" Obtiene el nombre y apellido de un usuario en el servicio REST a partir de su ID Args: id: ID del usuario en el servicio REST Returns: El nombre y apellido en caso de encontrar al doctor o el mensaje \"Email not found\" \"\"\" respuesta = None nombre = None try : respuesta = requests . get ( url_getnombre + '/' + str ( id ), auth = HTTPBasicAuth ( usuario , password ) ) respuestajson = respuesta . json () logging . getLogger ( __name__ ) . debug ( \"Respuesta de NombrePorID: \" + str ( respuestajson )) nombre = str ( respuestajson . get ( 'firstName' )) + \" \" + str ( respuestajson . get ( 'lastNames' )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Error obteniendo nombre del doctor \" + str ( e )) raise Exception if respuesta . status_code == 200 : return nombre if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" GetRolesPorEmail ( mail ) Obtiene los roles de un usuario Parameters: Name Type Description Default mail str Correo del usuario required Returns: Type Description list [ str ] Lista de roles que tenga el usuario, o lista vac\u00eda si no los encuentra. Source code in modulos\\servicio_rest.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def GetRolesPorEmail ( mail : str ) -> list [ str ]: \"\"\" Obtiene los roles de un usuario Args: mail: Correo del usuario Returns: Lista de roles que tenga el usuario, o lista vac\u00eda si no los encuentra. \"\"\" respuesta = None roles = [] try : respuesta = requests . get ( url_getroles + '/' + str ( mail ), auth = HTTPBasicAuth ( usuario , password ) ) if respuesta . status_code == 200 : if \"Nombre rol=Doctor\" in respuesta . text : roles . append ( \"Doctor\" ) if \"Nombre rol=Administrador\" in respuesta . text : roles . append ( \"Administrador\" ) if \"Nombre rol=Administrativo\" in respuesta . text : roles . append ( \"Administrativo\" ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de GetRolesPorEmail: \" + str ( roles )) if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Error obteniendo roles del doctor \" + str ( e )) raise Exception except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return roles GetidRESTPorIDTel ( id ) Obtiene la ID del servicio REST de un usuario a partir de su ID en Telegram Parameters: Name Type Description Default id str | int ID de Telegram del usuario required Returns: Type Description str Obtiene la ID del usuario en el servicio REST o el mensaje \"Email not found\" Source code in modulos\\servicio_rest.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def GetidRESTPorIDTel ( id : str | int ) -> str : \"\"\" Obtiene la ID del servicio REST de un usuario a partir de su ID en Telegram Args: id: ID de Telegram del usuario Returns: Obtiene la ID del usuario en el servicio REST o el mensaje \"Email not found\" \"\"\" respuesta = None nombre = None try : respuesta = requests . get ( url_getIDrestporIDtel , auth = HTTPBasicAuth ( usuario , password ), params = { 'idTel' : str ( id )} ) idRest = str ( respuesta . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de idRESTPorIDTel: \" + str ( respuesta . text )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idRest if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" GetidTelPoridREST ( id ) Obtiene la ID de telegram de un usuario a partir de su ID del servicio REST Parameters: Name Type Description Default id str | int ID de servicio REST de un usuario required Returns: Type Description str La ID de Telegram de un usuario, o \"Email not found\" en caso de no existir. Source code in modulos\\servicio_rest.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def GetidTelPoridREST ( id : str | int ) -> str : \"\"\" Obtiene la ID de telegram de un usuario a partir de su ID del servicio REST Args: id: ID de servicio REST de un usuario Returns: La ID de Telegram de un usuario, o \"Email not found\" en caso de no existir. \"\"\" respuesta = None nombre = None idTel = '0' try : respuesta = requests . get ( url_getIDtelporIDrest , auth = HTTPBasicAuth ( usuario , password ), params = { 'id' : str ( id )} ) idTel = str ( respuesta . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de idRESTPorIDTel: \" + str ( respuesta . text )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idTel if \"Could not find the doctor\" in respuesta . text : return \"Email not found\" InsertaTelegramID ( idusuario , chatid ) Inserta la ID de telegram del usuario, utilizando la ID REST del mismo Parameters: Name Type Description Default idusuario str | int ID del usuario en el servicio REST required chatid str | int ID del usuario en Telegram required Returns: Type Description str | None Devuelve el mensaje de ID de Telegram actualizado si se completa, o None si hay un fallo. Source code in modulos\\servicio_rest.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def InsertaTelegramID ( idusuario : str | int , chatid : str | int ) -> str | None : \"\"\" Inserta la ID de telegram del usuario, utilizando la ID REST del mismo Args: idusuario: ID del usuario en el servicio REST chatid: ID del usuario en Telegram Returns: Devuelve el mensaje de ID de Telegram actualizado si se completa, o None si hay un fallo. \"\"\" respuesta = None try : respuesta = requests . put ( url_inserta + '/' + idusuario , auth = HTTPBasicAuth ( usuario , password ), headers = { 'Content-Type' : 'text/plain' }, data = str ( chatid )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return respuesta . text SetEvento ( evento_data ) Funci\u00f3n para enviar el evento final a la API REST para que modifique el calendario de asignaciones Parameters: Name Type Description Default evento_data str Cadena con los datos del evento en formato ical required Returns: Type Description (bool) : Verdadero si lo hizo bien, falso si no Source code in modulos\\servicio_rest.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def SetEvento ( evento_data : str ): \"\"\" Funci\u00f3n para enviar el evento final a la API REST para que modifique el calendario de asignaciones Args: evento_data: Cadena con los datos del evento en formato ical Returns: (bool) : Verdadero si lo hizo bien, falso si no \"\"\" respuesta = None try : # Obtenemos la respuesta de solicitar los roles respuesta = requests . post ( url_eventos , auth = HTTPBasicAuth ( usuario , password ), headers = { 'Content-Type' : 'text/plain' }, data = str ( evento_data ) ) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return respuesta . text start ( user , contrasena , inserta_id_tel_por_id_rest , get_id_por_email , get_nombre_por_id_rest , get_id_rest_por_id_tel , get_rol_por_email , get_id_tel_por_id_rest , put_evento ) Funci\u00f3n para inicializar el m\u00f3dulo. Rellena las urls de acceso a la API REST y las credenciales. Parameters: Name Type Description Default user str Usuario para acceder a la API REST required contrasena str Password para acceder a la API REST required inserta_id_tel_por_id_rest str URL para insertar la ID de telegram en la BBDD required get_id_por_email str URL para obtener la ID del servicio REST a partir del email required get_nombre_por_id_rest str URL para obtener el nombre del doctor a partir de la ID del servicio REST required get_id_rest_por_id_tel str URL para obtener la ID del servicio REST a partir de la ID de Telegram required get_rol_por_email str URL para obtener los roles de un doctor a partir de su email required get_id_tel_por_id_rest str URL para obtener la ID de Telegram a partir de la ID del servicio REST required put_evento str URL para enviar el evento a la API REST. required Source code in modulos\\servicio_rest.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def start ( user : str , contrasena : str , inserta_id_tel_por_id_rest : str , get_id_por_email : str , get_nombre_por_id_rest : str , get_id_rest_por_id_tel : str , get_rol_por_email : str , get_id_tel_por_id_rest : str , put_evento : str ) -> None : \"\"\" Funci\u00f3n para inicializar el m\u00f3dulo. Rellena las urls de acceso a la API REST y las credenciales. Args: user: Usuario para acceder a la API REST contrasena: Password para acceder a la API REST inserta_id_tel_por_id_rest: URL para insertar la ID de telegram en la BBDD get_id_por_email: URL para obtener la ID del servicio REST a partir del email get_nombre_por_id_rest: URL para obtener el nombre del doctor a partir de la ID del servicio REST get_id_rest_por_id_tel: URL para obtener la ID del servicio REST a partir de la ID de Telegram get_rol_por_email: URL para obtener los roles de un doctor a partir de su email get_id_tel_por_id_rest: URL para obtener la ID de Telegram a partir de la ID del servicio REST put_evento: URL para enviar el evento a la API REST. \"\"\" global url_inserta , url_getID , usuario , password , url_getnombre , url_getIDrestporIDtel , url_getroles , url_getIDtelporIDrest , url_eventos url_inserta = inserta_id_tel_por_id_rest url_getID = get_id_por_email url_getnombre = get_nombre_por_id_rest url_getIDrestporIDtel = get_id_rest_por_id_tel url_getroles = get_rol_por_email url_getIDtelporIDrest = get_id_tel_por_id_rest url_eventos = put_evento usuario = user password = contrasena logging . getLogger ( __name__ ) . debug ( \"Inicializado el objeto REST con valores: \" + \" URL_INSERTA: \" + url_inserta + \" URL_OBTENER: \" + url_getID + \" URL_GET_NOMBRE \" + url_getnombre + \" URL_GET_ID\" + url_getIDrestporIDtel + \" USUARIO: \" + usuario + \" PASSWORD: \" + password )","title":"servicio_rest"},{"location":"servicio_rest/#modulos.servicio_rest.GetAdmins","text":"Obtiene una lista de administradores en la BBDD del servicio REST Returns: Type Description list [ str ] Lista con los correos de los administradores, o lista vac\u00eda si no los encuentra. Source code in modulos\\servicio_rest.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def GetAdmins () -> list [ str ]: \"\"\" Obtiene una lista de administradores en la BBDD del servicio REST Returns: Lista con los correos de los administradores, o lista vac\u00eda si no los encuentra. \"\"\" respuesta = None admines = [] try : #Obtenemos la respuesta de solicitar los roles respuesta = requests . get ( url_getroles , auth = HTTPBasicAuth ( usuario , password ), params = { 'rol' : \"Administrador\" } ) if respuesta . status_code == 200 : admines = respuesta . text . strip ( '][' ) . split ( ', ' ) return admines except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Error obteniendo roles del doctor \" + str ( e )) raise Exception except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return admines","title":"GetAdmins()"},{"location":"servicio_rest/#modulos.servicio_rest.GetEmailPorID","text":"Obtiene el correo de un usuario a partir de su ID del servicio REST Parameters: Name Type Description Default id str | int ID del servicio REST del usuario required Returns: Type Description str | None Correo del usuario o None en caso contrario Source code in modulos\\servicio_rest.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def GetEmailPorID ( id : str | int ) -> str | None : \"\"\" Obtiene el correo de un usuario a partir de su ID del servicio REST Args: id: ID del servicio REST del usuario Returns: Correo del usuario o None en caso contrario \"\"\" respuesta = None email = None try : respuesta = requests . get ( url_getnombre + '/' + str ( id ), auth = HTTPBasicAuth ( usuario , password ) ) respuestajson = respuesta . json () logging . getLogger ( __name__ ) . debug ( \"Respuesta de NombrePorID: \" + str ( respuestajson )) email = str ( respuestajson . get ( 'email' )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception return email","title":"GetEmailPorID()"},{"location":"servicio_rest/#modulos.servicio_rest.GetIDPorEmail","text":"Obteiene la ID del usuario en el servicio REST a partir de su correo electr\u00f3nico Parameters: Name Type Description Default email str Correo electr\u00f3nico del usuario required Returns: Type Description str Devuelve la cadena Email not found si no encuentra el correo, o la ID en el servicio REST si lo encontr\u00f3 Source code in modulos\\servicio_rest.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def GetIDPorEmail ( email : str ) -> str : \"\"\" Obteiene la ID del usuario en el servicio REST a partir de su correo electr\u00f3nico Args: email: Correo electr\u00f3nico del usuario Returns: Devuelve la cadena `Email not found` si no encuentra el correo, o la ID en el servicio REST si lo encontr\u00f3 \"\"\" try : respuesta = requests . get ( url_getID , auth = HTTPBasicAuth ( usuario , password ), params = { 'email' : email }) logging . getLogger ( __name__ ) . debug ( respuesta . text ) idrest = str ( respuesta . text ) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idrest if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\"","title":"GetIDPorEmail()"},{"location":"servicio_rest/#modulos.servicio_rest.GetNombrePorID","text":"Obtiene el nombre y apellido de un usuario en el servicio REST a partir de su ID Parameters: Name Type Description Default id str | int ID del usuario en el servicio REST required Returns: Type Description str El nombre y apellido en caso de encontrar al doctor o el mensaje \"Email not found\" Source code in modulos\\servicio_rest.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def GetNombrePorID ( id : str | int ) -> str : \"\"\" Obtiene el nombre y apellido de un usuario en el servicio REST a partir de su ID Args: id: ID del usuario en el servicio REST Returns: El nombre y apellido en caso de encontrar al doctor o el mensaje \"Email not found\" \"\"\" respuesta = None nombre = None try : respuesta = requests . get ( url_getnombre + '/' + str ( id ), auth = HTTPBasicAuth ( usuario , password ) ) respuestajson = respuesta . json () logging . getLogger ( __name__ ) . debug ( \"Respuesta de NombrePorID: \" + str ( respuestajson )) nombre = str ( respuestajson . get ( 'firstName' )) + \" \" + str ( respuestajson . get ( 'lastNames' )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Error obteniendo nombre del doctor \" + str ( e )) raise Exception if respuesta . status_code == 200 : return nombre if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\"","title":"GetNombrePorID()"},{"location":"servicio_rest/#modulos.servicio_rest.GetRolesPorEmail","text":"Obtiene los roles de un usuario Parameters: Name Type Description Default mail str Correo del usuario required Returns: Type Description list [ str ] Lista de roles que tenga el usuario, o lista vac\u00eda si no los encuentra. Source code in modulos\\servicio_rest.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def GetRolesPorEmail ( mail : str ) -> list [ str ]: \"\"\" Obtiene los roles de un usuario Args: mail: Correo del usuario Returns: Lista de roles que tenga el usuario, o lista vac\u00eda si no los encuentra. \"\"\" respuesta = None roles = [] try : respuesta = requests . get ( url_getroles + '/' + str ( mail ), auth = HTTPBasicAuth ( usuario , password ) ) if respuesta . status_code == 200 : if \"Nombre rol=Doctor\" in respuesta . text : roles . append ( \"Doctor\" ) if \"Nombre rol=Administrador\" in respuesta . text : roles . append ( \"Administrador\" ) if \"Nombre rol=Administrativo\" in respuesta . text : roles . append ( \"Administrativo\" ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de GetRolesPorEmail: \" + str ( roles )) if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Error obteniendo roles del doctor \" + str ( e )) raise Exception except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return roles","title":"GetRolesPorEmail()"},{"location":"servicio_rest/#modulos.servicio_rest.GetidRESTPorIDTel","text":"Obtiene la ID del servicio REST de un usuario a partir de su ID en Telegram Parameters: Name Type Description Default id str | int ID de Telegram del usuario required Returns: Type Description str Obtiene la ID del usuario en el servicio REST o el mensaje \"Email not found\" Source code in modulos\\servicio_rest.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def GetidRESTPorIDTel ( id : str | int ) -> str : \"\"\" Obtiene la ID del servicio REST de un usuario a partir de su ID en Telegram Args: id: ID de Telegram del usuario Returns: Obtiene la ID del usuario en el servicio REST o el mensaje \"Email not found\" \"\"\" respuesta = None nombre = None try : respuesta = requests . get ( url_getIDrestporIDtel , auth = HTTPBasicAuth ( usuario , password ), params = { 'idTel' : str ( id )} ) idRest = str ( respuesta . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de idRESTPorIDTel: \" + str ( respuesta . text )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idRest if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\"","title":"GetidRESTPorIDTel()"},{"location":"servicio_rest/#modulos.servicio_rest.GetidTelPoridREST","text":"Obtiene la ID de telegram de un usuario a partir de su ID del servicio REST Parameters: Name Type Description Default id str | int ID de servicio REST de un usuario required Returns: Type Description str La ID de Telegram de un usuario, o \"Email not found\" en caso de no existir. Source code in modulos\\servicio_rest.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def GetidTelPoridREST ( id : str | int ) -> str : \"\"\" Obtiene la ID de telegram de un usuario a partir de su ID del servicio REST Args: id: ID de servicio REST de un usuario Returns: La ID de Telegram de un usuario, o \"Email not found\" en caso de no existir. \"\"\" respuesta = None nombre = None idTel = '0' try : respuesta = requests . get ( url_getIDtelporIDrest , auth = HTTPBasicAuth ( usuario , password ), params = { 'id' : str ( id )} ) idTel = str ( respuesta . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de idRESTPorIDTel: \" + str ( respuesta . text )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idTel if \"Could not find the doctor\" in respuesta . text : return \"Email not found\"","title":"GetidTelPoridREST()"},{"location":"servicio_rest/#modulos.servicio_rest.InsertaTelegramID","text":"Inserta la ID de telegram del usuario, utilizando la ID REST del mismo Parameters: Name Type Description Default idusuario str | int ID del usuario en el servicio REST required chatid str | int ID del usuario en Telegram required Returns: Type Description str | None Devuelve el mensaje de ID de Telegram actualizado si se completa, o None si hay un fallo. Source code in modulos\\servicio_rest.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def InsertaTelegramID ( idusuario : str | int , chatid : str | int ) -> str | None : \"\"\" Inserta la ID de telegram del usuario, utilizando la ID REST del mismo Args: idusuario: ID del usuario en el servicio REST chatid: ID del usuario en Telegram Returns: Devuelve el mensaje de ID de Telegram actualizado si se completa, o None si hay un fallo. \"\"\" respuesta = None try : respuesta = requests . put ( url_inserta + '/' + idusuario , auth = HTTPBasicAuth ( usuario , password ), headers = { 'Content-Type' : 'text/plain' }, data = str ( chatid )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return respuesta . text","title":"InsertaTelegramID()"},{"location":"servicio_rest/#modulos.servicio_rest.SetEvento","text":"Funci\u00f3n para enviar el evento final a la API REST para que modifique el calendario de asignaciones Parameters: Name Type Description Default evento_data str Cadena con los datos del evento en formato ical required Returns: Type Description (bool) : Verdadero si lo hizo bien, falso si no Source code in modulos\\servicio_rest.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def SetEvento ( evento_data : str ): \"\"\" Funci\u00f3n para enviar el evento final a la API REST para que modifique el calendario de asignaciones Args: evento_data: Cadena con los datos del evento en formato ical Returns: (bool) : Verdadero si lo hizo bien, falso si no \"\"\" respuesta = None try : # Obtenemos la respuesta de solicitar los roles respuesta = requests . post ( url_eventos , auth = HTTPBasicAuth ( usuario , password ), headers = { 'Content-Type' : 'text/plain' }, data = str ( evento_data ) ) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . info ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return respuesta . text","title":"SetEvento()"},{"location":"servicio_rest/#modulos.servicio_rest.start","text":"Funci\u00f3n para inicializar el m\u00f3dulo. Rellena las urls de acceso a la API REST y las credenciales. Parameters: Name Type Description Default user str Usuario para acceder a la API REST required contrasena str Password para acceder a la API REST required inserta_id_tel_por_id_rest str URL para insertar la ID de telegram en la BBDD required get_id_por_email str URL para obtener la ID del servicio REST a partir del email required get_nombre_por_id_rest str URL para obtener el nombre del doctor a partir de la ID del servicio REST required get_id_rest_por_id_tel str URL para obtener la ID del servicio REST a partir de la ID de Telegram required get_rol_por_email str URL para obtener los roles de un doctor a partir de su email required get_id_tel_por_id_rest str URL para obtener la ID de Telegram a partir de la ID del servicio REST required put_evento str URL para enviar el evento a la API REST. required Source code in modulos\\servicio_rest.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def start ( user : str , contrasena : str , inserta_id_tel_por_id_rest : str , get_id_por_email : str , get_nombre_por_id_rest : str , get_id_rest_por_id_tel : str , get_rol_por_email : str , get_id_tel_por_id_rest : str , put_evento : str ) -> None : \"\"\" Funci\u00f3n para inicializar el m\u00f3dulo. Rellena las urls de acceso a la API REST y las credenciales. Args: user: Usuario para acceder a la API REST contrasena: Password para acceder a la API REST inserta_id_tel_por_id_rest: URL para insertar la ID de telegram en la BBDD get_id_por_email: URL para obtener la ID del servicio REST a partir del email get_nombre_por_id_rest: URL para obtener el nombre del doctor a partir de la ID del servicio REST get_id_rest_por_id_tel: URL para obtener la ID del servicio REST a partir de la ID de Telegram get_rol_por_email: URL para obtener los roles de un doctor a partir de su email get_id_tel_por_id_rest: URL para obtener la ID de Telegram a partir de la ID del servicio REST put_evento: URL para enviar el evento a la API REST. \"\"\" global url_inserta , url_getID , usuario , password , url_getnombre , url_getIDrestporIDtel , url_getroles , url_getIDtelporIDrest , url_eventos url_inserta = inserta_id_tel_por_id_rest url_getID = get_id_por_email url_getnombre = get_nombre_por_id_rest url_getIDrestporIDtel = get_id_rest_por_id_tel url_getroles = get_rol_por_email url_getIDtelporIDrest = get_id_tel_por_id_rest url_eventos = put_evento usuario = user password = contrasena logging . getLogger ( __name__ ) . debug ( \"Inicializado el objeto REST con valores: \" + \" URL_INSERTA: \" + url_inserta + \" URL_OBTENER: \" + url_getID + \" URL_GET_NOMBRE \" + url_getnombre + \" URL_GET_ID\" + url_getIDrestporIDtel + \" USUARIO: \" + usuario + \" PASSWORD: \" + password )","title":"start()"},{"location":"telegram_tools/","text":"M\u00f3dulo para agregar manejo del servicio de Telegram y aportar funcionalidad para el servicio de Guardianes Contiene las variables de m\u00f3dulo: bot : Contiene un objeto tipo telegram.Bot tokenbot : Contiene una cadena con el token del bot de Telegram cal_principal : Contiene un objeto gestor_calendario.Calendario que define el calendario principal del servicio cal_propuestas : Contiene un objeto gestor_calendario.Calendario que define el calendario de propuestas del servicio canalid : Contiene una cadena con la id del canal de avisos de guardias del servicio canalid_admin : Contiene una cadena con la id del canal de avisos para administradores Estas variables son con acceso de lectura desde cualquier funci\u00f3n del m\u00f3dulo. Para poder escribir en ellas, es necesario declararla como global dentro de la funci\u00f3n autenticar ( func ) M\u00e9todo para autenticar usuario al usar las funciones. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def autenticar ( func ): \"\"\" M\u00e9todo para autenticar usuario al usar las funciones. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func (function): Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = args [ 0 ] . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): func ( * args , ** kwargs ) elif \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper autenticar_admin ( func ) M\u00e9todo para autenticar usuario al usar las funciones del bot. Verifica si es un administrador. Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def autenticar_admin ( func ): \"\"\" M\u00e9todo para autenticar usuario al usar las funciones del bot. Verifica si es un administrador. Se utiliza como un decorador Args: func (function): Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = args [ 0 ] . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : func ( * args , ** kwargs ) else : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No tiene el rol adecuado para esta funci\u00f3n.\" \"Verifique sus permisos con el administrador del sistema\" ) if \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper autenticar_retorno ( func ) M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def autenticar_retorno ( func ): \"\"\" M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func (function): Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = str ( args [ 0 ] . callback_query . from_user . id ) id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): func ( * args , ** kwargs ) elif \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper autenticar_retorno_admin ( func ) M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def autenticar_retorno_admin ( func ): \"\"\" M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func (function): Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = str ( args [ 0 ] . callback_query . from_user . id ) id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : func ( * args , ** kwargs ) else : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No tiene el rol adecuado para esta funci\u00f3n.\" \"Verifique sus permisos con el administrador del sistema\" ) if \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper borrar_mensaje ( id_chat , id_mensaje ) Funci\u00f3n para borrar un mensaje cuando se ha cursado la petici\u00f3n de tomar un evento Parameters: Name Type Description Default id_chat str | int Id del chat de donde se hace la acci\u00f3n de tomar evento required id_mensaje str | int ID del mensaje a borrar required Returns: Type Description bool Verdadero si pudo completarlo, falso si no Source code in modulos\\telegram_tools.py 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 def borrar_mensaje ( id_chat : str | int , id_mensaje : str | int ) -> bool : \"\"\" Funci\u00f3n para borrar un mensaje cuando se ha cursado la petici\u00f3n de tomar un evento Args: id_chat: Id del chat de donde se hace la acci\u00f3n de tomar evento id_mensaje: ID del mensaje a borrar Returns: Verdadero si pudo completarlo, falso si no \"\"\" terminado : bool = False try : terminado = bot . deleteMessage ( chat_id = id_chat , message_id = id_mensaje ) return terminado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return terminado botones ( update , context ) Funci\u00f3n para mostrar los botones en el chat que ejecutar\u00e1n las funciones para el usuario Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 @autenticar def botones ( update : telegram . Update , context : telegram . ext . CallbackContext ): \"\"\" Funci\u00f3n para mostrar los botones en el chat que ejecutar\u00e1n las funciones para el usuario Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" id_user = update . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : kb = [ [ telegram . KeyboardButton ( 'Actividades propias' ) ], [ telegram . KeyboardButton ( 'Actividades pendientes de ser aprobadas o denegadas' ), ], ] else : kb = [ [ telegram . KeyboardButton ( 'Actividades propias' ) ], [ telegram . KeyboardButton ( 'Actividades pendientes de ser aprobadas o denegadas' ) ] ] kb_markup = telegram . ReplyKeyboardMarkup ( kb , resize_keyboard = True ) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Seleccione una opcion\" , reply_markup = kb_markup ) cancelar_propuesta_evento ( uid , attendee ) Funci\u00f3n para que un usuario pueda cancelar su oferta o su demanda Parameters: Name Type Description Default uid str | int Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a cancelar su propuesta required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 def cancelar_propuesta_evento ( uid : str | int , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda cancelar su oferta o su demanda Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a cancelar su propuesta Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento_cancelado = cal_propuestas . cancelar_evento ( correo_usuario = attendee , uid_evento = uid ) if isinstance ( evento_cancelado , gestor_calendario . Evento ): return evento_cancelado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None ceder_evento ( uid , attendee ) Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a ceder su puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 def ceder_evento ( uid : str , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a ceder su puesto en una guardia Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_principal . get_evento ( uid ) evento_cedido = cal_propuestas . ofertar_evento ( correo_usuario = attendee , evento = evento , uid_evento = uid ) if isinstance ( evento_cedido , gestor_calendario . Evento ): return evento_cedido except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None editar_datos_evento ( evento , id_chat , id_mensaje , accion = 'nada' ) Funci\u00f3n para editar un mensaje de Telegram con los datos de un evento. Utilizada para actualizar los mensajes en el canal de publicaci\u00f3n de guardias Parameters: Name Type Description Default evento gestor_calendario . Evento Evento que se va a actualizar required id_chat str Identificador del chat donde se edita el mensaje required id_mensaje str Identificador del mensaje que se va a editar required accion str Acci\u00f3n que se incluye en el bot\u00f3n que est\u00e1 debajo de la publicaci\u00f3n del mensaje, que luego interacciona con los retornos 'nada' Source code in modulos\\telegram_tools.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def editar_datos_evento ( evento : gestor_calendario . Evento , id_chat : str , id_mensaje : str , accion : str = \"nada\" ): \"\"\" Funci\u00f3n para editar un mensaje de Telegram con los datos de un evento. Utilizada para actualizar los mensajes en el canal de publicaci\u00f3n de guardias Args: evento: Evento que se va a actualizar id_chat: Identificador del chat donde se edita el mensaje id_mensaje: Identificador del mensaje que se va a editar accion: Acci\u00f3n que se incluye en el bot\u00f3n que est\u00e1 debajo de la publicaci\u00f3n del mensaje, que luego interacciona con los retornos \"\"\" reply_markup = [] mensaje = None if accion == \"cancelar_cesion\" : texto = \"Cancelar propuesta de cambio\" if accion == \"tomar\" : texto = \"Pedir esta actividad cedida\" if accion == \"ceder\" : texto = \"Ofrecer esta actividad\" if accion == \"aprobar_denegar\" : texto = \"Aprobar este cambio de actividad\" if accion == \"permutar\" : texto = \"Pedir esta actividad para intercambio\" if accion == \"rechazar\" : texto = \"Rechazar intercambio\" if accion == \"escoger\" : texto = \"Escoger esta actividad para intercambio\" boton_callback = [[ telegram . InlineKeyboardButton ( text = \" {} \" . format ( texto ), callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()) ) ]] cadena = \"<b> {} </b> \\n Fecha: {} \\n Sitios libres: {} \" . format ( evento . get_summary (), evento . get_fecha_str (), evento . get_sitios_libres ()) if accion != \"nada\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . editMessageText ( chat_id = id_chat , message_id = id_mensaje , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) guardias_aprobar_denegar ( update , context ) Funci\u00f3n para obtener las guardias que est\u00e1n pendientes de aprobar o denegar y dar la posibilidad de aceptar o denegar el cambio Se imprimir\u00e1n las guardias y se colocar\u00e1n botones para aprobar o denegar el cambio, bajo el mensaje con los datos del evento. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 @autenticar_admin def guardias_aprobar_denegar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias que est\u00e1n pendientes de aprobar o denegar y dar la posibilidad de aceptar o denegar el cambio Se imprimir\u00e1n las guardias y se colocar\u00e1n botones para aprobar o denegar el cambio, bajo el mensaje con los datos del evento. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas # reply_markup=telegram.InlineKeyboardMarkup([]) cadena = \"\" lista_eventos = [] try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos = cal_propuestas . get_eventos ( completos = True ) # Aqui pediriamos el nombre del usuario a traves de REST, usando el id de Telegram como dato # hace falta una funci\u00f3n de obtener la ID por la ID de Telegram logging . getLogger ( __name__ ) . debug ( \"El usuario {} ha solicitado las actividades para aprobar o denegar. Fecha actual {} \" . format ( nombre_usuario , datetime . date . today ())) if lista_eventos == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay actividades pendientes de aceptar o denegar\" ) # key=lambda fecha: e.vobject_instance.vevent.dstart for e in lista_eventos : logging . getLogger ( __name__ ) . debug ( \"Evento para denegar o aprobar: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"aprobar_denegar_cesion\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error recogiendo las Actividades, por favor, p\u00f3ngase en contacto con el administrador\" ) guardias_disponibles ( update , context ) Funci\u00f3n para obtener las guardias en las que hay al menos un puesto con propuesta de cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 @autenticar def guardias_disponibles ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias en las que hay al menos un puesto con propuesta de cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas reply_markup = [] lista_botones = [] cadena = \"\" lista_eventos : list [ gestor_calendario . Evento ] = cal_propuestas . get_eventos () evento_ya_suscrito = 0 try : for e in lista_eventos : if e . get_comprobar_asistente ( servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ))) != True : if e . get_asistentes ( tipo = 'INDIVIDUAL' ): mostrar_datos_evento ( \"resumen\" , evento = e , id_chat = update . message . chat_id , accion = \"tomar\" ) if e . get_asistentes ( tipo = 'GROUP' ): mostrar_datos_evento ( \"resumen\" , evento = e , id_chat = update . message . chat_id , accion = \"intercambiar\" ) else : evento_ya_suscrito += 1 if lista_eventos == [] or evento_ya_suscrito == len ( lista_eventos ): context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay Actividades disponibles\" ) logging . getLogger ( __name__ ) . debug ( \"No hay Actividades disponibles\" ) logging . getLogger ( __name__ ) . debug ( cadena ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) guardias_pendientes ( update , context ) Funci\u00f3n para obtener las guardias en las que el usuario est\u00e1 demandando turno pero a\u00fan no se ha aprobado el cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 @autenticar def guardias_pendientes ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias en las que el usuario est\u00e1 demandando turno pero a\u00fan no se ha aprobado el cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas reply_markup = [] lista_botones = [] cadena = \"\" relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () actividad_encontrada = False try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos_ofertados = cal_propuestas . get_eventos ( attendee = email_usuario , rol = \"OPT-PARTICIPANT\" ) lista_eventos_demandados = cal_propuestas . get_eventos ( attendee = email_usuario , rol = \"NON-PARTICIPANT\" ) if lista_eventos_ofertados == [] and lista_eventos_demandados == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay Actividades pendientes de ser aprobadas o denegadas\" ) logging . getLogger ( __name__ ) . debug ( \"No hay Actividades pendientes de ser aprobadas o denegadas\" ) else : for e in lista_eventos_ofertados : cursor . execute ( f \"\"\"SELECT accion FROM oferta_demanda where uid_evento=\" { e . get_uid () } \";\"\"\" ) accion = cursor . fetchall ()[ 0 ][ 0 ] if accion == \"ceder\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_cesion\" ) actividad_encontrada = True elif accion == \"intercambiar\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_intercambio\" ) actividad_encontrada = True elif accion == \"enviado\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_intercambio\" ) actividad_encontrada = True for e in lista_eventos_demandados : cursor . execute ( f \"\"\"SELECT accion FROM oferta_demanda where uid_evento=\" { e . get_uid () } \";\"\"\" ) accion = cursor . fetchall ()[ 0 ][ 0 ] if accion == \"ceder\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_cesion\" ) actividad_encontrada = True elif accion == \"intercambiar\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_intercambio\" ) actividad_encontrada = True elif accion == \"enviado\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_intercambio\" ) actividad_encontrada = True if actividad_encontrada == False : context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay Actividades pendientes de ser aprobadas o denegadas\" ) logging . getLogger ( __name__ ) . debug ( \"No hay Actividades pendientes de ser aprobadas o denegadas\" ) logging . getLogger ( __name__ ) . debug ( cadena ) cursor . close () relacion . close () except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) cursor . close () relacion . close () guardias_propias ( update , context ) Funci\u00f3n para obtener las Actividades propias del usuario actualmente establecidas. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 @autenticar def guardias_propias ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las Actividades propias del usuario actualmente establecidas. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas # reply_markup=telegram.InlineKeyboardMarkup([]) cadena = \"\" lista_eventos : list [ gestor_calendario . Evento ] = [] evento_ya_ofrecido = 0 try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos = cal_principal . get_eventos ( email_usuario ) # Aqui pediriamos el nombre del usuario a traves de REST, usando el id de Telegram como dato #hace falta una funci\u00f3n de obtener la ID por la ID de Telegram logging . getLogger ( __name__ ) . debug ( \"El usuario {} ha solicitado sus propias actividades. Fecha actual {} \" . format ( nombre_usuario , datetime . date . today ())) if lista_eventos == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay actividades asignados a usted\" ) else : for e in lista_eventos : evento_aux = cal_propuestas . get_evento ( uid_evento = e . get_uid ()) if isinstance ( evento_aux , gestor_calendario . Evento ): if evento_aux . get_comprobar_asistente ( asistente = email_usuario , rol = \"OPT-PARTICIPANT\" ) == True : logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id ) else : logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"ceder_intercambiar\" ) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error recogiendo las Actividades propias, por favor, p\u00f3ngase en contacto con el administrador\" ) intercambiar_evento ( uid , attendee ) Funci\u00f3n para que un usuario pueda ofertar un intercambio de su participaci\u00f3n en una actividad y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a ceder su puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def intercambiar_evento ( uid : str , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda ofertar un intercambio de su participaci\u00f3n en una actividad y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a ceder su puesto en una guardia Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_principal . get_evento ( uid ) evento_intercambiado = cal_propuestas . ofertar_evento ( correo_usuario = attendee , evento = evento , tipo = 'GROUP' , uid_evento = uid ) if isinstance ( evento_intercambiado , gestor_calendario . Evento ): return evento_intercambiado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None lista_propuestas_seleccionadas ( demandante , eventos_ya_propuestos = [], ofertante = '' ) Funci\u00f3n para listar las propuestas que el demandante env\u00eda a un ofertante de un intercambio Parameters: Name Type Description Default demandante str Correo del demandante required eventos_ya_propuestos list [ str ] Lista de id de eventos ya agregados en la propuesta. Se utiliza para evitar que el demandante pueda incluir un evento varias veces [] ofertante str Correo del ofertante para que no se puedan proponer eventos que el ofertante ya est\u00e9 participando. '' Returns: Type Description (telegram.InlineKeyboardMarkup,str) : Devuelve el reply_markup y la cadena de texto del mensaje. Source code in modulos\\telegram_tools.py 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 def lista_propuestas_seleccionadas ( demandante : str , eventos_ya_propuestos : list [ str ] = [], ofertante : str = \"\" ): \"\"\" Funci\u00f3n para listar las propuestas que el demandante env\u00eda a un ofertante de un intercambio Args: demandante: Correo del demandante eventos_ya_propuestos: Lista de id de eventos ya agregados en la propuesta. Se utiliza para evitar que el demandante pueda incluir un evento varias veces ofertante: Correo del ofertante para que no se puedan proponer eventos que el ofertante ya est\u00e9 participando. Returns: (telegram.InlineKeyboardMarkup,str) : Devuelve el reply_markup y la cadena de texto del mensaje. \"\"\" global cal_principal reply_markup : telegram . InlineKeyboardMarkup = [] texto : str = \"\" try : if eventos_ya_propuestos != []: texto = \"Propuestas las actividades siguientes \\n \" for id in eventos_ya_propuestos : evento = cal_principal . get_evento ( uid_evento = id ) texto += \" \\n {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ()) else : texto = \"Escoja una o m\u00e1s actividades y pulse Enviar\" lista_eventos = cal_principal . get_eventos ( demandante ) fila_botones = [] columna_botones = [] for evento in lista_eventos : if evento . get_uid () not in eventos_ya_propuestos : boton = telegram . InlineKeyboardButton ( text = \" {} - {} \" . format ( evento . get_summary (), evento . get_fecha_str () ), callback_data = \" {} ; {} \" . format ( \"hacer_propuesta\" , evento . get_uid ()) ) columna_botones . append ( list ([ boton ])) columna_botones . append ([ telegram . InlineKeyboardButton ( text = \"Deshacer las selecciones\" , callback_data = \" {} \" . format ( \"deshacer_propuesta\" ) ), telegram . InlineKeyboardButton ( text = \"Enviar las propuestas\" , callback_data = \" {} \" . format ( \"enviar_propuesta\" ) ) ]) reply_markup = telegram . InlineKeyboardMarkup ( columna_botones ) return reply_markup , texto except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) marcar_cambio ( uid , demandante , ofertante ) Funci\u00f3n para marcar la cesi\u00f3n de ofertante a un demandante Parameters: Name Type Description Default uid str | int UID del evento a marcar required demandante str Correo del demandante required ofertante str Correo del ofertante required Returns: Type Description bool True si lo marc\u00f3 con \u00e9xito, False si no Source code in modulos\\telegram_tools.py 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 def marcar_cambio ( uid : str | int , demandante : str , ofertante : str ): \"\"\" Funci\u00f3n para marcar la cesi\u00f3n de ofertante a un demandante Args: uid: UID del evento a marcar demandante: Correo del demandante ofertante: Correo del ofertante Returns: (bool): True si lo marc\u00f3 con \u00e9xito, False si no \"\"\" evento = cal_propuestas . get_evento ( uid ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () if isinstance ( evento , gestor_calendario . Evento ): ofertantes = evento . get_asistentes ( rol = 'OPT-PARTICIPANT' ) lista = list ( ofertantes . keys ()) ofertante_marcado = random . choice ( lista ) cursor . execute ( f \"\"\"UPDATE oferta_demanda SET demandante=\" { demandante } \" WHERE ofertante=\" { ofertante_marcado } \" and uid_evento=\" { uid } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () mostrar_datos_evento ( modo , evento , id_chat , accion = 'nada' , demandante = '' , ofertante = '' ) Funci\u00f3n para presentar datos de un evento en un chat de telegram. Env\u00eda una mensaje al chat indicado por id_chat con los datos del evento y los botones contextuales si procede. Parameters: Name Type Description Default modo str Modo en el que se presenta el evento: \u00b7\u00b7\u00b7resumen: Solo muestra nombre, puestos libres y fecha del evento \u00b7\u00b7\u00b7completo: Muestra nombre, fecha e integrantes del evento required evento gestor_calendario . Evento Objeto gestor_calendario.Evento que contiene los datos del evento a representar. required id_chat str Identificador del chat donde se van a mostrar los datos del evento required accion str Accion que se pone en el mensaje de retorno cuando se pulsa un bot\u00f3n de un mensaje con un evento. Si la acci\u00f3n es nada, no se pone un bot\u00f3n 'nada' Returns: Type Description str Devuelve la id del mensaje enviado Source code in modulos\\telegram_tools.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def mostrar_datos_evento ( modo : str , evento : gestor_calendario . Evento , id_chat : str , accion : str = \"nada\" , demandante : str = \"\" , ofertante : str = \"\" ) -> str : \"\"\" Funci\u00f3n para presentar datos de un evento en un chat de telegram. Env\u00eda una mensaje al chat indicado por id_chat con los datos del evento y los botones contextuales si procede. Args: modo: Modo en el que se presenta el evento: \u00b7\u00b7\u00b7resumen: Solo muestra nombre, puestos libres y fecha del evento \u00b7\u00b7\u00b7completo: Muestra nombre, fecha e integrantes del evento evento: Objeto gestor_calendario.Evento que contiene los datos del evento a representar. id_chat: Identificador del chat donde se van a mostrar los datos del evento accion: Accion que se pone en el mensaje de retorno cuando se pulsa un bot\u00f3n de un mensaje con un evento. Si la acci\u00f3n es nada, no se pone un bot\u00f3n Returns: Devuelve la id del mensaje enviado \"\"\" reply_markup = [] mensaje : telegram . Message = None texto = \"\" if accion == \"cancelar_cesion\" : texto = \"Cancelar propuesta de cambio\" if accion == \"cancelar_intercambio\" : texto = \"Cancelar propuesta de intercambio\" if accion == \"tomar\" : texto = \"Demandar esta actividad cedida\" if accion == \"ceder\" : texto = \"Ofrecer esta actividad\" if accion == \"aprobar_denegar\" : texto = \"Aprobar este cambio de actividad\" if accion == \"permutar\" : texto = \"Demandar esta actividad para intercambio\" if accion == \"intercambiar\" : texto = \"Ofrecer esta actividad para intercambio\" if modo == \"resumen\" : boton_callback = [[ telegram . InlineKeyboardButton ( text = \" {} \" . format ( texto ), callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()) ) ]] cadena = \"<b> {} </b> \\n Fecha: {} \\n \" . format ( evento . get_summary (), evento . get_fecha_str ()) if accion != \"nada\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) else : cadena = \"Actividad en la que se ha inscrito a la espera de aprobaci\u00f3n \\n\\n \" + cadena mensaje = bot . send_message ( chat_id = id_chat , text = cadena , parse_mode = \"HTML\" ) if modo == \"completo\" : cadena = \"<b> {} </b> \\n \" . format ( evento . get_summary ()) if evento . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) if ofertante == \"\" : if evento . get_cuenta_ofertantes () > 0 : cadena += \" \\n <i>Ofertantes de la actividad</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"OPT-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) else : cadena += \" \\n <i>Ofertante de la actividad</i>: \\n \" nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , ofertante ) if demandante == \"\" : if evento . get_cuenta_demandantes () > 0 : cadena += \" \\n <i>Demandantes de la actividad</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"NON-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) else : cadena += \" \\n <i>Demandante de la actividad</i>: \\n \" nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , demandante ) cadena += \" \\n en fecha: <b> {} </b>\" . format ( evento . get_fecha_str ()) boton_callback = [[ telegram . InlineKeyboardButton ( text = texto , callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()))]] if accion != \"nada\" and accion != \"aprobar_denegar_cesion\" and accion != \"ceder_intercambiar\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) elif accion == \"aprobar_denegar_cesion\" : boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Aprobar este cambio de actividad\" , callback_data = \" {} ; {} \" . format ( \"aprobar_cesion\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Denegar este cambio de actividad\" , callback_data = \" {} ; {} \" . format ( \"denegar_cesion\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) elif accion == \"ceder_intercambiar\" : boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Ceder\" , callback_data = \" {} ; {} \" . format ( \"ceder\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Intercambiar\" , callback_data = \" {} ; {} \" . format ( \"intercambiar\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) if accion == \"nada\" : mensaje = bot . send_message ( chat_id = id_chat , text = cadena , parse_mode = \"HTML\" ) return mensaje . message_id mostrar_propuesta_cesion ( evento , demandante , ofertante = '' ) Esta funci\u00f3n se utiliza para mostrar la propuesta a los administradores para que puedan aprobarla o denegarla. Parameters: Name Type Description Default evento gestor_calendario . Evento Evento que se va a mostrar required demandante str required Returns: Type Description bool Verdadero si lo hace con \u00e9xito, falso si no Source code in modulos\\telegram_tools.py 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 def mostrar_propuesta_cesion ( evento : gestor_calendario . Evento , demandante : str , ofertante : str = \"\" ): \"\"\" Esta funci\u00f3n se utiliza para mostrar la propuesta a los administradores para que puedan aprobarla o denegarla. Args: evento: Evento que se va a mostrar demandante: Returns: (bool): Verdadero si lo hace con \u00e9xito, falso si no \"\"\" try : relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cadena = \"<b> {} </b> - <i> {} </i> \\n \" . format ( evento . get_summary (), evento . get_fecha_str ()) if evento . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) if ofertante == \"\" : cursor . execute ( f \"\"\"SELECT ofertante FROM oferta_demanda where uid_evento=\" { evento . get_uid () } \" and demandante=\" { demandante } \";\"\"\" ) lectura = cursor . fetchall () if lectura != []: ofertante = lectura [ 0 ][ 0 ] nombre_ofertante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )) nombre_demandante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante )) cadena += \" \\n <b> {} </b> (<i> {} </i>) cede a \\n <b> {} </b> (<i> {} </i>)\" . format ( nombre_ofertante , ofertante , nombre_demandante , demandante ) boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Aprobar este cambio de actividad\" , callback_data = \" {} ; {} \" . format ( \"aprobar_cesion\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Denegar este cambio de actividad\" , callback_data = \" {} ; {} \" . format ( \"denegar_cesion\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = canalid_admin , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) cursor . execute ( f \"\"\"UPDATE oferta_demanda SET id_mensaje_canal_admins=\" { mensaje . message_id } \" where uid_evento=\" { evento . get_uid () } \" and demandante=\" { demandante } \" and ofertante=\" { ofertante } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () return True except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () return False mostrar_propuesta_intercambio ( evento_ofertado , evento_propuesto , demandante , ofertante ) Esta funci\u00f3n se utiliza para mostrar la propuesta de intercambio a los administradores para que puedan aprobarla o denegarla. Parameters: Name Type Description Default evento_ofertado gestor_calendario . Evento Evento ofertado por el ofertante required evento_propuesto gestor_calendario . Evento Evento propuesto por el demandante required ofertante str Correo del ofertante required demandante str Correo del demandante required Source code in modulos\\telegram_tools.py 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 def mostrar_propuesta_intercambio ( evento_ofertado : gestor_calendario . Evento , evento_propuesto : gestor_calendario . Evento , demandante : str , ofertante : str ): \"\"\" Esta funci\u00f3n se utiliza para mostrar la propuesta de intercambio a los administradores para que puedan aprobarla o denegarla. Args: evento_ofertado: Evento ofertado por el ofertante evento_propuesto: Evento propuesto por el demandante ofertante: Correo del ofertante demandante: Correo del demandante \"\"\" try : relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cadena = \"Evento ofertado: \\n <b> {} </b> - {} \\n \" . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str ()) if evento_ofertado . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento_ofertado . get_asistentes (): if evento_ofertado . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) nombre_ofertante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )) nombre_demandante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante )) cadena += \" \\n <b> {} </b> (<i> {} </i>) intercambia a \\n <b> {} </b> (<i> {} </i>) su participaci\u00f3n a cambio de \\n \" . format ( nombre_ofertante , ofertante , nombre_demandante , demandante ) cadena += \" \\n Evento propuesto: \\n <b> {} </b> - {} \\n \" . format ( evento_propuesto . get_summary (), evento_propuesto . get_fecha_str ()) if evento_propuesto . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento_propuesto . get_asistentes (): if evento_propuesto . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Aprobar este intercambio de actividades\" , callback_data = \" {} ; {} \" . format ( \"aprobar_intercambio\" , evento_ofertado . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Denegar este intercambio de actividades\" , callback_data = \" {} ; {} \" . format ( \"denegar_intercambio\" , evento_ofertado . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = canalid_admin , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) cursor . execute ( f \"\"\"UPDATE oferta_demanda set uid_evento_propuesta_intercambio=\" { evento_propuesto . get_uid () } \",id_mensaje_canal_admins=\" { str ( mensaje . message_id ) } \",accion=\"enviado\" WHERE demandante=\" { demandante } \" and ofertante=\" { ofertante } \" and accion=\"propuestas\" and uid_evento=\" { evento_ofertado . get_uid () } \" and id_mensaje_canal_publicaciones is null and uid_evento_propuesta_intercambio is null;\"\"\" ) relacion . commit () cursor . close () relacion . close () return True except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () return False notificar_aprobar_cesion ( borrados , asentados , evento ) Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Parameters: Name Type Description Default borrados list [ str ] Usuarios que se borran del evento required asentados list [ str ] Usuarios que se agregan al evento required evento gestor_calendario . Evento Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 def notificar_aprobar_cesion ( borrados : list [ str ], asentados : list [ str ], evento : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Args: borrados: Usuarios que se borran del evento asentados: Usuarios que se agregan al evento evento: Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : for borrado in borrados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( borrado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido aprobado. Ha sido usted excluido de la actividad {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) for asentado in asentados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( asentado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido aprobado. Ha sido usted incluido en la actividad {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False notificar_aprobar_propuesta_intercambio ( ofertante , demandante , evento_ofertado , evento_propuesto ) Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Parameters: Name Type Description Default ofertante str Usuarios que ofrecio el evento ofertado y acepto el propuesto required demandante str Usuarios que demando el evento ofertado y ofrecio el propuesto required evento_ofertado gestor_calendario . Evento Evento ofertado para intercambio. Necesario para obtener las fechas y el resumen required evento_propuesto gestor_calendario . Evento Evento propuesto para intercambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 def notificar_aprobar_propuesta_intercambio ( ofertante : str , demandante : str , evento_ofertado : gestor_calendario . Evento , evento_propuesto : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Args: ofertante: Usuarios que ofrecio el evento ofertado y acepto el propuesto demandante: Usuarios que demando el evento ofertado y ofrecio el propuesto evento_ofertado: Evento ofertado para intercambio. Necesario para obtener las fechas y el resumen evento_propuesto: Evento propuesto para intercambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El intercambio ha sido aprobado. \\n\\n Ha sido usted excluido de la actividad {} - {} \\n Ha sido incluido en la actividad {} - {} \" . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str (), evento_propuesto . get_summary (), evento_propuesto . get_fecha_str ())) id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El intercambio ha sido aprobado. \\n\\n Ha sido usted incluido en la actividad {} - {} \\n Ha sido excluido de la actividad {} - {} \" . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str (), evento_propuesto . get_summary (), evento_propuesto . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False notificar_denegar_cesion ( borrados , mantenidos , evento ) Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Parameters: Name Type Description Default borrados list [ str ] Usuarios que se borran del evento required mantenidos list [ str ] Usuarios que se agregan al evento required evento gestor_calendario . Evento Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 def notificar_denegar_cesion ( borrados : list [ str ], mantenidos : list [ str ], evento : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Args: borrados: Usuarios que se borran del evento mantenidos: Usuarios que se agregan al evento evento: Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : for borrado in borrados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( borrado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Ha sido usted excluido de la actividad {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) for mantenido in mantenidos : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( mantenido )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Se mantiene usted en la actividad {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False notificar_denegar_propuesta_intercambio ( ofertante , demandante , evento_ofertado , evento_propuesto ) Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Parameters: Name Type Description Default ofertante str Usuarios que ofrecio el evento ofertado y acepto el propuesto required demandante str Usuarios que demando el evento ofertado y ofrecio el propuesto required evento_ofertado gestor_calendario . Evento Evento ofertado para intercambio. Necesario para obtener las fechas y el resumen required evento_propuesto gestor_calendario . Evento Evento propuesto para intercambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 def notificar_denegar_propuesta_intercambio ( ofertante : str , demandante : str , evento_ofertado : gestor_calendario . Evento , evento_propuesto : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Args: ofertante: Usuarios que ofrecio el evento ofertado y acepto el propuesto demandante: Usuarios que demando el evento ofertado y ofrecio el propuesto evento_ofertado: Evento ofertado para intercambio. Necesario para obtener las fechas y el resumen evento_propuesto: Evento propuesto para intercambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Mantiene usted su actividad {} - {} \" . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str ())) id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Mantiene usted su actividad {} - {} \" . format ( evento_propuesto . get_summary (), evento_propuesto . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False permutar_evento ( uid , attendee ) Funci\u00f3n para que un usuario pueda demandar un puesto en una guardia ofrecida y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a demandar un puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def permutar_evento ( uid : str , attendee : str ): \"\"\" Funci\u00f3n para que un usuario pueda demandar un puesto en una guardia ofrecida y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a demandar un puesto en una guardia Returns: (gestor_calendario.Evento|None):Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_propuestas . get_evento ( uid ) if isinstance ( evento , gestor_calendario . Evento ): evento_permutado = cal_propuestas . tomar_evento ( correo_usuario = attendee , uid_evento = uid , tipo = 'GROUP' ) if isinstance ( evento_permutado , gestor_calendario . Evento ): return evento_permutado else : return None else : return None except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None registro_paso1 ( update , context ) Primer paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Returns: Type Description int Devuelve estado actual del registro_paso1. Paso 1 completo Source code in modulos\\telegram_tools.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def registro_paso1 ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> int : \"\"\" Primer paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram Returns: Devuelve estado actual del registro_paso1. Paso 1 completo \"\"\" context . bot . send_message ( chat_id = update . message . chat_id , text = \"Introduce tu correo electronico para identificarte en la plataforma\" , reply_markup = telegram . ForceReply ()) return 1 registro_paso2 ( update , context ) Segundo paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Returns: Type Description int Devuelve estado actual del registro_paso1. O bien vuelta a empezar este paso o fin de avance en estados Source code in modulos\\telegram_tools.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def registro_paso2 ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> int : \"\"\" Segundo paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram Returns: Devuelve estado actual del registro_paso1. O bien vuelta a empezar este paso o fin de avance en estados \"\"\" logging . getLogger ( __name__ ) . debug ( update . message . text ) idusuario = False if ( \"@\" in update . message . text ): try : # Aqui pedimos a la API Rest la ID del usuario con su email respuesta = servicio_rest . GetIDPorEmail ( email = update . message . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta a GETIDPorEmail es:\" + str ( respuesta ) + \" tipo \" + str ( respuesta . isdigit ())) if respuesta . isdigit (): idusuario = respuesta elif respuesta == \"Email not found\" : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Su correo no ha sido encontrado en la plataforma. \\n Por favor, consulte al \" \"administrador de su sistema para comprobar que sus datos estan adecuadamente \" \"agregados\" ) return ConversationHandler . END if idusuario != False : logging . getLogger ( __name__ ) . debug ( idusuario ) logging . getLogger ( __name__ ) . debug ( update . effective_chat . id ) respuesta = servicio_rest . InsertaTelegramID ( idusuario = str ( idusuario ), chatid = update . effective_chat . id ) logging . getLogger ( __name__ ) . debug ( \"Valor de respuesta \" + str ( respuesta )) # Aqui har\u00edamos la consulta a REST para preguntar si existe ese correo electr\u00f3nico. Si es el caso, # enviar\u00edamos el id if respuesta == 'ID de telegram actualizado' : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha sido identificado en la plataforma, {} \" . format ( servicio_rest . GetNombrePorID ( idusuario ))) # Imprimimos su nombre else : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) botones ( update , context ) return ConversationHandler . END except Exception as e : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ConversationHandler . END else : update . message . reply_text ( \"La cadena no tiene un @. Intente de nuevo enviar su correo\" ) return 1 retorno_aprobar_cesion ( update , context ) Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 @autenticar_retorno_admin def retorno_aprobar_cesion ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"aprobar_cesion\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento = cal_propuestas . get_evento ( uid_evento ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cursor . execute ( f \"\"\"SELECT ofertante,demandante FROM oferta_demanda where uid_evento=\" { evento . get_uid () } \" and id_mensaje_canal_admins=\" { update . callback_query . message . message_id } \" and accion=\"ceder\";\"\"\" ) lectura = cursor . fetchall () ofertante = lectura [ 0 ][ 0 ] demandante = lectura [ 0 ][ 1 ] evento . asienta_asistentes ( ofertante = ofertante , demandante = demandante ) if isinstance ( evento , gestor_calendario . Evento ): evento_modificado = cal_principal . get_evento ( uid_evento ) evento_modificado . set_asistente ( demandante , 'REQ-PARTICIPANT' ) evento_modificado . borrar_asistente ( ofertante ) if cal_principal . set_evento ( evento_modificado ): if evento . get_cuenta_ofertantes () == 0 : cal_propuestas . borrar_evento ( uid_evento ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) texto_final = \"La propuesta de cambio de la actividad <b> {} </b> con fecha <i> {} </i> ha sido aprobada. \\n Se ha excluido a {} \\n\\n Se ha incluido a {} \" \\ . format ( evento . get_summary (), evento . get_fecha_str (), servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )), servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante ))) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final , parse_mode = \"HTML\" ) notificar_aprobar_cesion ([ ofertante ], [ demandante ], evento_modificado ) servicio_rest . SetEvento ( evento_modificado . get_data ()) else : logging . getLogger ( __name__ ) . debug ( \"El evento {} se ha borrado del calendario de propuestas\" . format ( uid_evento )) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { ofertante } \" and demandante=\" { demandante } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) retorno_aprobar_intercambio ( update , context ) Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 @autenticar_retorno_admin def retorno_aprobar_intercambio ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento_ofertado = update . callback_query . data . split ( ';' ) evento_ofertado = cal_propuestas . get_evento ( uid_evento_ofertado ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cursor . execute ( f \"\"\"SELECT ofertante,demandante,uid_evento_propuesta_intercambio FROM oferta_demanda where uid_evento=\" { evento_ofertado . get_uid () } \" and id_mensaje_canal_admins=\" { update . callback_query . message . message_id } \" and accion=\"enviado\";\"\"\" ) lectura = cursor . fetchall () ofertante = lectura [ 0 ][ 0 ] demandante = lectura [ 0 ][ 1 ] uid_evento_propuesto = lectura [ 0 ][ 2 ] evento_ofertado . asienta_asistentes ( ofertante = ofertante , demandante = demandante ) evento_propuesto = cal_principal . get_evento ( uid_evento = uid_evento_propuesto ) if isinstance ( evento_ofertado , gestor_calendario . Evento ): evento_modificado = cal_principal . get_evento ( uid_evento_ofertado ) evento_modificado . set_asistente ( demandante , 'REQ-PARTICIPANT' ) evento_modificado . borrar_asistente ( ofertante ) evento_propuesto . set_asistente ( ofertante , 'REQ-PARTICIPANT' ) evento_propuesto . borrar_asistente ( demandante ) if cal_principal . set_evento ( evento_modificado ) and cal_principal . set_evento ( evento_propuesto ): if evento_ofertado . get_cuenta_ofertantes () == 0 : cal_propuestas . borrar_evento ( uid_evento_ofertado ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) texto_final = \"La propuesta de intercambio ha sido aprobada. \\n La actividad <b> {} </b> - <i> {} </i> ofertada por <b> {} </b> \\n \" \\ \"Intercambiada por la actividad <b> {} </b> - <i> {} </i> propuesta por <b> {} </b>\" \\ . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str (), servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )), evento_propuesto . get_summary (), evento_propuesto . get_fecha_str () , servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante ))) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final , parse_mode = \"HTML\" ) notificar_aprobar_propuesta_intercambio ( ofertante , demandante , evento_modificado , evento_propuesto ) servicio_rest . SetEvento ( evento_modificado . get_data ()) servicio_rest . SetEvento ( evento_propuesto . get_data ()) else : logging . getLogger ( __name__ ) . debug ( \"El evento {} se ha borrado del calendario de propuestas\" . format ( uid_evento_ofertado )) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento_ofertado } \" and ofertante=\" { ofertante } \" and demandante=\" { demandante } \" and uid_evento_propuesta_intercambio=\" { uid_evento_propuesto } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento_ofertado , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento_ofertado , update . callback_query , e )) retorno_cancelar_cesion ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 @autenticar_retorno def retorno_cancelar_cesion ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"cancelar_cesion\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cursor . execute ( f \"\"\"SELECT ofertante,demandante,id_mensaje_canal_publicaciones,id_mensaje_canal_admins,accion FROM oferta_demanda where uid_evento=\" { uid_evento } \";\"\"\" ) resultado = cursor . fetchall () if resultado != []: ofertante = resultado [ 0 ][ 0 ] demandante = resultado [ 0 ][ 1 ] id_mensaje_canal_publicaciones = resultado [ 0 ][ 2 ] id_mensaje_canal_admins = resultado [ 0 ][ 3 ] accion = resultado [ 0 ][ 4 ] if demandante is not None : if demandante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , demandante ) elif ofertante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , demandante ) cancelado = cancelar_propuesta_evento ( uid_evento , ofertante ) elif ofertante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , ofertante ) if isinstance ( cancelado , gestor_calendario . Evento ): if id_mensaje_canal_admins is not None : borrar_mensaje ( id_chat = canalid_admin , id_mensaje = id_mensaje_canal_admins ) if id_mensaje_canal_publicaciones is not None : borrar_mensaje ( id_chat = canalid , id_mensaje = id_mensaje_canal_publicaciones ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) if demandante is not None : if demandante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )), text = \"Se ha cancelado la propuesta de cesi\u00f3n. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) idmensaje = mostrar_datos_evento ( \"resumen\" , cancelado , canalid , \"tomar\" ) cursor . execute ( f \"\"\"UPDATE oferta_demanda set id_mensaje_canal_admins=null,demandante=null,id_mensaje_canal_publicaciones=\" { idmensaje } \" where uid_evento=\" { uid_evento } \" and ofertante=\" { ofertante } \" and accion=\"ceder\" and demandante=\" { correo } \";\"\"\" ) relacion . commit () elif ofertante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )), text = \"Se ha cancelado la propuesta de cesi\u00f3n. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )), text = \"Se ha cancelado la propuesta de cesi\u00f3n. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and demandante=\" { demandante } \"and accion=\"ceder\";\"\"\" ) relacion . commit () elif ofertante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )), text = \"Se ha cancelado la propuesta de cesi\u00f3n. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and accion=\"ceder\";\"\"\" ) relacion . commit () else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se pudo cancelar con \u00e9xito la propuesta de {} en fecha {} , dado que la oferta ya no existe\" . format ( cancelado . get_summary (), cancelado . get_fecha_str () ) ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_cancelar_intercambio ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 @autenticar_retorno def retorno_cancelar_intercambio ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cursor . execute ( f \"\"\"SELECT ofertante,demandante,id_mensaje_canal_publicaciones,id_mensaje_canal_admins,accion FROM oferta_demanda where uid_evento=\" { uid_evento } \";\"\"\" ) resultado = cursor . fetchall () if resultado != []: ofertante = resultado [ 0 ][ 0 ] demandante = resultado [ 0 ][ 1 ] id_mensaje_canal_publicaciones = resultado [ 0 ][ 2 ] id_mensaje_canal_admins = resultado [ 0 ][ 3 ] accion = resultado [ 0 ][ 4 ] if accion == \"intercambiar\" or accion == \"enviado\" : if demandante is not None : if demandante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , demandante ) elif ofertante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , demandante ) cancelado = cancelar_propuesta_evento ( uid_evento , ofertante ) elif ofertante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , ofertante ) if isinstance ( cancelado , gestor_calendario . Evento ): if id_mensaje_canal_admins is not None : borrar_mensaje ( id_chat = canalid_admin , id_mensaje = id_mensaje_canal_admins ) if id_mensaje_canal_publicaciones is not None : borrar_mensaje ( id_chat = canalid , id_mensaje = id_mensaje_canal_publicaciones ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) if demandante is not None : if demandante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )), text = \"Se ha cancelado la propuesta de intercambio. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) idmensaje = mostrar_datos_evento ( \"resumen\" , cancelado , canalid , \"permutar\" ) cursor . execute ( f \"\"\"UPDATE oferta_demanda set id_mensaje_canal_admins=null,demandante=null,uid_evento_propuesta_intercambio=null,id_mensaje_canal_publicaciones=\" { idmensaje } \",accion=\"intercambiar\" where uid_evento=\" { uid_evento } \" and ofertante=\" { ofertante } \" and demandante=\" { correo } \";\"\"\" ) relacion . commit () elif ofertante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )), text = \"Se ha cancelado la propuesta de intercambio. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )), text = \"Se ha cancelado la propuesta de intercambio. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and demandante=\" { demandante } \"and accion=\"intercambiar\";\"\"\" ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and demandante=\" { demandante } \"and accion=\"enviado\";\"\"\" ) relacion . commit () elif ofertante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )), text = \"Se ha cancelado la propuesta de intercambio. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and accion=\"intercambiar\";\"\"\" ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and accion=\"enviado\";\"\"\" ) relacion . commit () else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se pudo cancelar con \u00e9xito la propuesta {} en fecha {} , dado que la oferta ya no existe\" . format ( cancelado . get_summary (), cancelado . get_fecha_str () ) ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se puede cancelar esta propuesta actualmente hasta que se decidan las propuestas.\" . format ( cancelado . get_summary (), cancelado . get_fecha_str () ) ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_ceder ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es ceder, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 @autenticar_retorno def retorno_ceder ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es ceder, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"ceder\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cedido = ceder_evento ( uid_evento , correo ) if isinstance ( cedido , gestor_calendario . Evento ): borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha ofrecido para cesi\u00f3n con \u00e9xito el evento {} en fecha {} \" . format ( cedido . get_summary (), cedido . get_fecha_str ())) idmensaje = mostrar_datos_evento ( \"resumen\" , cedido , canalid , \"tomar\" ) cursor . execute ( f \"\"\"INSERT INTO oferta_demanda (ofertante,uid_evento,id_mensaje_canal_publicaciones,accion) VALUES ( \" { correo } \",\" { cedido . get_uid () } \",' { idmensaje } ',\"ceder\");\"\"\" ) relacion . commit () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_denegar_cesion ( update , context ) Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 @autenticar_retorno_admin def retorno_denegar_cesion ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"denegar_cesion\" : evento = cal_propuestas . get_evento ( uid_evento ) evento_original = cal_principal . get_evento ( uid_evento ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cursor . execute ( f \"\"\"SELECT ofertante,demandante FROM oferta_demanda where uid_evento=\" { evento . get_uid () } \" and id_mensaje_canal_admins=\" { update . callback_query . message . message_id } \" and accion=\"ceder\";\"\"\" ) lectura = cursor . fetchall () ofertante = lectura [ 0 ][ 0 ] demandante = lectura [ 0 ][ 1 ] if ( evento . negar_cambio_asistentes ( ofertante = ofertante , demandante = demandante )): resultado = cal_propuestas . set_evento ( evento ) if resultado == True : texto_final = \"Se ha denegado con \u00e9xito la cesi\u00f3n de <b> {} </b> con fecha <i> {} </i>\" . format ( evento . get_summary (), evento . get_fecha_str ()) if evento . get_cuenta_ofertantes () == 0 : cal_propuestas . borrar_evento ( evento . get_uid ()) notificar_denegar_cesion ( borrados = list ([ demandante ]), mantenidos = list ([ ofertante ]), evento = evento ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final , parse_mode = \"HTML\" ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Ha habido un problema a la hora de inscribirse en el evento.\" \"P\u00f3ngase en contacto con un administrador\" ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { ofertante } \" and demandante=\" { demandante } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_denegar_intercambio ( update , context ) Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 @autenticar_retorno_admin def retorno_denegar_intercambio ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento_ofertado = update . callback_query . data . split ( ';' ) correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento_ofertado = cal_propuestas . get_evento ( uid_evento_ofertado ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cursor . execute ( f \"\"\"SELECT ofertante,demandante,uid_evento_propuesta_intercambio FROM oferta_demanda where uid_evento=\" { evento_ofertado . get_uid () } \" and id_mensaje_canal_admins=\" { update . callback_query . message . message_id } \" and accion=\"enviado\";\"\"\" ) lectura = cursor . fetchall () ofertante = lectura [ 0 ][ 0 ] demandante = lectura [ 0 ][ 1 ] uid_evento_propuesto = lectura [ 0 ][ 2 ] evento_propuesto = cal_principal . get_evento ( uid_evento = uid_evento_propuesto ) nombre_ofertante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )) nombre_demandante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante )) if ( evento_ofertado . negar_cambio_asistentes ( ofertante = ofertante , demandante = demandante )): resultado = cal_propuestas . set_evento ( evento_ofertado ) if resultado == True : texto_final = \"Se ha denegado con \u00e9xito el intercambio de \\n {} - {} ofertado por {} y \\n {} - {} propuesto por {} \" \\ . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str (), nombre_ofertante , evento_propuesto . get_summary (), evento_propuesto . get_fecha_str (), nombre_demandante ) if evento_ofertado . get_cuenta_ofertantes () == 0 : cal_propuestas . borrar_evento ( evento_ofertado . get_uid ()) notificar_denegar_propuesta_intercambio ( demandante = demandante , ofertante = ofertante , evento_propuesto = evento_propuesto , evento_ofertado = evento_ofertado ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento_ofertado } \" and ofertante=\" { ofertante } \" and demandante=\" { demandante } \" and uid_evento_propuesta_intercambio=\" { uid_evento_propuesto } \";\"\"\" ) relacion . commit () else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Ha habido un problema a la hora de inscribirse en el evento.\" \"P\u00f3ngase en contacto con un administrador\" ) cursor . close () relacion . close () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento_ofertado , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento_ofertado , update . callback_query , e )) cursor . close () relacion . close () retorno_intercambiar ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es intercambiar, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 @autenticar_retorno def retorno_intercambiar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es intercambiar, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"intercambiar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) intercambiado = intercambiar_evento ( uid_evento , correo ) if isinstance ( intercambiado , gestor_calendario . Evento ): borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha ofrecido para intercambio con \u00e9xito el evento {} en fecha {} \" . format ( intercambiado . get_summary (), intercambiado . get_fecha_str ())) idmensaje = mostrar_datos_evento ( \"resumen\" , intercambiado , canalid , \"permutar\" ) cursor . execute ( f \"\"\"INSERT INTO oferta_demanda (ofertante,uid_evento,id_mensaje_canal_publicaciones,accion) VALUES ( \" { correo } \",\" { intercambiado . get_uid () } \",' { idmensaje } ',\"intercambiar\");\"\"\" ) relacion . commit () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_permutar ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es permutar, el demandante recibe una encuesta con todas sus guardias futuras para proponer algunas de ellas como intercambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 @autenticar_retorno def retorno_permutar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es permutar, el demandante recibe una encuesta con todas sus guardias futuras para proponer algunas de ellas como intercambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid botones = [] relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"permutar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) permutado = permutar_evento ( uid_evento , correo ) cursor . execute ( f \"\"\"SELECT ofertante FROM oferta_demanda where accion=\"intercambiar\" and uid_evento=\" { uid_evento } \" and id_mensaje_canal_publicaciones=\" { update . callback_query . message . message_id } \" and demandante is null;\"\"\" ) datos = cursor . fetchall () ofertante = datos [ 0 ][ 0 ] if isinstance ( permutado , gestor_calendario . Evento ): cursor . execute ( f \"\"\"UPDATE oferta_demanda set demandante=\" { correo } \",id_mensaje_canal_publicaciones=null,accion=\"permutar\" where uid_evento=\" { uid_evento } \" and id_mensaje_canal_publicaciones=\" { update . callback_query . message . message_id } \" and accion=\"intercambiar\";\"\"\" ) relacion . commit () borrar_mensaje ( id_chat = canalid , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha demandado para intercambio el evento {} en fecha {} \" . format ( permutado . get_summary (), permutado . get_fecha_str ())) reply_markup , texto = lista_propuestas_seleccionadas ( correo ) mensaje = context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto , reply_markup = reply_markup ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_tomar_cesion ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es tomar, a\u00f1ade al usuario con el rol NON-PARTICIPANT al evento en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 @autenticar_retorno def retorno_tomar_cesion ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es tomar, a\u00f1ade al usuario con el rol NON-PARTICIPANT al evento en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid , canalid_admin relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () idmensaje = None try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"tomar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento = cal_principal . get_evento ( uid_evento ) if evento . get_comprobar_asistente ( correo ) != True : tomado = tomar_evento ( uid_evento , correo ) if isinstance ( tomado , gestor_calendario . Evento ): cursor . execute ( f \"\"\"SELECT ofertante FROM oferta_demanda where uid_evento=\" { tomado . get_uid () } \"and demandante IS NULL and accion=\"ceder\" and id_mensaje_canal_publicaciones=\" { update . callback_query . message . message_id } \";\"\"\" ) datos = cursor . fetchall () ofertante = datos [ 0 ][ 0 ] context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Evento en el que se ha inscrito\" ) mostrar_datos_evento ( \"completo\" , tomado , update . callback_query . from_user . id , \"nada\" , demandante = correo , ofertante = ofertante ) borrar_mensaje ( id_chat = canalid , id_mensaje = update . callback_query . message . message_id ) cursor . execute ( f \"\"\"UPDATE oferta_demanda set id_mensaje_canal_publicaciones=null,demandante=\" { correo } \" where uid_evento=\" { tomado . get_uid () } \"and demandante IS NULL and accion=\"ceder\" and ofertante=\" { ofertante } \";\"\"\" ) relacion . commit () mostrar_propuesta_cesion ( tomado , demandante = correo , ofertante = ofertante ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No puede demandar este evento porque ya est\u00e1 inscrito en \u00e9l o no hay puestos libres\" ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se puede usted inscribir en el evento porque ya est\u00e1 inscrito\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () start ( token_bot , cal_prim , cal_prop , canal_id , canal_id_admin , path_sqlite ) Funci\u00f3n de inicializaci\u00f3n del bot de Telegram Parameters: Name Type Description Default token_bot str Token de Telegram para autenticar el bot en el sistema de Telegram required cal_prim str Calendario principal que se utiliza en el servicio de guardias required cal_prop str Calendario de propuestas de cambio en el servicio de guardias required canal_id str Id para el canal de publicaci\u00f3n de guardias. required Source code in modulos\\telegram_tools.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def start ( token_bot : str , cal_prim : str , cal_prop : str , canal_id : str , canal_id_admin : str , path_sqlite : str ): \"\"\" Funci\u00f3n de inicializaci\u00f3n del bot de Telegram Args: token_bot: Token de Telegram para autenticar el bot en el sistema de Telegram cal_prim: Calendario principal que se utiliza en el servicio de guardias cal_prop: Calendario de propuestas de cambio en el servicio de guardias canal_id: Id para el canal de publicaci\u00f3n de guardias. \"\"\" global tokenbot , bot , cal_principal , cal_propuestas , canalid , canalid_admin , path_sqlite3 cal_principal = cal_prim cal_propuestas = cal_prop canalid = canal_id canalid_admin = canal_id_admin tokenbot = token_bot path_sqlite3 = path_sqlite bot = telegram . Bot ( token = token_bot ) tomar_evento ( uid , attendee ) Funci\u00f3n para que un usuario pueda demandar un puesto en una guardia ofrecida y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a demandar un puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 def tomar_evento ( uid : str , attendee : str ): \"\"\" Funci\u00f3n para que un usuario pueda demandar un puesto en una guardia ofrecida y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a demandar un puesto en una guardia Returns: (gestor_calendario.Evento|None):Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_propuestas . get_evento ( uid ) if isinstance ( evento , gestor_calendario . Evento ): evento_tomado = cal_propuestas . tomar_evento ( correo_usuario = attendee , uid_evento = uid ) if isinstance ( evento_tomado , gestor_calendario . Evento ): return evento_tomado else : return None else : return None except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"telegram_tools"},{"location":"telegram_tools/#modulos.telegram_tools.autenticar","text":"M\u00e9todo para autenticar usuario al usar las funciones. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def autenticar ( func ): \"\"\" M\u00e9todo para autenticar usuario al usar las funciones. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func (function): Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = args [ 0 ] . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): func ( * args , ** kwargs ) elif \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper","title":"autenticar()"},{"location":"telegram_tools/#modulos.telegram_tools.autenticar_admin","text":"M\u00e9todo para autenticar usuario al usar las funciones del bot. Verifica si es un administrador. Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def autenticar_admin ( func ): \"\"\" M\u00e9todo para autenticar usuario al usar las funciones del bot. Verifica si es un administrador. Se utiliza como un decorador Args: func (function): Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = args [ 0 ] . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : func ( * args , ** kwargs ) else : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No tiene el rol adecuado para esta funci\u00f3n.\" \"Verifique sus permisos con el administrador del sistema\" ) if \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper","title":"autenticar_admin()"},{"location":"telegram_tools/#modulos.telegram_tools.autenticar_retorno","text":"M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def autenticar_retorno ( func ): \"\"\" M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func (function): Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = str ( args [ 0 ] . callback_query . from_user . id ) id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): func ( * args , ** kwargs ) elif \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper","title":"autenticar_retorno()"},{"location":"telegram_tools/#modulos.telegram_tools.autenticar_retorno_admin","text":"M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def autenticar_retorno_admin ( func ): \"\"\" M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func (function): Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = str ( args [ 0 ] . callback_query . from_user . id ) id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : func ( * args , ** kwargs ) else : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No tiene el rol adecuado para esta funci\u00f3n.\" \"Verifique sus permisos con el administrador del sistema\" ) if \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper","title":"autenticar_retorno_admin()"},{"location":"telegram_tools/#modulos.telegram_tools.borrar_mensaje","text":"Funci\u00f3n para borrar un mensaje cuando se ha cursado la petici\u00f3n de tomar un evento Parameters: Name Type Description Default id_chat str | int Id del chat de donde se hace la acci\u00f3n de tomar evento required id_mensaje str | int ID del mensaje a borrar required Returns: Type Description bool Verdadero si pudo completarlo, falso si no Source code in modulos\\telegram_tools.py 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 def borrar_mensaje ( id_chat : str | int , id_mensaje : str | int ) -> bool : \"\"\" Funci\u00f3n para borrar un mensaje cuando se ha cursado la petici\u00f3n de tomar un evento Args: id_chat: Id del chat de donde se hace la acci\u00f3n de tomar evento id_mensaje: ID del mensaje a borrar Returns: Verdadero si pudo completarlo, falso si no \"\"\" terminado : bool = False try : terminado = bot . deleteMessage ( chat_id = id_chat , message_id = id_mensaje ) return terminado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return terminado","title":"borrar_mensaje()"},{"location":"telegram_tools/#modulos.telegram_tools.botones","text":"Funci\u00f3n para mostrar los botones en el chat que ejecutar\u00e1n las funciones para el usuario Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 @autenticar def botones ( update : telegram . Update , context : telegram . ext . CallbackContext ): \"\"\" Funci\u00f3n para mostrar los botones en el chat que ejecutar\u00e1n las funciones para el usuario Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" id_user = update . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : kb = [ [ telegram . KeyboardButton ( 'Actividades propias' ) ], [ telegram . KeyboardButton ( 'Actividades pendientes de ser aprobadas o denegadas' ), ], ] else : kb = [ [ telegram . KeyboardButton ( 'Actividades propias' ) ], [ telegram . KeyboardButton ( 'Actividades pendientes de ser aprobadas o denegadas' ) ] ] kb_markup = telegram . ReplyKeyboardMarkup ( kb , resize_keyboard = True ) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Seleccione una opcion\" , reply_markup = kb_markup )","title":"botones()"},{"location":"telegram_tools/#modulos.telegram_tools.cancelar_propuesta_evento","text":"Funci\u00f3n para que un usuario pueda cancelar su oferta o su demanda Parameters: Name Type Description Default uid str | int Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a cancelar su propuesta required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 def cancelar_propuesta_evento ( uid : str | int , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda cancelar su oferta o su demanda Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a cancelar su propuesta Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento_cancelado = cal_propuestas . cancelar_evento ( correo_usuario = attendee , uid_evento = uid ) if isinstance ( evento_cancelado , gestor_calendario . Evento ): return evento_cancelado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"cancelar_propuesta_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.ceder_evento","text":"Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a ceder su puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 def ceder_evento ( uid : str , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a ceder su puesto en una guardia Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_principal . get_evento ( uid ) evento_cedido = cal_propuestas . ofertar_evento ( correo_usuario = attendee , evento = evento , uid_evento = uid ) if isinstance ( evento_cedido , gestor_calendario . Evento ): return evento_cedido except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"ceder_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.editar_datos_evento","text":"Funci\u00f3n para editar un mensaje de Telegram con los datos de un evento. Utilizada para actualizar los mensajes en el canal de publicaci\u00f3n de guardias Parameters: Name Type Description Default evento gestor_calendario . Evento Evento que se va a actualizar required id_chat str Identificador del chat donde se edita el mensaje required id_mensaje str Identificador del mensaje que se va a editar required accion str Acci\u00f3n que se incluye en el bot\u00f3n que est\u00e1 debajo de la publicaci\u00f3n del mensaje, que luego interacciona con los retornos 'nada' Source code in modulos\\telegram_tools.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def editar_datos_evento ( evento : gestor_calendario . Evento , id_chat : str , id_mensaje : str , accion : str = \"nada\" ): \"\"\" Funci\u00f3n para editar un mensaje de Telegram con los datos de un evento. Utilizada para actualizar los mensajes en el canal de publicaci\u00f3n de guardias Args: evento: Evento que se va a actualizar id_chat: Identificador del chat donde se edita el mensaje id_mensaje: Identificador del mensaje que se va a editar accion: Acci\u00f3n que se incluye en el bot\u00f3n que est\u00e1 debajo de la publicaci\u00f3n del mensaje, que luego interacciona con los retornos \"\"\" reply_markup = [] mensaje = None if accion == \"cancelar_cesion\" : texto = \"Cancelar propuesta de cambio\" if accion == \"tomar\" : texto = \"Pedir esta actividad cedida\" if accion == \"ceder\" : texto = \"Ofrecer esta actividad\" if accion == \"aprobar_denegar\" : texto = \"Aprobar este cambio de actividad\" if accion == \"permutar\" : texto = \"Pedir esta actividad para intercambio\" if accion == \"rechazar\" : texto = \"Rechazar intercambio\" if accion == \"escoger\" : texto = \"Escoger esta actividad para intercambio\" boton_callback = [[ telegram . InlineKeyboardButton ( text = \" {} \" . format ( texto ), callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()) ) ]] cadena = \"<b> {} </b> \\n Fecha: {} \\n Sitios libres: {} \" . format ( evento . get_summary (), evento . get_fecha_str (), evento . get_sitios_libres ()) if accion != \"nada\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . editMessageText ( chat_id = id_chat , message_id = id_mensaje , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" )","title":"editar_datos_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.guardias_aprobar_denegar","text":"Funci\u00f3n para obtener las guardias que est\u00e1n pendientes de aprobar o denegar y dar la posibilidad de aceptar o denegar el cambio Se imprimir\u00e1n las guardias y se colocar\u00e1n botones para aprobar o denegar el cambio, bajo el mensaje con los datos del evento. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 @autenticar_admin def guardias_aprobar_denegar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias que est\u00e1n pendientes de aprobar o denegar y dar la posibilidad de aceptar o denegar el cambio Se imprimir\u00e1n las guardias y se colocar\u00e1n botones para aprobar o denegar el cambio, bajo el mensaje con los datos del evento. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas # reply_markup=telegram.InlineKeyboardMarkup([]) cadena = \"\" lista_eventos = [] try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos = cal_propuestas . get_eventos ( completos = True ) # Aqui pediriamos el nombre del usuario a traves de REST, usando el id de Telegram como dato # hace falta una funci\u00f3n de obtener la ID por la ID de Telegram logging . getLogger ( __name__ ) . debug ( \"El usuario {} ha solicitado las actividades para aprobar o denegar. Fecha actual {} \" . format ( nombre_usuario , datetime . date . today ())) if lista_eventos == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay actividades pendientes de aceptar o denegar\" ) # key=lambda fecha: e.vobject_instance.vevent.dstart for e in lista_eventos : logging . getLogger ( __name__ ) . debug ( \"Evento para denegar o aprobar: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"aprobar_denegar_cesion\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error recogiendo las Actividades, por favor, p\u00f3ngase en contacto con el administrador\" )","title":"guardias_aprobar_denegar()"},{"location":"telegram_tools/#modulos.telegram_tools.guardias_disponibles","text":"Funci\u00f3n para obtener las guardias en las que hay al menos un puesto con propuesta de cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 @autenticar def guardias_disponibles ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias en las que hay al menos un puesto con propuesta de cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas reply_markup = [] lista_botones = [] cadena = \"\" lista_eventos : list [ gestor_calendario . Evento ] = cal_propuestas . get_eventos () evento_ya_suscrito = 0 try : for e in lista_eventos : if e . get_comprobar_asistente ( servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ))) != True : if e . get_asistentes ( tipo = 'INDIVIDUAL' ): mostrar_datos_evento ( \"resumen\" , evento = e , id_chat = update . message . chat_id , accion = \"tomar\" ) if e . get_asistentes ( tipo = 'GROUP' ): mostrar_datos_evento ( \"resumen\" , evento = e , id_chat = update . message . chat_id , accion = \"intercambiar\" ) else : evento_ya_suscrito += 1 if lista_eventos == [] or evento_ya_suscrito == len ( lista_eventos ): context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay Actividades disponibles\" ) logging . getLogger ( __name__ ) . debug ( \"No hay Actividades disponibles\" ) logging . getLogger ( __name__ ) . debug ( cadena ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" )","title":"guardias_disponibles()"},{"location":"telegram_tools/#modulos.telegram_tools.guardias_pendientes","text":"Funci\u00f3n para obtener las guardias en las que el usuario est\u00e1 demandando turno pero a\u00fan no se ha aprobado el cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 @autenticar def guardias_pendientes ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias en las que el usuario est\u00e1 demandando turno pero a\u00fan no se ha aprobado el cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas reply_markup = [] lista_botones = [] cadena = \"\" relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () actividad_encontrada = False try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos_ofertados = cal_propuestas . get_eventos ( attendee = email_usuario , rol = \"OPT-PARTICIPANT\" ) lista_eventos_demandados = cal_propuestas . get_eventos ( attendee = email_usuario , rol = \"NON-PARTICIPANT\" ) if lista_eventos_ofertados == [] and lista_eventos_demandados == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay Actividades pendientes de ser aprobadas o denegadas\" ) logging . getLogger ( __name__ ) . debug ( \"No hay Actividades pendientes de ser aprobadas o denegadas\" ) else : for e in lista_eventos_ofertados : cursor . execute ( f \"\"\"SELECT accion FROM oferta_demanda where uid_evento=\" { e . get_uid () } \";\"\"\" ) accion = cursor . fetchall ()[ 0 ][ 0 ] if accion == \"ceder\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_cesion\" ) actividad_encontrada = True elif accion == \"intercambiar\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_intercambio\" ) actividad_encontrada = True elif accion == \"enviado\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_intercambio\" ) actividad_encontrada = True for e in lista_eventos_demandados : cursor . execute ( f \"\"\"SELECT accion FROM oferta_demanda where uid_evento=\" { e . get_uid () } \";\"\"\" ) accion = cursor . fetchall ()[ 0 ][ 0 ] if accion == \"ceder\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_cesion\" ) actividad_encontrada = True elif accion == \"intercambiar\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_intercambio\" ) actividad_encontrada = True elif accion == \"enviado\" : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar_intercambio\" ) actividad_encontrada = True if actividad_encontrada == False : context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay Actividades pendientes de ser aprobadas o denegadas\" ) logging . getLogger ( __name__ ) . debug ( \"No hay Actividades pendientes de ser aprobadas o denegadas\" ) logging . getLogger ( __name__ ) . debug ( cadena ) cursor . close () relacion . close () except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) cursor . close () relacion . close ()","title":"guardias_pendientes()"},{"location":"telegram_tools/#modulos.telegram_tools.guardias_propias","text":"Funci\u00f3n para obtener las Actividades propias del usuario actualmente establecidas. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 @autenticar def guardias_propias ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las Actividades propias del usuario actualmente establecidas. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas # reply_markup=telegram.InlineKeyboardMarkup([]) cadena = \"\" lista_eventos : list [ gestor_calendario . Evento ] = [] evento_ya_ofrecido = 0 try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos = cal_principal . get_eventos ( email_usuario ) # Aqui pediriamos el nombre del usuario a traves de REST, usando el id de Telegram como dato #hace falta una funci\u00f3n de obtener la ID por la ID de Telegram logging . getLogger ( __name__ ) . debug ( \"El usuario {} ha solicitado sus propias actividades. Fecha actual {} \" . format ( nombre_usuario , datetime . date . today ())) if lista_eventos == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay actividades asignados a usted\" ) else : for e in lista_eventos : evento_aux = cal_propuestas . get_evento ( uid_evento = e . get_uid ()) if isinstance ( evento_aux , gestor_calendario . Evento ): if evento_aux . get_comprobar_asistente ( asistente = email_usuario , rol = \"OPT-PARTICIPANT\" ) == True : logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id ) else : logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"ceder_intercambiar\" ) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error recogiendo las Actividades propias, por favor, p\u00f3ngase en contacto con el administrador\" )","title":"guardias_propias()"},{"location":"telegram_tools/#modulos.telegram_tools.intercambiar_evento","text":"Funci\u00f3n para que un usuario pueda ofertar un intercambio de su participaci\u00f3n en una actividad y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a ceder su puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def intercambiar_evento ( uid : str , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda ofertar un intercambio de su participaci\u00f3n en una actividad y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a ceder su puesto en una guardia Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_principal . get_evento ( uid ) evento_intercambiado = cal_propuestas . ofertar_evento ( correo_usuario = attendee , evento = evento , tipo = 'GROUP' , uid_evento = uid ) if isinstance ( evento_intercambiado , gestor_calendario . Evento ): return evento_intercambiado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"intercambiar_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.lista_propuestas_seleccionadas","text":"Funci\u00f3n para listar las propuestas que el demandante env\u00eda a un ofertante de un intercambio Parameters: Name Type Description Default demandante str Correo del demandante required eventos_ya_propuestos list [ str ] Lista de id de eventos ya agregados en la propuesta. Se utiliza para evitar que el demandante pueda incluir un evento varias veces [] ofertante str Correo del ofertante para que no se puedan proponer eventos que el ofertante ya est\u00e9 participando. '' Returns: Type Description (telegram.InlineKeyboardMarkup,str) : Devuelve el reply_markup y la cadena de texto del mensaje. Source code in modulos\\telegram_tools.py 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 def lista_propuestas_seleccionadas ( demandante : str , eventos_ya_propuestos : list [ str ] = [], ofertante : str = \"\" ): \"\"\" Funci\u00f3n para listar las propuestas que el demandante env\u00eda a un ofertante de un intercambio Args: demandante: Correo del demandante eventos_ya_propuestos: Lista de id de eventos ya agregados en la propuesta. Se utiliza para evitar que el demandante pueda incluir un evento varias veces ofertante: Correo del ofertante para que no se puedan proponer eventos que el ofertante ya est\u00e9 participando. Returns: (telegram.InlineKeyboardMarkup,str) : Devuelve el reply_markup y la cadena de texto del mensaje. \"\"\" global cal_principal reply_markup : telegram . InlineKeyboardMarkup = [] texto : str = \"\" try : if eventos_ya_propuestos != []: texto = \"Propuestas las actividades siguientes \\n \" for id in eventos_ya_propuestos : evento = cal_principal . get_evento ( uid_evento = id ) texto += \" \\n {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ()) else : texto = \"Escoja una o m\u00e1s actividades y pulse Enviar\" lista_eventos = cal_principal . get_eventos ( demandante ) fila_botones = [] columna_botones = [] for evento in lista_eventos : if evento . get_uid () not in eventos_ya_propuestos : boton = telegram . InlineKeyboardButton ( text = \" {} - {} \" . format ( evento . get_summary (), evento . get_fecha_str () ), callback_data = \" {} ; {} \" . format ( \"hacer_propuesta\" , evento . get_uid ()) ) columna_botones . append ( list ([ boton ])) columna_botones . append ([ telegram . InlineKeyboardButton ( text = \"Deshacer las selecciones\" , callback_data = \" {} \" . format ( \"deshacer_propuesta\" ) ), telegram . InlineKeyboardButton ( text = \"Enviar las propuestas\" , callback_data = \" {} \" . format ( \"enviar_propuesta\" ) ) ]) reply_markup = telegram . InlineKeyboardMarkup ( columna_botones ) return reply_markup , texto except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e ))","title":"lista_propuestas_seleccionadas()"},{"location":"telegram_tools/#modulos.telegram_tools.marcar_cambio","text":"Funci\u00f3n para marcar la cesi\u00f3n de ofertante a un demandante Parameters: Name Type Description Default uid str | int UID del evento a marcar required demandante str Correo del demandante required ofertante str Correo del ofertante required Returns: Type Description bool True si lo marc\u00f3 con \u00e9xito, False si no Source code in modulos\\telegram_tools.py 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 def marcar_cambio ( uid : str | int , demandante : str , ofertante : str ): \"\"\" Funci\u00f3n para marcar la cesi\u00f3n de ofertante a un demandante Args: uid: UID del evento a marcar demandante: Correo del demandante ofertante: Correo del ofertante Returns: (bool): True si lo marc\u00f3 con \u00e9xito, False si no \"\"\" evento = cal_propuestas . get_evento ( uid ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () if isinstance ( evento , gestor_calendario . Evento ): ofertantes = evento . get_asistentes ( rol = 'OPT-PARTICIPANT' ) lista = list ( ofertantes . keys ()) ofertante_marcado = random . choice ( lista ) cursor . execute ( f \"\"\"UPDATE oferta_demanda SET demandante=\" { demandante } \" WHERE ofertante=\" { ofertante_marcado } \" and uid_evento=\" { uid } \";\"\"\" ) relacion . commit () cursor . close () relacion . close ()","title":"marcar_cambio()"},{"location":"telegram_tools/#modulos.telegram_tools.mostrar_datos_evento","text":"Funci\u00f3n para presentar datos de un evento en un chat de telegram. Env\u00eda una mensaje al chat indicado por id_chat con los datos del evento y los botones contextuales si procede. Parameters: Name Type Description Default modo str Modo en el que se presenta el evento: \u00b7\u00b7\u00b7resumen: Solo muestra nombre, puestos libres y fecha del evento \u00b7\u00b7\u00b7completo: Muestra nombre, fecha e integrantes del evento required evento gestor_calendario . Evento Objeto gestor_calendario.Evento que contiene los datos del evento a representar. required id_chat str Identificador del chat donde se van a mostrar los datos del evento required accion str Accion que se pone en el mensaje de retorno cuando se pulsa un bot\u00f3n de un mensaje con un evento. Si la acci\u00f3n es nada, no se pone un bot\u00f3n 'nada' Returns: Type Description str Devuelve la id del mensaje enviado Source code in modulos\\telegram_tools.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def mostrar_datos_evento ( modo : str , evento : gestor_calendario . Evento , id_chat : str , accion : str = \"nada\" , demandante : str = \"\" , ofertante : str = \"\" ) -> str : \"\"\" Funci\u00f3n para presentar datos de un evento en un chat de telegram. Env\u00eda una mensaje al chat indicado por id_chat con los datos del evento y los botones contextuales si procede. Args: modo: Modo en el que se presenta el evento: \u00b7\u00b7\u00b7resumen: Solo muestra nombre, puestos libres y fecha del evento \u00b7\u00b7\u00b7completo: Muestra nombre, fecha e integrantes del evento evento: Objeto gestor_calendario.Evento que contiene los datos del evento a representar. id_chat: Identificador del chat donde se van a mostrar los datos del evento accion: Accion que se pone en el mensaje de retorno cuando se pulsa un bot\u00f3n de un mensaje con un evento. Si la acci\u00f3n es nada, no se pone un bot\u00f3n Returns: Devuelve la id del mensaje enviado \"\"\" reply_markup = [] mensaje : telegram . Message = None texto = \"\" if accion == \"cancelar_cesion\" : texto = \"Cancelar propuesta de cambio\" if accion == \"cancelar_intercambio\" : texto = \"Cancelar propuesta de intercambio\" if accion == \"tomar\" : texto = \"Demandar esta actividad cedida\" if accion == \"ceder\" : texto = \"Ofrecer esta actividad\" if accion == \"aprobar_denegar\" : texto = \"Aprobar este cambio de actividad\" if accion == \"permutar\" : texto = \"Demandar esta actividad para intercambio\" if accion == \"intercambiar\" : texto = \"Ofrecer esta actividad para intercambio\" if modo == \"resumen\" : boton_callback = [[ telegram . InlineKeyboardButton ( text = \" {} \" . format ( texto ), callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()) ) ]] cadena = \"<b> {} </b> \\n Fecha: {} \\n \" . format ( evento . get_summary (), evento . get_fecha_str ()) if accion != \"nada\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) else : cadena = \"Actividad en la que se ha inscrito a la espera de aprobaci\u00f3n \\n\\n \" + cadena mensaje = bot . send_message ( chat_id = id_chat , text = cadena , parse_mode = \"HTML\" ) if modo == \"completo\" : cadena = \"<b> {} </b> \\n \" . format ( evento . get_summary ()) if evento . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) if ofertante == \"\" : if evento . get_cuenta_ofertantes () > 0 : cadena += \" \\n <i>Ofertantes de la actividad</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"OPT-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) else : cadena += \" \\n <i>Ofertante de la actividad</i>: \\n \" nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , ofertante ) if demandante == \"\" : if evento . get_cuenta_demandantes () > 0 : cadena += \" \\n <i>Demandantes de la actividad</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"NON-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) else : cadena += \" \\n <i>Demandante de la actividad</i>: \\n \" nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , demandante ) cadena += \" \\n en fecha: <b> {} </b>\" . format ( evento . get_fecha_str ()) boton_callback = [[ telegram . InlineKeyboardButton ( text = texto , callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()))]] if accion != \"nada\" and accion != \"aprobar_denegar_cesion\" and accion != \"ceder_intercambiar\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) elif accion == \"aprobar_denegar_cesion\" : boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Aprobar este cambio de actividad\" , callback_data = \" {} ; {} \" . format ( \"aprobar_cesion\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Denegar este cambio de actividad\" , callback_data = \" {} ; {} \" . format ( \"denegar_cesion\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) elif accion == \"ceder_intercambiar\" : boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Ceder\" , callback_data = \" {} ; {} \" . format ( \"ceder\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Intercambiar\" , callback_data = \" {} ; {} \" . format ( \"intercambiar\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) if accion == \"nada\" : mensaje = bot . send_message ( chat_id = id_chat , text = cadena , parse_mode = \"HTML\" ) return mensaje . message_id","title":"mostrar_datos_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.mostrar_propuesta_cesion","text":"Esta funci\u00f3n se utiliza para mostrar la propuesta a los administradores para que puedan aprobarla o denegarla. Parameters: Name Type Description Default evento gestor_calendario . Evento Evento que se va a mostrar required demandante str required Returns: Type Description bool Verdadero si lo hace con \u00e9xito, falso si no Source code in modulos\\telegram_tools.py 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 def mostrar_propuesta_cesion ( evento : gestor_calendario . Evento , demandante : str , ofertante : str = \"\" ): \"\"\" Esta funci\u00f3n se utiliza para mostrar la propuesta a los administradores para que puedan aprobarla o denegarla. Args: evento: Evento que se va a mostrar demandante: Returns: (bool): Verdadero si lo hace con \u00e9xito, falso si no \"\"\" try : relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cadena = \"<b> {} </b> - <i> {} </i> \\n \" . format ( evento . get_summary (), evento . get_fecha_str ()) if evento . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) if ofertante == \"\" : cursor . execute ( f \"\"\"SELECT ofertante FROM oferta_demanda where uid_evento=\" { evento . get_uid () } \" and demandante=\" { demandante } \";\"\"\" ) lectura = cursor . fetchall () if lectura != []: ofertante = lectura [ 0 ][ 0 ] nombre_ofertante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )) nombre_demandante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante )) cadena += \" \\n <b> {} </b> (<i> {} </i>) cede a \\n <b> {} </b> (<i> {} </i>)\" . format ( nombre_ofertante , ofertante , nombre_demandante , demandante ) boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Aprobar este cambio de actividad\" , callback_data = \" {} ; {} \" . format ( \"aprobar_cesion\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Denegar este cambio de actividad\" , callback_data = \" {} ; {} \" . format ( \"denegar_cesion\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = canalid_admin , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) cursor . execute ( f \"\"\"UPDATE oferta_demanda SET id_mensaje_canal_admins=\" { mensaje . message_id } \" where uid_evento=\" { evento . get_uid () } \" and demandante=\" { demandante } \" and ofertante=\" { ofertante } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () return True except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () return False","title":"mostrar_propuesta_cesion()"},{"location":"telegram_tools/#modulos.telegram_tools.mostrar_propuesta_intercambio","text":"Esta funci\u00f3n se utiliza para mostrar la propuesta de intercambio a los administradores para que puedan aprobarla o denegarla. Parameters: Name Type Description Default evento_ofertado gestor_calendario . Evento Evento ofertado por el ofertante required evento_propuesto gestor_calendario . Evento Evento propuesto por el demandante required ofertante str Correo del ofertante required demandante str Correo del demandante required Source code in modulos\\telegram_tools.py 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 def mostrar_propuesta_intercambio ( evento_ofertado : gestor_calendario . Evento , evento_propuesto : gestor_calendario . Evento , demandante : str , ofertante : str ): \"\"\" Esta funci\u00f3n se utiliza para mostrar la propuesta de intercambio a los administradores para que puedan aprobarla o denegarla. Args: evento_ofertado: Evento ofertado por el ofertante evento_propuesto: Evento propuesto por el demandante ofertante: Correo del ofertante demandante: Correo del demandante \"\"\" try : relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cadena = \"Evento ofertado: \\n <b> {} </b> - {} \\n \" . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str ()) if evento_ofertado . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento_ofertado . get_asistentes (): if evento_ofertado . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) nombre_ofertante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )) nombre_demandante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante )) cadena += \" \\n <b> {} </b> (<i> {} </i>) intercambia a \\n <b> {} </b> (<i> {} </i>) su participaci\u00f3n a cambio de \\n \" . format ( nombre_ofertante , ofertante , nombre_demandante , demandante ) cadena += \" \\n Evento propuesto: \\n <b> {} </b> - {} \\n \" . format ( evento_propuesto . get_summary (), evento_propuesto . get_fecha_str ()) if evento_propuesto . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento_propuesto . get_asistentes (): if evento_propuesto . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Aprobar este intercambio de actividades\" , callback_data = \" {} ; {} \" . format ( \"aprobar_intercambio\" , evento_ofertado . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Denegar este intercambio de actividades\" , callback_data = \" {} ; {} \" . format ( \"denegar_intercambio\" , evento_ofertado . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = canalid_admin , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) cursor . execute ( f \"\"\"UPDATE oferta_demanda set uid_evento_propuesta_intercambio=\" { evento_propuesto . get_uid () } \",id_mensaje_canal_admins=\" { str ( mensaje . message_id ) } \",accion=\"enviado\" WHERE demandante=\" { demandante } \" and ofertante=\" { ofertante } \" and accion=\"propuestas\" and uid_evento=\" { evento_ofertado . get_uid () } \" and id_mensaje_canal_publicaciones is null and uid_evento_propuesta_intercambio is null;\"\"\" ) relacion . commit () cursor . close () relacion . close () return True except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () return False","title":"mostrar_propuesta_intercambio()"},{"location":"telegram_tools/#modulos.telegram_tools.notificar_aprobar_cesion","text":"Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Parameters: Name Type Description Default borrados list [ str ] Usuarios que se borran del evento required asentados list [ str ] Usuarios que se agregan al evento required evento gestor_calendario . Evento Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 def notificar_aprobar_cesion ( borrados : list [ str ], asentados : list [ str ], evento : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Args: borrados: Usuarios que se borran del evento asentados: Usuarios que se agregan al evento evento: Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : for borrado in borrados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( borrado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido aprobado. Ha sido usted excluido de la actividad {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) for asentado in asentados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( asentado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido aprobado. Ha sido usted incluido en la actividad {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"notificar_aprobar_cesion()"},{"location":"telegram_tools/#modulos.telegram_tools.notificar_aprobar_propuesta_intercambio","text":"Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Parameters: Name Type Description Default ofertante str Usuarios que ofrecio el evento ofertado y acepto el propuesto required demandante str Usuarios que demando el evento ofertado y ofrecio el propuesto required evento_ofertado gestor_calendario . Evento Evento ofertado para intercambio. Necesario para obtener las fechas y el resumen required evento_propuesto gestor_calendario . Evento Evento propuesto para intercambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 def notificar_aprobar_propuesta_intercambio ( ofertante : str , demandante : str , evento_ofertado : gestor_calendario . Evento , evento_propuesto : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Args: ofertante: Usuarios que ofrecio el evento ofertado y acepto el propuesto demandante: Usuarios que demando el evento ofertado y ofrecio el propuesto evento_ofertado: Evento ofertado para intercambio. Necesario para obtener las fechas y el resumen evento_propuesto: Evento propuesto para intercambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El intercambio ha sido aprobado. \\n\\n Ha sido usted excluido de la actividad {} - {} \\n Ha sido incluido en la actividad {} - {} \" . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str (), evento_propuesto . get_summary (), evento_propuesto . get_fecha_str ())) id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El intercambio ha sido aprobado. \\n\\n Ha sido usted incluido en la actividad {} - {} \\n Ha sido excluido de la actividad {} - {} \" . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str (), evento_propuesto . get_summary (), evento_propuesto . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"notificar_aprobar_propuesta_intercambio()"},{"location":"telegram_tools/#modulos.telegram_tools.notificar_denegar_cesion","text":"Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Parameters: Name Type Description Default borrados list [ str ] Usuarios que se borran del evento required mantenidos list [ str ] Usuarios que se agregan al evento required evento gestor_calendario . Evento Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 def notificar_denegar_cesion ( borrados : list [ str ], mantenidos : list [ str ], evento : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Args: borrados: Usuarios que se borran del evento mantenidos: Usuarios que se agregan al evento evento: Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : for borrado in borrados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( borrado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Ha sido usted excluido de la actividad {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) for mantenido in mantenidos : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( mantenido )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Se mantiene usted en la actividad {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"notificar_denegar_cesion()"},{"location":"telegram_tools/#modulos.telegram_tools.notificar_denegar_propuesta_intercambio","text":"Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Parameters: Name Type Description Default ofertante str Usuarios que ofrecio el evento ofertado y acepto el propuesto required demandante str Usuarios que demando el evento ofertado y ofrecio el propuesto required evento_ofertado gestor_calendario . Evento Evento ofertado para intercambio. Necesario para obtener las fechas y el resumen required evento_propuesto gestor_calendario . Evento Evento propuesto para intercambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 def notificar_denegar_propuesta_intercambio ( ofertante : str , demandante : str , evento_ofertado : gestor_calendario . Evento , evento_propuesto : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Args: ofertante: Usuarios que ofrecio el evento ofertado y acepto el propuesto demandante: Usuarios que demando el evento ofertado y ofrecio el propuesto evento_ofertado: Evento ofertado para intercambio. Necesario para obtener las fechas y el resumen evento_propuesto: Evento propuesto para intercambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Mantiene usted su actividad {} - {} \" . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str ())) id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Mantiene usted su actividad {} - {} \" . format ( evento_propuesto . get_summary (), evento_propuesto . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"notificar_denegar_propuesta_intercambio()"},{"location":"telegram_tools/#modulos.telegram_tools.permutar_evento","text":"Funci\u00f3n para que un usuario pueda demandar un puesto en una guardia ofrecida y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a demandar un puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def permutar_evento ( uid : str , attendee : str ): \"\"\" Funci\u00f3n para que un usuario pueda demandar un puesto en una guardia ofrecida y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a demandar un puesto en una guardia Returns: (gestor_calendario.Evento|None):Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_propuestas . get_evento ( uid ) if isinstance ( evento , gestor_calendario . Evento ): evento_permutado = cal_propuestas . tomar_evento ( correo_usuario = attendee , uid_evento = uid , tipo = 'GROUP' ) if isinstance ( evento_permutado , gestor_calendario . Evento ): return evento_permutado else : return None else : return None except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"permutar_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.registro_paso1","text":"Primer paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Returns: Type Description int Devuelve estado actual del registro_paso1. Paso 1 completo Source code in modulos\\telegram_tools.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def registro_paso1 ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> int : \"\"\" Primer paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram Returns: Devuelve estado actual del registro_paso1. Paso 1 completo \"\"\" context . bot . send_message ( chat_id = update . message . chat_id , text = \"Introduce tu correo electronico para identificarte en la plataforma\" , reply_markup = telegram . ForceReply ()) return 1","title":"registro_paso1()"},{"location":"telegram_tools/#modulos.telegram_tools.registro_paso2","text":"Segundo paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Returns: Type Description int Devuelve estado actual del registro_paso1. O bien vuelta a empezar este paso o fin de avance en estados Source code in modulos\\telegram_tools.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def registro_paso2 ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> int : \"\"\" Segundo paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram Returns: Devuelve estado actual del registro_paso1. O bien vuelta a empezar este paso o fin de avance en estados \"\"\" logging . getLogger ( __name__ ) . debug ( update . message . text ) idusuario = False if ( \"@\" in update . message . text ): try : # Aqui pedimos a la API Rest la ID del usuario con su email respuesta = servicio_rest . GetIDPorEmail ( email = update . message . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta a GETIDPorEmail es:\" + str ( respuesta ) + \" tipo \" + str ( respuesta . isdigit ())) if respuesta . isdigit (): idusuario = respuesta elif respuesta == \"Email not found\" : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Su correo no ha sido encontrado en la plataforma. \\n Por favor, consulte al \" \"administrador de su sistema para comprobar que sus datos estan adecuadamente \" \"agregados\" ) return ConversationHandler . END if idusuario != False : logging . getLogger ( __name__ ) . debug ( idusuario ) logging . getLogger ( __name__ ) . debug ( update . effective_chat . id ) respuesta = servicio_rest . InsertaTelegramID ( idusuario = str ( idusuario ), chatid = update . effective_chat . id ) logging . getLogger ( __name__ ) . debug ( \"Valor de respuesta \" + str ( respuesta )) # Aqui har\u00edamos la consulta a REST para preguntar si existe ese correo electr\u00f3nico. Si es el caso, # enviar\u00edamos el id if respuesta == 'ID de telegram actualizado' : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha sido identificado en la plataforma, {} \" . format ( servicio_rest . GetNombrePorID ( idusuario ))) # Imprimimos su nombre else : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) botones ( update , context ) return ConversationHandler . END except Exception as e : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ConversationHandler . END else : update . message . reply_text ( \"La cadena no tiene un @. Intente de nuevo enviar su correo\" ) return 1","title":"registro_paso2()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_aprobar_cesion","text":"Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 @autenticar_retorno_admin def retorno_aprobar_cesion ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"aprobar_cesion\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento = cal_propuestas . get_evento ( uid_evento ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cursor . execute ( f \"\"\"SELECT ofertante,demandante FROM oferta_demanda where uid_evento=\" { evento . get_uid () } \" and id_mensaje_canal_admins=\" { update . callback_query . message . message_id } \" and accion=\"ceder\";\"\"\" ) lectura = cursor . fetchall () ofertante = lectura [ 0 ][ 0 ] demandante = lectura [ 0 ][ 1 ] evento . asienta_asistentes ( ofertante = ofertante , demandante = demandante ) if isinstance ( evento , gestor_calendario . Evento ): evento_modificado = cal_principal . get_evento ( uid_evento ) evento_modificado . set_asistente ( demandante , 'REQ-PARTICIPANT' ) evento_modificado . borrar_asistente ( ofertante ) if cal_principal . set_evento ( evento_modificado ): if evento . get_cuenta_ofertantes () == 0 : cal_propuestas . borrar_evento ( uid_evento ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) texto_final = \"La propuesta de cambio de la actividad <b> {} </b> con fecha <i> {} </i> ha sido aprobada. \\n Se ha excluido a {} \\n\\n Se ha incluido a {} \" \\ . format ( evento . get_summary (), evento . get_fecha_str (), servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )), servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante ))) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final , parse_mode = \"HTML\" ) notificar_aprobar_cesion ([ ofertante ], [ demandante ], evento_modificado ) servicio_rest . SetEvento ( evento_modificado . get_data ()) else : logging . getLogger ( __name__ ) . debug ( \"El evento {} se ha borrado del calendario de propuestas\" . format ( uid_evento )) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { ofertante } \" and demandante=\" { demandante } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e ))","title":"retorno_aprobar_cesion()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_aprobar_intercambio","text":"Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 @autenticar_retorno_admin def retorno_aprobar_intercambio ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento_ofertado = update . callback_query . data . split ( ';' ) evento_ofertado = cal_propuestas . get_evento ( uid_evento_ofertado ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cursor . execute ( f \"\"\"SELECT ofertante,demandante,uid_evento_propuesta_intercambio FROM oferta_demanda where uid_evento=\" { evento_ofertado . get_uid () } \" and id_mensaje_canal_admins=\" { update . callback_query . message . message_id } \" and accion=\"enviado\";\"\"\" ) lectura = cursor . fetchall () ofertante = lectura [ 0 ][ 0 ] demandante = lectura [ 0 ][ 1 ] uid_evento_propuesto = lectura [ 0 ][ 2 ] evento_ofertado . asienta_asistentes ( ofertante = ofertante , demandante = demandante ) evento_propuesto = cal_principal . get_evento ( uid_evento = uid_evento_propuesto ) if isinstance ( evento_ofertado , gestor_calendario . Evento ): evento_modificado = cal_principal . get_evento ( uid_evento_ofertado ) evento_modificado . set_asistente ( demandante , 'REQ-PARTICIPANT' ) evento_modificado . borrar_asistente ( ofertante ) evento_propuesto . set_asistente ( ofertante , 'REQ-PARTICIPANT' ) evento_propuesto . borrar_asistente ( demandante ) if cal_principal . set_evento ( evento_modificado ) and cal_principal . set_evento ( evento_propuesto ): if evento_ofertado . get_cuenta_ofertantes () == 0 : cal_propuestas . borrar_evento ( uid_evento_ofertado ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) texto_final = \"La propuesta de intercambio ha sido aprobada. \\n La actividad <b> {} </b> - <i> {} </i> ofertada por <b> {} </b> \\n \" \\ \"Intercambiada por la actividad <b> {} </b> - <i> {} </i> propuesta por <b> {} </b>\" \\ . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str (), servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )), evento_propuesto . get_summary (), evento_propuesto . get_fecha_str () , servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante ))) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final , parse_mode = \"HTML\" ) notificar_aprobar_propuesta_intercambio ( ofertante , demandante , evento_modificado , evento_propuesto ) servicio_rest . SetEvento ( evento_modificado . get_data ()) servicio_rest . SetEvento ( evento_propuesto . get_data ()) else : logging . getLogger ( __name__ ) . debug ( \"El evento {} se ha borrado del calendario de propuestas\" . format ( uid_evento_ofertado )) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento_ofertado } \" and ofertante=\" { ofertante } \" and demandante=\" { demandante } \" and uid_evento_propuesta_intercambio=\" { uid_evento_propuesto } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento_ofertado , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento_ofertado , update . callback_query , e ))","title":"retorno_aprobar_intercambio()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_cancelar_cesion","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 @autenticar_retorno def retorno_cancelar_cesion ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"cancelar_cesion\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cursor . execute ( f \"\"\"SELECT ofertante,demandante,id_mensaje_canal_publicaciones,id_mensaje_canal_admins,accion FROM oferta_demanda where uid_evento=\" { uid_evento } \";\"\"\" ) resultado = cursor . fetchall () if resultado != []: ofertante = resultado [ 0 ][ 0 ] demandante = resultado [ 0 ][ 1 ] id_mensaje_canal_publicaciones = resultado [ 0 ][ 2 ] id_mensaje_canal_admins = resultado [ 0 ][ 3 ] accion = resultado [ 0 ][ 4 ] if demandante is not None : if demandante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , demandante ) elif ofertante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , demandante ) cancelado = cancelar_propuesta_evento ( uid_evento , ofertante ) elif ofertante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , ofertante ) if isinstance ( cancelado , gestor_calendario . Evento ): if id_mensaje_canal_admins is not None : borrar_mensaje ( id_chat = canalid_admin , id_mensaje = id_mensaje_canal_admins ) if id_mensaje_canal_publicaciones is not None : borrar_mensaje ( id_chat = canalid , id_mensaje = id_mensaje_canal_publicaciones ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) if demandante is not None : if demandante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )), text = \"Se ha cancelado la propuesta de cesi\u00f3n. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) idmensaje = mostrar_datos_evento ( \"resumen\" , cancelado , canalid , \"tomar\" ) cursor . execute ( f \"\"\"UPDATE oferta_demanda set id_mensaje_canal_admins=null,demandante=null,id_mensaje_canal_publicaciones=\" { idmensaje } \" where uid_evento=\" { uid_evento } \" and ofertante=\" { ofertante } \" and accion=\"ceder\" and demandante=\" { correo } \";\"\"\" ) relacion . commit () elif ofertante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )), text = \"Se ha cancelado la propuesta de cesi\u00f3n. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )), text = \"Se ha cancelado la propuesta de cesi\u00f3n. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and demandante=\" { demandante } \"and accion=\"ceder\";\"\"\" ) relacion . commit () elif ofertante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )), text = \"Se ha cancelado la propuesta de cesi\u00f3n. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and accion=\"ceder\";\"\"\" ) relacion . commit () else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se pudo cancelar con \u00e9xito la propuesta de {} en fecha {} , dado que la oferta ya no existe\" . format ( cancelado . get_summary (), cancelado . get_fecha_str () ) ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_cancelar_cesion()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_cancelar_intercambio","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 @autenticar_retorno def retorno_cancelar_intercambio ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cursor . execute ( f \"\"\"SELECT ofertante,demandante,id_mensaje_canal_publicaciones,id_mensaje_canal_admins,accion FROM oferta_demanda where uid_evento=\" { uid_evento } \";\"\"\" ) resultado = cursor . fetchall () if resultado != []: ofertante = resultado [ 0 ][ 0 ] demandante = resultado [ 0 ][ 1 ] id_mensaje_canal_publicaciones = resultado [ 0 ][ 2 ] id_mensaje_canal_admins = resultado [ 0 ][ 3 ] accion = resultado [ 0 ][ 4 ] if accion == \"intercambiar\" or accion == \"enviado\" : if demandante is not None : if demandante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , demandante ) elif ofertante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , demandante ) cancelado = cancelar_propuesta_evento ( uid_evento , ofertante ) elif ofertante == correo : cancelado = cancelar_propuesta_evento ( uid_evento , ofertante ) if isinstance ( cancelado , gestor_calendario . Evento ): if id_mensaje_canal_admins is not None : borrar_mensaje ( id_chat = canalid_admin , id_mensaje = id_mensaje_canal_admins ) if id_mensaje_canal_publicaciones is not None : borrar_mensaje ( id_chat = canalid , id_mensaje = id_mensaje_canal_publicaciones ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) if demandante is not None : if demandante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )), text = \"Se ha cancelado la propuesta de intercambio. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) idmensaje = mostrar_datos_evento ( \"resumen\" , cancelado , canalid , \"permutar\" ) cursor . execute ( f \"\"\"UPDATE oferta_demanda set id_mensaje_canal_admins=null,demandante=null,uid_evento_propuesta_intercambio=null,id_mensaje_canal_publicaciones=\" { idmensaje } \",accion=\"intercambiar\" where uid_evento=\" { uid_evento } \" and ofertante=\" { ofertante } \" and demandante=\" { correo } \";\"\"\" ) relacion . commit () elif ofertante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( demandante )), text = \"Se ha cancelado la propuesta de intercambio. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )), text = \"Se ha cancelado la propuesta de intercambio. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and demandante=\" { demandante } \"and accion=\"intercambiar\";\"\"\" ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and demandante=\" { demandante } \"and accion=\"enviado\";\"\"\" ) relacion . commit () elif ofertante == correo : context . bot . send_message ( chat_id = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( ofertante )), text = \"Se ha cancelado la propuesta de intercambio. Ha sido usted excluido de la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str ()) ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and accion=\"intercambiar\";\"\"\" ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { correo } \" and accion=\"enviado\";\"\"\" ) relacion . commit () else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se pudo cancelar con \u00e9xito la propuesta {} en fecha {} , dado que la oferta ya no existe\" . format ( cancelado . get_summary (), cancelado . get_fecha_str () ) ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se puede cancelar esta propuesta actualmente hasta que se decidan las propuestas.\" . format ( cancelado . get_summary (), cancelado . get_fecha_str () ) ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_cancelar_intercambio()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_ceder","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es ceder, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 @autenticar_retorno def retorno_ceder ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es ceder, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"ceder\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cedido = ceder_evento ( uid_evento , correo ) if isinstance ( cedido , gestor_calendario . Evento ): borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha ofrecido para cesi\u00f3n con \u00e9xito el evento {} en fecha {} \" . format ( cedido . get_summary (), cedido . get_fecha_str ())) idmensaje = mostrar_datos_evento ( \"resumen\" , cedido , canalid , \"tomar\" ) cursor . execute ( f \"\"\"INSERT INTO oferta_demanda (ofertante,uid_evento,id_mensaje_canal_publicaciones,accion) VALUES ( \" { correo } \",\" { cedido . get_uid () } \",' { idmensaje } ',\"ceder\");\"\"\" ) relacion . commit () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_ceder()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_denegar_cesion","text":"Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 @autenticar_retorno_admin def retorno_denegar_cesion ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"denegar_cesion\" : evento = cal_propuestas . get_evento ( uid_evento ) evento_original = cal_principal . get_evento ( uid_evento ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cursor . execute ( f \"\"\"SELECT ofertante,demandante FROM oferta_demanda where uid_evento=\" { evento . get_uid () } \" and id_mensaje_canal_admins=\" { update . callback_query . message . message_id } \" and accion=\"ceder\";\"\"\" ) lectura = cursor . fetchall () ofertante = lectura [ 0 ][ 0 ] demandante = lectura [ 0 ][ 1 ] if ( evento . negar_cambio_asistentes ( ofertante = ofertante , demandante = demandante )): resultado = cal_propuestas . set_evento ( evento ) if resultado == True : texto_final = \"Se ha denegado con \u00e9xito la cesi\u00f3n de <b> {} </b> con fecha <i> {} </i>\" . format ( evento . get_summary (), evento . get_fecha_str ()) if evento . get_cuenta_ofertantes () == 0 : cal_propuestas . borrar_evento ( evento . get_uid ()) notificar_denegar_cesion ( borrados = list ([ demandante ]), mantenidos = list ([ ofertante ]), evento = evento ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final , parse_mode = \"HTML\" ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Ha habido un problema a la hora de inscribirse en el evento.\" \"P\u00f3ngase en contacto con un administrador\" ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento } \" and ofertante=\" { ofertante } \" and demandante=\" { demandante } \";\"\"\" ) relacion . commit () cursor . close () relacion . close () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_denegar_cesion()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_denegar_intercambio","text":"Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 @autenticar_retorno_admin def retorno_denegar_intercambio ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento_ofertado = update . callback_query . data . split ( ';' ) correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento_ofertado = cal_propuestas . get_evento ( uid_evento_ofertado ) relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () cursor . execute ( f \"\"\"SELECT ofertante,demandante,uid_evento_propuesta_intercambio FROM oferta_demanda where uid_evento=\" { evento_ofertado . get_uid () } \" and id_mensaje_canal_admins=\" { update . callback_query . message . message_id } \" and accion=\"enviado\";\"\"\" ) lectura = cursor . fetchall () ofertante = lectura [ 0 ][ 0 ] demandante = lectura [ 0 ][ 1 ] uid_evento_propuesto = lectura [ 0 ][ 2 ] evento_propuesto = cal_principal . get_evento ( uid_evento = uid_evento_propuesto ) nombre_ofertante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( ofertante )) nombre_demandante = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( demandante )) if ( evento_ofertado . negar_cambio_asistentes ( ofertante = ofertante , demandante = demandante )): resultado = cal_propuestas . set_evento ( evento_ofertado ) if resultado == True : texto_final = \"Se ha denegado con \u00e9xito el intercambio de \\n {} - {} ofertado por {} y \\n {} - {} propuesto por {} \" \\ . format ( evento_ofertado . get_summary (), evento_ofertado . get_fecha_str (), nombre_ofertante , evento_propuesto . get_summary (), evento_propuesto . get_fecha_str (), nombre_demandante ) if evento_ofertado . get_cuenta_ofertantes () == 0 : cal_propuestas . borrar_evento ( evento_ofertado . get_uid ()) notificar_denegar_propuesta_intercambio ( demandante = demandante , ofertante = ofertante , evento_propuesto = evento_propuesto , evento_ofertado = evento_ofertado ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) cursor . execute ( f \"\"\"DELETE FROM oferta_demanda where uid_evento=\" { uid_evento_ofertado } \" and ofertante=\" { ofertante } \" and demandante=\" { demandante } \" and uid_evento_propuesta_intercambio=\" { uid_evento_propuesto } \";\"\"\" ) relacion . commit () else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Ha habido un problema a la hora de inscribirse en el evento.\" \"P\u00f3ngase en contacto con un administrador\" ) cursor . close () relacion . close () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento_ofertado , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento_ofertado , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_denegar_intercambio()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_intercambiar","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es intercambiar, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 @autenticar_retorno def retorno_intercambiar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es intercambiar, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"intercambiar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) intercambiado = intercambiar_evento ( uid_evento , correo ) if isinstance ( intercambiado , gestor_calendario . Evento ): borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha ofrecido para intercambio con \u00e9xito el evento {} en fecha {} \" . format ( intercambiado . get_summary (), intercambiado . get_fecha_str ())) idmensaje = mostrar_datos_evento ( \"resumen\" , intercambiado , canalid , \"permutar\" ) cursor . execute ( f \"\"\"INSERT INTO oferta_demanda (ofertante,uid_evento,id_mensaje_canal_publicaciones,accion) VALUES ( \" { correo } \",\" { intercambiado . get_uid () } \",' { idmensaje } ',\"intercambiar\");\"\"\" ) relacion . commit () logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_intercambiar()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_permutar","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es permutar, el demandante recibe una encuesta con todas sus guardias futuras para proponer algunas de ellas como intercambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 @autenticar_retorno def retorno_permutar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es permutar, el demandante recibe una encuesta con todas sus guardias futuras para proponer algunas de ellas como intercambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid botones = [] relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"permutar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) permutado = permutar_evento ( uid_evento , correo ) cursor . execute ( f \"\"\"SELECT ofertante FROM oferta_demanda where accion=\"intercambiar\" and uid_evento=\" { uid_evento } \" and id_mensaje_canal_publicaciones=\" { update . callback_query . message . message_id } \" and demandante is null;\"\"\" ) datos = cursor . fetchall () ofertante = datos [ 0 ][ 0 ] if isinstance ( permutado , gestor_calendario . Evento ): cursor . execute ( f \"\"\"UPDATE oferta_demanda set demandante=\" { correo } \",id_mensaje_canal_publicaciones=null,accion=\"permutar\" where uid_evento=\" { uid_evento } \" and id_mensaje_canal_publicaciones=\" { update . callback_query . message . message_id } \" and accion=\"intercambiar\";\"\"\" ) relacion . commit () borrar_mensaje ( id_chat = canalid , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha demandado para intercambio el evento {} en fecha {} \" . format ( permutado . get_summary (), permutado . get_fecha_str ())) reply_markup , texto = lista_propuestas_seleccionadas ( correo ) mensaje = context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto , reply_markup = reply_markup ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_permutar()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_tomar_cesion","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es tomar, a\u00f1ade al usuario con el rol NON-PARTICIPANT al evento en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 @autenticar_retorno def retorno_tomar_cesion ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es tomar, a\u00f1ade al usuario con el rol NON-PARTICIPANT al evento en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid , canalid_admin relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () idmensaje = None try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"tomar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento = cal_principal . get_evento ( uid_evento ) if evento . get_comprobar_asistente ( correo ) != True : tomado = tomar_evento ( uid_evento , correo ) if isinstance ( tomado , gestor_calendario . Evento ): cursor . execute ( f \"\"\"SELECT ofertante FROM oferta_demanda where uid_evento=\" { tomado . get_uid () } \"and demandante IS NULL and accion=\"ceder\" and id_mensaje_canal_publicaciones=\" { update . callback_query . message . message_id } \";\"\"\" ) datos = cursor . fetchall () ofertante = datos [ 0 ][ 0 ] context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Evento en el que se ha inscrito\" ) mostrar_datos_evento ( \"completo\" , tomado , update . callback_query . from_user . id , \"nada\" , demandante = correo , ofertante = ofertante ) borrar_mensaje ( id_chat = canalid , id_mensaje = update . callback_query . message . message_id ) cursor . execute ( f \"\"\"UPDATE oferta_demanda set id_mensaje_canal_publicaciones=null,demandante=\" { correo } \" where uid_evento=\" { tomado . get_uid () } \"and demandante IS NULL and accion=\"ceder\" and ofertante=\" { ofertante } \";\"\"\" ) relacion . commit () mostrar_propuesta_cesion ( tomado , demandante = correo , ofertante = ofertante ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No puede demandar este evento porque ya est\u00e1 inscrito en \u00e9l o no hay puestos libres\" ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se puede usted inscribir en el evento porque ya est\u00e1 inscrito\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_tomar_cesion()"},{"location":"telegram_tools/#modulos.telegram_tools.start","text":"Funci\u00f3n de inicializaci\u00f3n del bot de Telegram Parameters: Name Type Description Default token_bot str Token de Telegram para autenticar el bot en el sistema de Telegram required cal_prim str Calendario principal que se utiliza en el servicio de guardias required cal_prop str Calendario de propuestas de cambio en el servicio de guardias required canal_id str Id para el canal de publicaci\u00f3n de guardias. required Source code in modulos\\telegram_tools.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def start ( token_bot : str , cal_prim : str , cal_prop : str , canal_id : str , canal_id_admin : str , path_sqlite : str ): \"\"\" Funci\u00f3n de inicializaci\u00f3n del bot de Telegram Args: token_bot: Token de Telegram para autenticar el bot en el sistema de Telegram cal_prim: Calendario principal que se utiliza en el servicio de guardias cal_prop: Calendario de propuestas de cambio en el servicio de guardias canal_id: Id para el canal de publicaci\u00f3n de guardias. \"\"\" global tokenbot , bot , cal_principal , cal_propuestas , canalid , canalid_admin , path_sqlite3 cal_principal = cal_prim cal_propuestas = cal_prop canalid = canal_id canalid_admin = canal_id_admin tokenbot = token_bot path_sqlite3 = path_sqlite bot = telegram . Bot ( token = token_bot )","title":"start()"},{"location":"telegram_tools/#modulos.telegram_tools.tomar_evento","text":"Funci\u00f3n para que un usuario pueda demandar un puesto en una guardia ofrecida y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a demandar un puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 def tomar_evento ( uid : str , attendee : str ): \"\"\" Funci\u00f3n para que un usuario pueda demandar un puesto en una guardia ofrecida y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a demandar un puesto en una guardia Returns: (gestor_calendario.Evento|None):Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_propuestas . get_evento ( uid ) if isinstance ( evento , gestor_calendario . Evento ): evento_tomado = cal_propuestas . tomar_evento ( correo_usuario = attendee , uid_evento = uid ) if isinstance ( evento_tomado , gestor_calendario . Evento ): return evento_tomado else : return None else : return None except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"tomar_evento()"}]}