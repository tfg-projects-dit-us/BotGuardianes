{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BotGuardianes Esta p\u00e1gina es documentaci\u00f3n del c\u00f3digo generada a partir de los comentarios del propio c\u00f3digo Para empezar, pulsa en las secciones del \u00edndice de la izquierda, para ver la documentaci\u00f3n asociada a cada m\u00f3dulo","title":"Principal"},{"location":"#botguardianes","text":"Esta p\u00e1gina es documentaci\u00f3n del c\u00f3digo generada a partir de los comentarios del propio c\u00f3digo Para empezar, pulsa en las secciones del \u00edndice de la izquierda, para ver la documentaci\u00f3n asociada a cada m\u00f3dulo","title":"BotGuardianes"},{"location":"config/","text":"config Clase para empaquetar la configuraci\u00f3n del bot de telegram Attributes: Name Type Description configfile dict Diccionario conteniendo la configuraci\u00f3n en un fichero yaml directorio str Ruta donde se encuentra el fichero de configuraci\u00f3n. Por defecto en ./data/config/config.yaml Source code in modulos\\config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class config : \"\"\" Clase para empaquetar la configuraci\u00f3n del bot de telegram Attributes: configfile (dict): Diccionario conteniendo la configuraci\u00f3n en un fichero yaml directorio (str): Ruta donde se encuentra el fichero de configuraci\u00f3n. Por defecto en ./data/config/config.yaml \"\"\" def __init__ ( self , directorio : str ): \"\"\" M\u00e9todo inicializador Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml \"\"\" self . configfile : dict = None self . directorio = directorio self . cargar_configuracion_lectura () self . crear_log () self . crear_db () def cargar_configuracion_lectura ( self , directorio : str | None = None ) -> dict : \"\"\" Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n Returns: Devuelve diccionario con la configuraci\u00f3n \"\"\" locale . setlocale ( locale . LC_ALL , 'es_ES.UTF-8' ) try : if ( directorio == None and self . directorio != None ): with open ( self . directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) elif ( directorio != None ): with open ( directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return self . configfile def crear_log ( self , config : dict | None = None ) -> None : \"\"\" Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Args: config: Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n \"\"\" if ( config != None ): self . configfile = config if not os . path . exists ( './data/log' ): os . makedirs ( './data/log' ) logging . getLogger ( __name__ ) . info ( \"Directorio log creado\" ) # Comprobamos si est\u00e1 el nivel if 'level' in self . configfile [ 'log' ]: nivel_log_num = getattr ( logging , self . configfile [ 'log' ][ 'level' ] . upper ()) if not isinstance ( nivel_log_num , int ): raise ValueError ( 'Nivel de log invalido: %s ' % self . configfile [ 'log' ][ 'level' ]) logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , encoding = 'utf-8' , format = '[ %(asctime)s ] - \u00b7 %(name)s \u00b7 - %(levelname)s - %(message)s ' , level = nivel_log_num ) #En caso de que no haya nivel definido, se pone por defecto warning else : logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , enconding = 'utf-8' , format = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' , level = logging . WARNING ) logging . getLogger ( __name__ ) . debug ( str ( self . configfile )) def crear_db ( self ): \"\"\" Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n \"\"\" connection = sqlite3 . connect ( self . configfile [ 'sqlite' ][ 'path' ]) c = connection . cursor () c . execute ( '''CREATE TABLE IF NOT EXISTS relaciones_id ( Idevento TEXT NOT NULL, Idmessage TEXT NOT NULL); ''' ) connection . commit () c . close () connection . close () __init__ ( directorio ) M\u00e9todo inicializador Parameters: Name Type Description Default directorio str Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml required Source code in modulos\\config.py 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , directorio : str ): \"\"\" M\u00e9todo inicializador Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml \"\"\" self . configfile : dict = None self . directorio = directorio self . cargar_configuracion_lectura () self . crear_log () self . crear_db () cargar_configuracion_lectura ( directorio = None ) Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Parameters: Name Type Description Default directorio str | None Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n None Returns: Type Description dict Devuelve diccionario con la configuraci\u00f3n Source code in modulos\\config.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def cargar_configuracion_lectura ( self , directorio : str | None = None ) -> dict : \"\"\" Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n Returns: Devuelve diccionario con la configuraci\u00f3n \"\"\" locale . setlocale ( locale . LC_ALL , 'es_ES.UTF-8' ) try : if ( directorio == None and self . directorio != None ): with open ( self . directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) elif ( directorio != None ): with open ( directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return self . configfile crear_db () Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n Source code in modulos\\config.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def crear_db ( self ): \"\"\" Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n \"\"\" connection = sqlite3 . connect ( self . configfile [ 'sqlite' ][ 'path' ]) c = connection . cursor () c . execute ( '''CREATE TABLE IF NOT EXISTS relaciones_id ( Idevento TEXT NOT NULL, Idmessage TEXT NOT NULL); ''' ) connection . commit () c . close () connection . close () crear_log ( config = None ) Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Parameters: Name Type Description Default config dict | None Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n None Source code in modulos\\config.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def crear_log ( self , config : dict | None = None ) -> None : \"\"\" Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Args: config: Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n \"\"\" if ( config != None ): self . configfile = config if not os . path . exists ( './data/log' ): os . makedirs ( './data/log' ) logging . getLogger ( __name__ ) . info ( \"Directorio log creado\" ) # Comprobamos si est\u00e1 el nivel if 'level' in self . configfile [ 'log' ]: nivel_log_num = getattr ( logging , self . configfile [ 'log' ][ 'level' ] . upper ()) if not isinstance ( nivel_log_num , int ): raise ValueError ( 'Nivel de log invalido: %s ' % self . configfile [ 'log' ][ 'level' ]) logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , encoding = 'utf-8' , format = '[ %(asctime)s ] - \u00b7 %(name)s \u00b7 - %(levelname)s - %(message)s ' , level = nivel_log_num ) #En caso de que no haya nivel definido, se pone por defecto warning else : logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , enconding = 'utf-8' , format = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' , level = logging . WARNING ) logging . getLogger ( __name__ ) . debug ( str ( self . configfile ))","title":"config"},{"location":"config/#modulos.config.config","text":"Clase para empaquetar la configuraci\u00f3n del bot de telegram Attributes: Name Type Description configfile dict Diccionario conteniendo la configuraci\u00f3n en un fichero yaml directorio str Ruta donde se encuentra el fichero de configuraci\u00f3n. Por defecto en ./data/config/config.yaml Source code in modulos\\config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class config : \"\"\" Clase para empaquetar la configuraci\u00f3n del bot de telegram Attributes: configfile (dict): Diccionario conteniendo la configuraci\u00f3n en un fichero yaml directorio (str): Ruta donde se encuentra el fichero de configuraci\u00f3n. Por defecto en ./data/config/config.yaml \"\"\" def __init__ ( self , directorio : str ): \"\"\" M\u00e9todo inicializador Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml \"\"\" self . configfile : dict = None self . directorio = directorio self . cargar_configuracion_lectura () self . crear_log () self . crear_db () def cargar_configuracion_lectura ( self , directorio : str | None = None ) -> dict : \"\"\" Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n Returns: Devuelve diccionario con la configuraci\u00f3n \"\"\" locale . setlocale ( locale . LC_ALL , 'es_ES.UTF-8' ) try : if ( directorio == None and self . directorio != None ): with open ( self . directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) elif ( directorio != None ): with open ( directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return self . configfile def crear_log ( self , config : dict | None = None ) -> None : \"\"\" Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Args: config: Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n \"\"\" if ( config != None ): self . configfile = config if not os . path . exists ( './data/log' ): os . makedirs ( './data/log' ) logging . getLogger ( __name__ ) . info ( \"Directorio log creado\" ) # Comprobamos si est\u00e1 el nivel if 'level' in self . configfile [ 'log' ]: nivel_log_num = getattr ( logging , self . configfile [ 'log' ][ 'level' ] . upper ()) if not isinstance ( nivel_log_num , int ): raise ValueError ( 'Nivel de log invalido: %s ' % self . configfile [ 'log' ][ 'level' ]) logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , encoding = 'utf-8' , format = '[ %(asctime)s ] - \u00b7 %(name)s \u00b7 - %(levelname)s - %(message)s ' , level = nivel_log_num ) #En caso de que no haya nivel definido, se pone por defecto warning else : logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , enconding = 'utf-8' , format = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' , level = logging . WARNING ) logging . getLogger ( __name__ ) . debug ( str ( self . configfile )) def crear_db ( self ): \"\"\" Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n \"\"\" connection = sqlite3 . connect ( self . configfile [ 'sqlite' ][ 'path' ]) c = connection . cursor () c . execute ( '''CREATE TABLE IF NOT EXISTS relaciones_id ( Idevento TEXT NOT NULL, Idmessage TEXT NOT NULL); ''' ) connection . commit () c . close () connection . close ()","title":"config"},{"location":"config/#modulos.config.config.__init__","text":"M\u00e9todo inicializador Parameters: Name Type Description Default directorio str Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml required Source code in modulos\\config.py 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , directorio : str ): \"\"\" M\u00e9todo inicializador Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n en yaml \"\"\" self . configfile : dict = None self . directorio = directorio self . cargar_configuracion_lectura () self . crear_log () self . crear_db ()","title":"__init__()"},{"location":"config/#modulos.config.config.cargar_configuracion_lectura","text":"Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Parameters: Name Type Description Default directorio str | None Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n None Returns: Type Description dict Devuelve diccionario con la configuraci\u00f3n Source code in modulos\\config.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def cargar_configuracion_lectura ( self , directorio : str | None = None ) -> dict : \"\"\" Carga la configuraci\u00f3n desde el archivo YAML de configuraci\u00f3n Configura el locale en es_ES y carga el fichero YAML de manera que crea un diccionario guardado en configfile Args: directorio: Directorio donde se encuentra el fichero de configuraci\u00f3n. Util para cargar otro fichero de configuraci\u00f3n en tiempo de ejecuci\u00f3n Returns: Devuelve diccionario con la configuraci\u00f3n \"\"\" locale . setlocale ( locale . LC_ALL , 'es_ES.UTF-8' ) try : if ( directorio == None and self . directorio != None ): with open ( self . directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) elif ( directorio != None ): with open ( directorio , 'r' ) as configuracion : self . configfile : dict = yaml . safe_load ( configuracion ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return self . configfile","title":"cargar_configuracion_lectura()"},{"location":"config/#modulos.config.config.crear_db","text":"Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n Source code in modulos\\config.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def crear_db ( self ): \"\"\" Crea base de datos sqlite en el path definido en el fichero de configuraci\u00f3n \"\"\" connection = sqlite3 . connect ( self . configfile [ 'sqlite' ][ 'path' ]) c = connection . cursor () c . execute ( '''CREATE TABLE IF NOT EXISTS relaciones_id ( Idevento TEXT NOT NULL, Idmessage TEXT NOT NULL); ''' ) connection . commit () c . close () connection . close ()","title":"crear_db()"},{"location":"config/#modulos.config.config.crear_log","text":"Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Parameters: Name Type Description Default config dict | None Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n None Source code in modulos\\config.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def crear_log ( self , config : dict | None = None ) -> None : \"\"\" Crea logs del servicio Este m\u00e9todo crea una carpeta de logs en el directorio data si no existiera, y crea a su vez el fichero de log con la fecha actual como parte del nombre Args: config: Diccionario con la configuraci\u00f3n, basado en la lectura del fichero yaml de configuraci\u00f3n \"\"\" if ( config != None ): self . configfile = config if not os . path . exists ( './data/log' ): os . makedirs ( './data/log' ) logging . getLogger ( __name__ ) . info ( \"Directorio log creado\" ) # Comprobamos si est\u00e1 el nivel if 'level' in self . configfile [ 'log' ]: nivel_log_num = getattr ( logging , self . configfile [ 'log' ][ 'level' ] . upper ()) if not isinstance ( nivel_log_num , int ): raise ValueError ( 'Nivel de log invalido: %s ' % self . configfile [ 'log' ][ 'level' ]) logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , encoding = 'utf-8' , format = '[ %(asctime)s ] - \u00b7 %(name)s \u00b7 - %(levelname)s - %(message)s ' , level = nivel_log_num ) #En caso de que no haya nivel definido, se pone por defecto warning else : logging . basicConfig ( filename = 'data/log/botguardianes-' + str ( datetime . datetime . today () . strftime ( '%Y.%m. %d ' )) + '.log' , filemode = 'a' , enconding = 'utf-8' , format = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' , level = logging . WARNING ) logging . getLogger ( __name__ ) . debug ( str ( self . configfile ))","title":"crear_log()"},{"location":"gestor_calendario/","text":"M\u00f3dulo para agregar manejo de calendarios y eventos mediante un cliente calDAV Contiene las clases: Evento : Clase para envolver un evento tipo caldav.Event Calendario : Clase para ofrecer m\u00e9todos de manejo de un calendario Contiene tambi\u00e9n los atributos de m\u00f3dulo: cliente : Variable a nivel de m\u00f3dulo con el objeto de manejo de cliente calDAV Y el m\u00e9todos de m\u00f3dulo: start(url_servicio,usuario,contrasena) : Inicio del cliente calDAV Calendario Clase para manejar un calendario con cliente calDAV Attributes: Name Type Description url str Nombre del calendario calendario caldav . Calendar Calendario conectado con cliente calDAV Source code in modulos\\gestor_calendario.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 class Calendario : \"\"\" Clase para manejar un calendario con cliente calDAV Attributes: url (str): Nombre del calendario calendario (caldav.Calendar): Calendario conectado con cliente calDAV \"\"\" def __init__ ( self , url : str = None ): \"\"\" Constructor de Calendario Args: url (str): La nombre del calendario que cargaremos \"\"\" self . url = url self . calendario = None self . cargar_calendario ( self . url ) def cargar_calendario ( self , nombre : str ): \"\"\" Inicializaci\u00f3n del calendario mediante cliente calDAV Args: nombre: nombre del calendario perteneciente al usuario de calDAV \"\"\" global cliente self . calendario = cliente . principal () . calendar ( cal_id = nombre ) @staticmethod def get_fecha_inicio_mes () -> datetime . datetime : \"\"\" Funci\u00f3n para calcular fecha inicio mes Returns: Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'month' ) . datetime # Funci\u00f3n para calcular el timestamp del \u00faltimo d\u00eda del mes @staticmethod def get_fecha_fin_mes () -> datetime . datetime : \"\"\" Funci\u00f3n para calcular fecha fin mes Returns: Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . ceil ( 'month' ) . datetime @staticmethod def ordenar_eventos ( lista_eventos : list [ Evento ]) -> list [ Evento ] | None : \"\"\" Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Args: lista_eventos: Lista de eventos a ordenar por fecha Returns: Lista ordenada de eventos \"\"\" lista_ordenada : list [ Evento ] = lista_eventos try : lista_ordenada = sorted ( lista_eventos , key = lambda x : x . get_fecha_str ()) except BaseException as exception : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , exception )) return None finally : return lista_ordenada def get_eventos ( self , attendee : str | None = None , rol : str = \"\" , completos : bool = False ) -> list [ Evento ]: \"\"\" Obtiene los eventos de un calendario en el periodo del mes actual. Args: attendee: Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. rol: Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante Returns: Lista de Evento \"\"\" lista_eventos = [] lista_eventos_aux = [] no_pedido = False sitios_libres = 0 sin_sitio = False try : eventosmes = self . calendario . date_search ( start = self . get_fecha_inicio_mes (), end = self . get_fecha_fin_mes (), expand = True ) for x in eventosmes : lista_eventos_aux . append ( Evento ( x )) for e in lista_eventos_aux : fecha = e . get_fecha_datetime () if self . get_fecha_fin_mes () > datetime . datetime ( fecha . year , fecha . month , fecha . day , 0 , 0 , 0 , 0 , pytz . timezone ( 'Europe/Madrid' )) > self . get_fecha_inicio_mes (): logging . getLogger ( __name__ ) . debug ( \"Evento en el periodo actual \" + str ( e )) if ( completos == True ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos para aprobar o denegar\" ) if e . get_cuenta_demandantes () == e . get_cuenta_ofertantes () and e . get_sitios_libres () == 0 : lista_eventos . append ( e ) elif ( attendee == None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos libres\" ) if e . get_sitios_libres () > 0 : lista_eventos . append ( e ) elif ( attendee != None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos de una persona\" ) if e . get_comprobar_asistente ( attendee , rol = rol ): lista_eventos . append ( e ) logging . getLogger ( __name__ ) . debug ( \"Lista de eventos en get_eventos:\" + str ( lista_eventos )) lista_ordenada = self . ordenar_eventos ( lista_eventos ) return lista_ordenada except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) print ( \"Error cargando eventos: \" + str ( e )) return None def get_evento ( self , uid_evento : str ) -> Evento | None : \"\"\" Obtiene un evento a partir de la uid del evento Args: uid_evento: identificador \u00fanico del evento Returns: Evento con uid=uid_evento o None en caso de no encontrarse \"\"\" try : return Evento ( self . calendario . event_by_uid ( uid = uid_evento )) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def asentar_cambios ( self , uid_evento : str ) -> tuple [ list [ str ], list [ str ], Evento ]: \"\"\" Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Args: uid_evento: Identificador \u00fanico del evento Returns: Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento \"\"\" try : evento = self . get_evento ( uid_evento ) ( borrados , asentados ) = evento . asienta_asistentes () return ( borrados , asentados , evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ([],[], None ) def set_evento ( self , evento : Evento ) -> bool : \"\"\" Guarda un evento en el calendario Args: evento: (gestor_calendario.Evento) Evento a guardar Returns: Verdadero si pudo hacerlo, falso si no \"\"\" try : evento_encontrado = self . calendario . event_by_uid ( uid = evento . get_uid ()) if isinstance ( evento_encontrado , caldav . Event ): evento_encontrado . data = evento . Event . data self . calendario . save_event ( evento_encontrado . data ) return True except caldav . lib . error . NotFoundError as e : logging . getLogger ( __name__ ) . debug ( \"Evento {} no existente en calendario. Funci\u00f3n ejecutada {} \" . format ( evento . get_uid (), sys . _getframe ( 1 ) . f_code . co_name )) logging . getLogger ( __name__ ) . debug ( \"Evento a introducir {} en calendario {} con data {} \" . format ( str ( evento ), str ( self . calendario . canonical_url ), str ( evento . Event . data ))) self . calendario . save_event ( evento . Event . data ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def ceder_evento ( self , correo_usuario : str , uid_evento : str , evento : Evento = None ) -> Evento | None : \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT y guarda el evento en el calendario Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: Evento: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ): evento_buscado . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" ) evento_cedido = self . set_evento ( evento_buscado ) if evento_cedido == True : return evento_buscado if isinstance ( evento , Evento ) and not isinstance ( evento_buscado , Evento ) : if evento . get_comprobar_asistente ( correo_usuario ): evento . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" ) evento_cedido = self . set_evento ( evento ) if evento_cedido == True : return self . get_evento ( uid_evento = uid_evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def cancelar_evento ( self , correo_usuario : str , uid_evento : str , evento : Evento = None ) -> Evento | None : \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: Evento: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" evento_cancelado = False try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): rol_asistente = evento_buscado . get_rol_asistente ( asistente = correo_usuario ) if rol_asistente == \"OPT-PARTICIPANT\" : ofertantes = evento_buscado . get_cuenta_ofertantes () demandantes = evento_buscado . get_cuenta_demandantes () asistentes = evento_buscado . get_cuenta_asistentes () if ofertantes > demandantes : evento_buscado . set_asistente ( correo_usuario , rol = \"REQ-PARTICIPANT\" ) evento_cancelado = self . set_evento ( evento_buscado ) if ofertantes <= demandantes : pass \"\"\"Se env\u00eda un mensaje al usuario indicando que no puede realizar esta acci\u00f3n\"\"\" ofertantes = evento_buscado . get_cuenta_ofertantes () if ofertantes == 0 : evento_buscado . Event . delete () evento_cancelado = True if rol_asistente == \"NON-PARTICIPANT\" : evento_buscado . borrar_asistente ( correo_usuario ) evento_cancelado = self . set_evento ( evento_buscado ) if evento_cancelado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def borrar_evento ( self , uid_evento : str ) -> bool : \"\"\" Borra el evento del calendario con la uid correspondiente Args: uid_evento: uid del evento que se desea borrar Returns: Devuelve True si lo borr\u00f3, False si no \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): evento_buscado . Event . delete () return True else : return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def tomar_evento ( self , correo_usuario : str , uid_evento : str ) -> Evento | None : \"\"\" Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Args: correo_usuario: Correo del usuario que tomar\u00e1 la plaza libre del evento uid_evento: Identificador \u00fanico del evento Returns: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ) != True and evento_buscado . get_sitios_libres () > 0 : evento_buscado . set_asistente ( correo_usuario , rol = \"NON-PARTICIPANT\" ) evento_tomado = self . set_evento ( evento_buscado ) if evento_tomado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None __init__ ( url = None ) Constructor de Calendario Parameters: Name Type Description Default url str La nombre del calendario que cargaremos None Source code in modulos\\gestor_calendario.py 416 417 418 419 420 421 422 423 424 425 def __init__ ( self , url : str = None ): \"\"\" Constructor de Calendario Args: url (str): La nombre del calendario que cargaremos \"\"\" self . url = url self . calendario = None self . cargar_calendario ( self . url ) asentar_cambios ( uid_evento ) Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Parameters: Name Type Description Default uid_evento str Identificador \u00fanico del evento required Returns: Type Description tuple [ list [ str ], list [ str ], Evento ] Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento Source code in modulos\\gestor_calendario.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def asentar_cambios ( self , uid_evento : str ) -> tuple [ list [ str ], list [ str ], Evento ]: \"\"\" Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Args: uid_evento: Identificador \u00fanico del evento Returns: Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento \"\"\" try : evento = self . get_evento ( uid_evento ) ( borrados , asentados ) = evento . asienta_asistentes () return ( borrados , asentados , evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ([],[], None ) borrar_evento ( uid_evento ) Borra el evento del calendario con la uid correspondiente Parameters: Name Type Description Default uid_evento str uid del evento que se desea borrar required Returns: Type Description bool Devuelve True si lo borr\u00f3, False si no Source code in modulos\\gestor_calendario.py 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 def borrar_evento ( self , uid_evento : str ) -> bool : \"\"\" Borra el evento del calendario con la uid correspondiente Args: uid_evento: uid del evento que se desea borrar Returns: Devuelve True si lo borr\u00f3, False si no \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): evento_buscado . Event . delete () return True else : return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False cancelar_evento ( correo_usuario , uid_evento , evento = None ) Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default correo_usuario str Correo del usuario que se est\u00e1 tratando de cambiar el rol required uid_evento str UID del evento que se est\u00e1 buscando en el calendario required evento Evento Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento None Returns: Name Type Description Evento Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 def cancelar_evento ( self , correo_usuario : str , uid_evento : str , evento : Evento = None ) -> Evento | None : \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: Evento: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" evento_cancelado = False try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): rol_asistente = evento_buscado . get_rol_asistente ( asistente = correo_usuario ) if rol_asistente == \"OPT-PARTICIPANT\" : ofertantes = evento_buscado . get_cuenta_ofertantes () demandantes = evento_buscado . get_cuenta_demandantes () asistentes = evento_buscado . get_cuenta_asistentes () if ofertantes > demandantes : evento_buscado . set_asistente ( correo_usuario , rol = \"REQ-PARTICIPANT\" ) evento_cancelado = self . set_evento ( evento_buscado ) if ofertantes <= demandantes : pass \"\"\"Se env\u00eda un mensaje al usuario indicando que no puede realizar esta acci\u00f3n\"\"\" ofertantes = evento_buscado . get_cuenta_ofertantes () if ofertantes == 0 : evento_buscado . Event . delete () evento_cancelado = True if rol_asistente == \"NON-PARTICIPANT\" : evento_buscado . borrar_asistente ( correo_usuario ) evento_cancelado = self . set_evento ( evento_buscado ) if evento_cancelado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None cargar_calendario ( nombre ) Inicializaci\u00f3n del calendario mediante cliente calDAV Parameters: Name Type Description Default nombre str nombre del calendario perteneciente al usuario de calDAV required Source code in modulos\\gestor_calendario.py 427 428 429 430 431 432 433 434 435 436 def cargar_calendario ( self , nombre : str ): \"\"\" Inicializaci\u00f3n del calendario mediante cliente calDAV Args: nombre: nombre del calendario perteneciente al usuario de calDAV \"\"\" global cliente self . calendario = cliente . principal () . calendar ( cal_id = nombre ) ceder_evento ( correo_usuario , uid_evento , evento = None ) Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT y guarda el evento en el calendario Parameters: Name Type Description Default correo_usuario str Correo del usuario que se est\u00e1 tratando de cambiar el rol required uid_evento str UID del evento que se est\u00e1 buscando en el calendario required evento Evento Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento None Returns: Name Type Description Evento Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 def ceder_evento ( self , correo_usuario : str , uid_evento : str , evento : Evento = None ) -> Evento | None : \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT y guarda el evento en el calendario Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: Evento: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ): evento_buscado . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" ) evento_cedido = self . set_evento ( evento_buscado ) if evento_cedido == True : return evento_buscado if isinstance ( evento , Evento ) and not isinstance ( evento_buscado , Evento ) : if evento . get_comprobar_asistente ( correo_usuario ): evento . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" ) evento_cedido = self . set_evento ( evento ) if evento_cedido == True : return self . get_evento ( uid_evento = uid_evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None get_evento ( uid_evento ) Obtiene un evento a partir de la uid del evento Parameters: Name Type Description Default uid_evento str identificador \u00fanico del evento required Returns: Type Description Evento | None Evento con uid=uid_evento o None en caso de no encontrarse Source code in modulos\\gestor_calendario.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 def get_evento ( self , uid_evento : str ) -> Evento | None : \"\"\" Obtiene un evento a partir de la uid del evento Args: uid_evento: identificador \u00fanico del evento Returns: Evento con uid=uid_evento o None en caso de no encontrarse \"\"\" try : return Evento ( self . calendario . event_by_uid ( uid = uid_evento )) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None get_eventos ( attendee = None , rol = '' , completos = False ) Obtiene los eventos de un calendario en el periodo del mes actual. Parameters: Name Type Description Default attendee str | None Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. None rol str Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante '' Returns: Type Description list [ Evento ] Lista de Evento Source code in modulos\\gestor_calendario.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 def get_eventos ( self , attendee : str | None = None , rol : str = \"\" , completos : bool = False ) -> list [ Evento ]: \"\"\" Obtiene los eventos de un calendario en el periodo del mes actual. Args: attendee: Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. rol: Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante Returns: Lista de Evento \"\"\" lista_eventos = [] lista_eventos_aux = [] no_pedido = False sitios_libres = 0 sin_sitio = False try : eventosmes = self . calendario . date_search ( start = self . get_fecha_inicio_mes (), end = self . get_fecha_fin_mes (), expand = True ) for x in eventosmes : lista_eventos_aux . append ( Evento ( x )) for e in lista_eventos_aux : fecha = e . get_fecha_datetime () if self . get_fecha_fin_mes () > datetime . datetime ( fecha . year , fecha . month , fecha . day , 0 , 0 , 0 , 0 , pytz . timezone ( 'Europe/Madrid' )) > self . get_fecha_inicio_mes (): logging . getLogger ( __name__ ) . debug ( \"Evento en el periodo actual \" + str ( e )) if ( completos == True ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos para aprobar o denegar\" ) if e . get_cuenta_demandantes () == e . get_cuenta_ofertantes () and e . get_sitios_libres () == 0 : lista_eventos . append ( e ) elif ( attendee == None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos libres\" ) if e . get_sitios_libres () > 0 : lista_eventos . append ( e ) elif ( attendee != None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos de una persona\" ) if e . get_comprobar_asistente ( attendee , rol = rol ): lista_eventos . append ( e ) logging . getLogger ( __name__ ) . debug ( \"Lista de eventos en get_eventos:\" + str ( lista_eventos )) lista_ordenada = self . ordenar_eventos ( lista_eventos ) return lista_ordenada except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) print ( \"Error cargando eventos: \" + str ( e )) return None get_fecha_fin_mes () staticmethod Funci\u00f3n para calcular fecha fin mes Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 449 450 451 452 453 454 455 456 457 @staticmethod def get_fecha_fin_mes () -> datetime . datetime : \"\"\" Funci\u00f3n para calcular fecha fin mes Returns: Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . ceil ( 'month' ) . datetime get_fecha_inicio_mes () staticmethod Funci\u00f3n para calcular fecha inicio mes Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 438 439 440 441 442 443 444 445 446 @staticmethod def get_fecha_inicio_mes () -> datetime . datetime : \"\"\" Funci\u00f3n para calcular fecha inicio mes Returns: Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'month' ) . datetime ordenar_eventos ( lista_eventos ) staticmethod Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Parameters: Name Type Description Default lista_eventos list [ Evento ] Lista de eventos a ordenar por fecha required Returns: Type Description list [ Evento ] | None Lista ordenada de eventos Source code in modulos\\gestor_calendario.py 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 @staticmethod def ordenar_eventos ( lista_eventos : list [ Evento ]) -> list [ Evento ] | None : \"\"\" Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Args: lista_eventos: Lista de eventos a ordenar por fecha Returns: Lista ordenada de eventos \"\"\" lista_ordenada : list [ Evento ] = lista_eventos try : lista_ordenada = sorted ( lista_eventos , key = lambda x : x . get_fecha_str ()) except BaseException as exception : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , exception )) return None finally : return lista_ordenada set_evento ( evento ) Guarda un evento en el calendario Parameters: Name Type Description Default evento Evento (gestor_calendario.Evento) Evento a guardar required Returns: Type Description bool Verdadero si pudo hacerlo, falso si no Source code in modulos\\gestor_calendario.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def set_evento ( self , evento : Evento ) -> bool : \"\"\" Guarda un evento en el calendario Args: evento: (gestor_calendario.Evento) Evento a guardar Returns: Verdadero si pudo hacerlo, falso si no \"\"\" try : evento_encontrado = self . calendario . event_by_uid ( uid = evento . get_uid ()) if isinstance ( evento_encontrado , caldav . Event ): evento_encontrado . data = evento . Event . data self . calendario . save_event ( evento_encontrado . data ) return True except caldav . lib . error . NotFoundError as e : logging . getLogger ( __name__ ) . debug ( \"Evento {} no existente en calendario. Funci\u00f3n ejecutada {} \" . format ( evento . get_uid (), sys . _getframe ( 1 ) . f_code . co_name )) logging . getLogger ( __name__ ) . debug ( \"Evento a introducir {} en calendario {} con data {} \" . format ( str ( evento ), str ( self . calendario . canonical_url ), str ( evento . Event . data ))) self . calendario . save_event ( evento . Event . data ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False tomar_evento ( correo_usuario , uid_evento ) Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Parameters: Name Type Description Default correo_usuario str Correo del usuario que tomar\u00e1 la plaza libre del evento required uid_evento str Identificador \u00fanico del evento required Returns: Type Description Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 def tomar_evento ( self , correo_usuario : str , uid_evento : str ) -> Evento | None : \"\"\" Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Args: correo_usuario: Correo del usuario que tomar\u00e1 la plaza libre del evento uid_evento: Identificador \u00fanico del evento Returns: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ) != True and evento_buscado . get_sitios_libres () > 0 : evento_buscado . set_asistente ( correo_usuario , rol = \"NON-PARTICIPANT\" ) evento_tomado = self . set_evento ( evento_buscado ) if evento_tomado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None Evento Clase que envuelve a un objeto de clase caldav.Event Genera m\u00e9todos que permitan operar con este objeto con m\u00e1s facilidad En el objeto caldav.Event Attendee es un diccionario de diccionarios. La clave es el correo del asistente, y da como resultado un diccionario que contiene rol y tipo de asistente. Los envuelve en listas, pero con esta clase vamos a convertirlo en un diccionario de diccionarios. Los roles del asistente son: REQ-PARTICIPANT: Significa asistente obligatorio al calendario OPT-PARTICIPANT: Empleado que pretende ceder este turno NON-PARTICIPANT: Empleado que quiere tomar este turno Los tipos del asistente son: INDIVIDUAL: Se usa para indicar cesiones. GROUP: Se usa para indicar intercambio. RESOURCE: Sin uso. ROOM: Sin uso. Ejemplos: { correo1: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE}, correo2: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE} } Attributes: Name Type Description Event caldav . Event Evento tipo caldav.Event asistentes dict [ dict ] Diccionario de asistentes Source code in modulos\\gestor_calendario.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 class Evento : \"\"\" Clase que envuelve a un objeto de clase caldav.Event Genera m\u00e9todos que permitan operar con este objeto con m\u00e1s facilidad En el objeto caldav.Event Attendee es un diccionario de diccionarios. La clave es el correo del asistente, y da como resultado un diccionario que contiene rol y tipo de asistente. Los envuelve en listas, pero con esta clase vamos a convertirlo en un diccionario de diccionarios. ``` Los roles del asistente son: REQ-PARTICIPANT: Significa asistente obligatorio al calendario OPT-PARTICIPANT: Empleado que pretende ceder este turno NON-PARTICIPANT: Empleado que quiere tomar este turno Los tipos del asistente son: INDIVIDUAL: Se usa para indicar cesiones. GROUP: Se usa para indicar intercambio. RESOURCE: Sin uso. ROOM: Sin uso. Ejemplos: { correo1: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE}, correo2: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE} } ``` Attributes: Event (caldav.Event): Evento tipo caldav.Event asistentes (dict[dict]): Diccionario de asistentes \"\"\" def __init__ ( self , evento : caldav . Event ): \"\"\" Constructor de Evento. Crea atributos: - Event: caldav.Event - asistentes: diccionario de asistentes {correo1,correo2,...} Args: evento: Evento tipo caldav.Event \"\"\" self . Event = evento self . asistentes = {} self . get_asistentes () def get_summary ( self ) -> str : \"\"\" Obtiene nombre de evento o summary Returns: Cadena con nombre del evento \"\"\" return str ( self . Event . vobject_instance . vevent . summary . value ) def get_uid ( self ) -> str : \"\"\" Obtiene uid del evento Returns: Uid del evento \"\"\" return str ( self . Event . vobject_instance . vevent . uid . value ) def get_asistentes ( self , rol : str = \"\" ) -> dict [ dict ]: \"\"\" Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Args: rol: El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT Returns: Devuelve un diccionario de diccionarios con clave principal el correo del usuario. \"\"\" if self . asistentes == {}: if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): for asistente in self . Event . vobject_instance . vevent . contents [ 'attendee' ]: if 'ROLE' in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) elif 'ROLE' in asistente . params . keys () and 'CUTYPE' not in asistente . params . keys (): if asistente . params [ 'ROLE' ] == [ 'null' ]: self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) else : self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : 'INDIVIDUAL' }}) elif 'ROLE' not in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) else : self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) if rol != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == rol : diccionario_aux . update ( self . asistentes [ asistente ]) cuenta_aux += 1 return diccionario_aux else : return self . asistentes def set_asistente ( self , correo_asistente : str , rol : str = \"\" , tipo : str = 'INDIVIDUAL' ) -> int : \"\"\" Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Args: correo_asistente: Correo del asistente que estamos queriendo actualizar rol: Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba tipo: Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. Returns: int: 0 si es correcto, -1 si sucede una Excepci\u00f3n \"\"\" try : asistente = self . asistentes [ correo_asistente ] except KeyError as k : self . asistentes [ correo_asistente ] = {} except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 finally : if rol != \"\" : self . asistentes [ correo_asistente ][ 'rol' ] = rol self . asistentes [ correo_asistente ][ 'tipo' ] = tipo if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == correo_asistente : self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'ROLE' : [ asistente [ 'rol' ]]}) self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'CUTYPE' : [ asistente [ 'tipo' ]]}) existente = True if not existente : try : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 else : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) return 0 def borrar_asistente ( self , asistente : str ) -> bool : \"\"\" Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Args: asistente: correo del asistente a borrar Returns: True si lo borra con \u00e9xito, False si no \"\"\" result = False try : del self . asistentes [ asistente ] existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == asistente : del self . Event . vobject_instance . vevent . attendee_list [ i ] existente = True result = True except KeyError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} . El correo del asistente no est\u00e1 incluido en el evento\" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def asienta_asistentes ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados \"\"\" lista_asentados = [] para_borrar = [] lista_borrados = [] try : for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : self . set_asistente ( asistente , rol = 'REQ-PARTICIPANT' ) lista_asentados . append ( asistente ) if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : para_borrar . append ( asistente ) for asistente in para_borrar : self . borrar_asistente ( asistente ) lista_borrados . append ( asistente ) return ( lista_borrados , lista_asentados ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def get_rol_asistente ( self , asistente : str ) -> str : \"\"\" Devuelve el rol del asistente que se pasa por par\u00e1metro Args: asistente: Correo del asistente Returns: rol del asistente en cadena \"\"\" return self . asistentes [ asistente ][ 'rol' ] def get_cuenta_asistentes ( self ) -> int : \"\"\" Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: Cantidad de asistentes requeridos a un evento. \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"REQ-PARTICIPANT\" : cuenta += 1 return cuenta def get_cuenta_ofertantes ( self ) -> int : \"\"\" Obtiene cuenta de ofertantes de un evento Returns: Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"OPT-PARTICIPANT\" : cuenta += 1 return cuenta def get_cuenta_demandantes ( self ) -> int : \"\"\" Obtiene cantidad de demandantes de un evento Returns: Obtiene cantidad de asistentes con el rol NON-PARTICIPANT \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"NON-PARTICIPANT\" : cuenta += 1 return cuenta def get_fecha_str ( self ) -> str : \"\"\" Obtiene la fecha de inicio del evento en formato cadena Returns: str: Fecha en formato [dia-mes-a\u00f1o horas-minutos] \"\"\" return str ( self . Event . vobject_instance . vevent . dtstart . value . strftime ( ' %d -%m-%Y %H:%M' )) def get_fecha_datetime ( self ) -> datetime . datetime : \"\"\" Obtiene la fecha de inicio del evento en formato datetime Returns: Fecha de inicio del evento \"\"\" return self . Event . vobject_instance . vevent . dtstart . value def get_sitios_libres ( self ) -> int : \"\"\" Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: Cantidad de puestos libres \"\"\" sitios_libres = 0 if self . asistentes != {}: for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'Optativo' en un evento. Significa que ya alguien pidi\u00f3 ceder el evento\" ) sitios_libres += 1 if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'No Participante' en un evento. Significa que ya alguien pidi\u00f3 obtener el evento que alguien cedi\u00f3\" ) sitios_libres -= 1 return sitios_libres def get_comprobar_asistente ( self , asistente : str , rol : str = \"\" ) -> bool : \"\"\" Comprueba si un asistente est\u00e1 en un evento Args: asistente: Correo del asistente que se comprueba rol: Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento Returns: True si est\u00e1 ( con el rol en concreto si es especificado), False si no \"\"\" resultado = False for attendee in self . asistentes : if ( asistente == attendee ): logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido Atendee {} \" . format ( str ( asistente ))) if rol == \"\" : resultado = True elif self . asistentes [ asistente ][ 'rol' ] == rol : resultado = True return resultado __init__ ( evento ) Constructor de Evento. Crea atributos Event: caldav.Event asistentes: diccionario de asistentes {correo1,correo2,...} Parameters: Name Type Description Default evento caldav . Event Evento tipo caldav.Event required Source code in modulos\\gestor_calendario.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def __init__ ( self , evento : caldav . Event ): \"\"\" Constructor de Evento. Crea atributos: - Event: caldav.Event - asistentes: diccionario de asistentes {correo1,correo2,...} Args: evento: Evento tipo caldav.Event \"\"\" self . Event = evento self . asistentes = {} self . get_asistentes () asienta_asistentes () Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: Type Description tuple [ list [ str ], list [ str ]] Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados Source code in modulos\\gestor_calendario.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def asienta_asistentes ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados \"\"\" lista_asentados = [] para_borrar = [] lista_borrados = [] try : for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : self . set_asistente ( asistente , rol = 'REQ-PARTICIPANT' ) lista_asentados . append ( asistente ) if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : para_borrar . append ( asistente ) for asistente in para_borrar : self . borrar_asistente ( asistente ) lista_borrados . append ( asistente ) return ( lista_borrados , lista_asentados ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False borrar_asistente ( asistente ) Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Parameters: Name Type Description Default asistente str correo del asistente a borrar required Returns: Type Description bool True si lo borra con \u00e9xito, False si no Source code in modulos\\gestor_calendario.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def borrar_asistente ( self , asistente : str ) -> bool : \"\"\" Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Args: asistente: correo del asistente a borrar Returns: True si lo borra con \u00e9xito, False si no \"\"\" result = False try : del self . asistentes [ asistente ] existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == asistente : del self . Event . vobject_instance . vevent . attendee_list [ i ] existente = True result = True except KeyError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} . El correo del asistente no est\u00e1 incluido en el evento\" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False get_asistentes ( rol = '' ) Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Parameters: Name Type Description Default rol str El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT '' Returns: Type Description dict [ dict ] Devuelve un diccionario de diccionarios con clave principal el correo del usuario. Source code in modulos\\gestor_calendario.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def get_asistentes ( self , rol : str = \"\" ) -> dict [ dict ]: \"\"\" Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Args: rol: El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT Returns: Devuelve un diccionario de diccionarios con clave principal el correo del usuario. \"\"\" if self . asistentes == {}: if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): for asistente in self . Event . vobject_instance . vevent . contents [ 'attendee' ]: if 'ROLE' in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) elif 'ROLE' in asistente . params . keys () and 'CUTYPE' not in asistente . params . keys (): if asistente . params [ 'ROLE' ] == [ 'null' ]: self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) else : self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : 'INDIVIDUAL' }}) elif 'ROLE' not in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) else : self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) if rol != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == rol : diccionario_aux . update ( self . asistentes [ asistente ]) cuenta_aux += 1 return diccionario_aux else : return self . asistentes get_comprobar_asistente ( asistente , rol = '' ) Comprueba si un asistente est\u00e1 en un evento Parameters: Name Type Description Default asistente str Correo del asistente que se comprueba required rol str Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento '' Returns: Type Description bool True si est\u00e1 ( con el rol en concreto si es especificado), False si no Source code in modulos\\gestor_calendario.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def get_comprobar_asistente ( self , asistente : str , rol : str = \"\" ) -> bool : \"\"\" Comprueba si un asistente est\u00e1 en un evento Args: asistente: Correo del asistente que se comprueba rol: Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento Returns: True si est\u00e1 ( con el rol en concreto si es especificado), False si no \"\"\" resultado = False for attendee in self . asistentes : if ( asistente == attendee ): logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido Atendee {} \" . format ( str ( asistente ))) if rol == \"\" : resultado = True elif self . asistentes [ asistente ][ 'rol' ] == rol : resultado = True return resultado get_cuenta_asistentes () Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: Type Description int Cantidad de asistentes requeridos a un evento. Source code in modulos\\gestor_calendario.py 299 300 301 302 303 304 305 306 307 308 309 310 311 def get_cuenta_asistentes ( self ) -> int : \"\"\" Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: Cantidad de asistentes requeridos a un evento. \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"REQ-PARTICIPANT\" : cuenta += 1 return cuenta get_cuenta_demandantes () Obtiene cantidad de demandantes de un evento Returns: Type Description int Obtiene cantidad de asistentes con el rol NON-PARTICIPANT Source code in modulos\\gestor_calendario.py 326 327 328 329 330 331 332 333 334 335 336 337 338 def get_cuenta_demandantes ( self ) -> int : \"\"\" Obtiene cantidad de demandantes de un evento Returns: Obtiene cantidad de asistentes con el rol NON-PARTICIPANT \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"NON-PARTICIPANT\" : cuenta += 1 return cuenta get_cuenta_ofertantes () Obtiene cuenta de ofertantes de un evento Returns: Type Description int Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento Source code in modulos\\gestor_calendario.py 312 313 314 315 316 317 318 319 320 321 322 323 324 def get_cuenta_ofertantes ( self ) -> int : \"\"\" Obtiene cuenta de ofertantes de un evento Returns: Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"OPT-PARTICIPANT\" : cuenta += 1 return cuenta get_fecha_datetime () Obtiene la fecha de inicio del evento en formato datetime Returns: Type Description datetime . datetime Fecha de inicio del evento Source code in modulos\\gestor_calendario.py 349 350 351 352 353 354 355 356 def get_fecha_datetime ( self ) -> datetime . datetime : \"\"\" Obtiene la fecha de inicio del evento en formato datetime Returns: Fecha de inicio del evento \"\"\" return self . Event . vobject_instance . vevent . dtstart . value get_fecha_str () Obtiene la fecha de inicio del evento en formato cadena Returns: Name Type Description str str Fecha en formato [dia-mes-a\u00f1o horas-minutos] Source code in modulos\\gestor_calendario.py 340 341 342 343 344 345 346 347 def get_fecha_str ( self ) -> str : \"\"\" Obtiene la fecha de inicio del evento en formato cadena Returns: str: Fecha en formato [dia-mes-a\u00f1o horas-minutos] \"\"\" return str ( self . Event . vobject_instance . vevent . dtstart . value . strftime ( ' %d -%m-%Y %H:%M' )) get_rol_asistente ( asistente ) Devuelve el rol del asistente que se pasa por par\u00e1metro Parameters: Name Type Description Default asistente str Correo del asistente required Returns: Type Description str rol del asistente en cadena Source code in modulos\\gestor_calendario.py 287 288 289 290 291 292 293 294 295 296 297 298 def get_rol_asistente ( self , asistente : str ) -> str : \"\"\" Devuelve el rol del asistente que se pasa por par\u00e1metro Args: asistente: Correo del asistente Returns: rol del asistente en cadena \"\"\" return self . asistentes [ asistente ][ 'rol' ] get_sitios_libres () Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: Type Description int Cantidad de puestos libres Source code in modulos\\gestor_calendario.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def get_sitios_libres ( self ) -> int : \"\"\" Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: Cantidad de puestos libres \"\"\" sitios_libres = 0 if self . asistentes != {}: for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'Optativo' en un evento. Significa que ya alguien pidi\u00f3 ceder el evento\" ) sitios_libres += 1 if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'No Participante' en un evento. Significa que ya alguien pidi\u00f3 obtener el evento que alguien cedi\u00f3\" ) sitios_libres -= 1 return sitios_libres get_summary () Obtiene nombre de evento o summary Returns: Type Description str Cadena con nombre del evento Source code in modulos\\gestor_calendario.py 110 111 112 113 114 115 116 117 def get_summary ( self ) -> str : \"\"\" Obtiene nombre de evento o summary Returns: Cadena con nombre del evento \"\"\" return str ( self . Event . vobject_instance . vevent . summary . value ) get_uid () Obtiene uid del evento Returns: Type Description str Uid del evento Source code in modulos\\gestor_calendario.py 119 120 121 122 123 124 125 126 def get_uid ( self ) -> str : \"\"\" Obtiene uid del evento Returns: Uid del evento \"\"\" return str ( self . Event . vobject_instance . vevent . uid . value ) set_asistente ( correo_asistente , rol = '' , tipo = 'INDIVIDUAL' ) Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Parameters: Name Type Description Default correo_asistente str Correo del asistente que estamos queriendo actualizar required rol str Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba '' tipo str Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. 'INDIVIDUAL' Returns: Name Type Description int int 0 si es correcto, -1 si sucede una Excepci\u00f3n Source code in modulos\\gestor_calendario.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def set_asistente ( self , correo_asistente : str , rol : str = \"\" , tipo : str = 'INDIVIDUAL' ) -> int : \"\"\" Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Args: correo_asistente: Correo del asistente que estamos queriendo actualizar rol: Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba tipo: Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. Returns: int: 0 si es correcto, -1 si sucede una Excepci\u00f3n \"\"\" try : asistente = self . asistentes [ correo_asistente ] except KeyError as k : self . asistentes [ correo_asistente ] = {} except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 finally : if rol != \"\" : self . asistentes [ correo_asistente ][ 'rol' ] = rol self . asistentes [ correo_asistente ][ 'tipo' ] = tipo if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == correo_asistente : self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'ROLE' : [ asistente [ 'rol' ]]}) self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'CUTYPE' : [ asistente [ 'tipo' ]]}) existente = True if not existente : try : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 else : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) return 0 start ( url_servicio , usuario = None , contrasena = None ) M\u00e9todo de m\u00f3dulo para cargar el cliente caldav en una variable de m\u00e9todo Parameters: Name Type Description Default url_servicio str url donde se encuentra el servidor caldav required usuario str usuario para acceder al servicio caldav None contrasena str contrase\u00f1a del servicio None Source code in modulos\\gestor_calendario.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def start ( url_servicio : str , usuario : str = None , contrasena : str = None ): \"\"\" M\u00e9todo de m\u00f3dulo para cargar el cliente caldav en una variable de m\u00e9todo Args: url_servicio: url donde se encuentra el servidor caldav usuario: usuario para acceder al servicio caldav contrasena: contrase\u00f1a del servicio \"\"\" global cliente try : cliente = caldav . DAVClient ( url = url_servicio , username = usuario , password = contrasena ) logging . getLogger ( __name__ ) . debug ( \"Iniciado url_servicio CALDAV\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e ))","title":"gestor_calendario"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario","text":"Clase para manejar un calendario con cliente calDAV Attributes: Name Type Description url str Nombre del calendario calendario caldav . Calendar Calendario conectado con cliente calDAV Source code in modulos\\gestor_calendario.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 class Calendario : \"\"\" Clase para manejar un calendario con cliente calDAV Attributes: url (str): Nombre del calendario calendario (caldav.Calendar): Calendario conectado con cliente calDAV \"\"\" def __init__ ( self , url : str = None ): \"\"\" Constructor de Calendario Args: url (str): La nombre del calendario que cargaremos \"\"\" self . url = url self . calendario = None self . cargar_calendario ( self . url ) def cargar_calendario ( self , nombre : str ): \"\"\" Inicializaci\u00f3n del calendario mediante cliente calDAV Args: nombre: nombre del calendario perteneciente al usuario de calDAV \"\"\" global cliente self . calendario = cliente . principal () . calendar ( cal_id = nombre ) @staticmethod def get_fecha_inicio_mes () -> datetime . datetime : \"\"\" Funci\u00f3n para calcular fecha inicio mes Returns: Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'month' ) . datetime # Funci\u00f3n para calcular el timestamp del \u00faltimo d\u00eda del mes @staticmethod def get_fecha_fin_mes () -> datetime . datetime : \"\"\" Funci\u00f3n para calcular fecha fin mes Returns: Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . ceil ( 'month' ) . datetime @staticmethod def ordenar_eventos ( lista_eventos : list [ Evento ]) -> list [ Evento ] | None : \"\"\" Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Args: lista_eventos: Lista de eventos a ordenar por fecha Returns: Lista ordenada de eventos \"\"\" lista_ordenada : list [ Evento ] = lista_eventos try : lista_ordenada = sorted ( lista_eventos , key = lambda x : x . get_fecha_str ()) except BaseException as exception : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , exception )) return None finally : return lista_ordenada def get_eventos ( self , attendee : str | None = None , rol : str = \"\" , completos : bool = False ) -> list [ Evento ]: \"\"\" Obtiene los eventos de un calendario en el periodo del mes actual. Args: attendee: Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. rol: Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante Returns: Lista de Evento \"\"\" lista_eventos = [] lista_eventos_aux = [] no_pedido = False sitios_libres = 0 sin_sitio = False try : eventosmes = self . calendario . date_search ( start = self . get_fecha_inicio_mes (), end = self . get_fecha_fin_mes (), expand = True ) for x in eventosmes : lista_eventos_aux . append ( Evento ( x )) for e in lista_eventos_aux : fecha = e . get_fecha_datetime () if self . get_fecha_fin_mes () > datetime . datetime ( fecha . year , fecha . month , fecha . day , 0 , 0 , 0 , 0 , pytz . timezone ( 'Europe/Madrid' )) > self . get_fecha_inicio_mes (): logging . getLogger ( __name__ ) . debug ( \"Evento en el periodo actual \" + str ( e )) if ( completos == True ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos para aprobar o denegar\" ) if e . get_cuenta_demandantes () == e . get_cuenta_ofertantes () and e . get_sitios_libres () == 0 : lista_eventos . append ( e ) elif ( attendee == None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos libres\" ) if e . get_sitios_libres () > 0 : lista_eventos . append ( e ) elif ( attendee != None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos de una persona\" ) if e . get_comprobar_asistente ( attendee , rol = rol ): lista_eventos . append ( e ) logging . getLogger ( __name__ ) . debug ( \"Lista de eventos en get_eventos:\" + str ( lista_eventos )) lista_ordenada = self . ordenar_eventos ( lista_eventos ) return lista_ordenada except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) print ( \"Error cargando eventos: \" + str ( e )) return None def get_evento ( self , uid_evento : str ) -> Evento | None : \"\"\" Obtiene un evento a partir de la uid del evento Args: uid_evento: identificador \u00fanico del evento Returns: Evento con uid=uid_evento o None en caso de no encontrarse \"\"\" try : return Evento ( self . calendario . event_by_uid ( uid = uid_evento )) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def asentar_cambios ( self , uid_evento : str ) -> tuple [ list [ str ], list [ str ], Evento ]: \"\"\" Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Args: uid_evento: Identificador \u00fanico del evento Returns: Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento \"\"\" try : evento = self . get_evento ( uid_evento ) ( borrados , asentados ) = evento . asienta_asistentes () return ( borrados , asentados , evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ([],[], None ) def set_evento ( self , evento : Evento ) -> bool : \"\"\" Guarda un evento en el calendario Args: evento: (gestor_calendario.Evento) Evento a guardar Returns: Verdadero si pudo hacerlo, falso si no \"\"\" try : evento_encontrado = self . calendario . event_by_uid ( uid = evento . get_uid ()) if isinstance ( evento_encontrado , caldav . Event ): evento_encontrado . data = evento . Event . data self . calendario . save_event ( evento_encontrado . data ) return True except caldav . lib . error . NotFoundError as e : logging . getLogger ( __name__ ) . debug ( \"Evento {} no existente en calendario. Funci\u00f3n ejecutada {} \" . format ( evento . get_uid (), sys . _getframe ( 1 ) . f_code . co_name )) logging . getLogger ( __name__ ) . debug ( \"Evento a introducir {} en calendario {} con data {} \" . format ( str ( evento ), str ( self . calendario . canonical_url ), str ( evento . Event . data ))) self . calendario . save_event ( evento . Event . data ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def ceder_evento ( self , correo_usuario : str , uid_evento : str , evento : Evento = None ) -> Evento | None : \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT y guarda el evento en el calendario Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: Evento: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ): evento_buscado . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" ) evento_cedido = self . set_evento ( evento_buscado ) if evento_cedido == True : return evento_buscado if isinstance ( evento , Evento ) and not isinstance ( evento_buscado , Evento ) : if evento . get_comprobar_asistente ( correo_usuario ): evento . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" ) evento_cedido = self . set_evento ( evento ) if evento_cedido == True : return self . get_evento ( uid_evento = uid_evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def cancelar_evento ( self , correo_usuario : str , uid_evento : str , evento : Evento = None ) -> Evento | None : \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: Evento: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" evento_cancelado = False try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): rol_asistente = evento_buscado . get_rol_asistente ( asistente = correo_usuario ) if rol_asistente == \"OPT-PARTICIPANT\" : ofertantes = evento_buscado . get_cuenta_ofertantes () demandantes = evento_buscado . get_cuenta_demandantes () asistentes = evento_buscado . get_cuenta_asistentes () if ofertantes > demandantes : evento_buscado . set_asistente ( correo_usuario , rol = \"REQ-PARTICIPANT\" ) evento_cancelado = self . set_evento ( evento_buscado ) if ofertantes <= demandantes : pass \"\"\"Se env\u00eda un mensaje al usuario indicando que no puede realizar esta acci\u00f3n\"\"\" ofertantes = evento_buscado . get_cuenta_ofertantes () if ofertantes == 0 : evento_buscado . Event . delete () evento_cancelado = True if rol_asistente == \"NON-PARTICIPANT\" : evento_buscado . borrar_asistente ( correo_usuario ) evento_cancelado = self . set_evento ( evento_buscado ) if evento_cancelado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None def borrar_evento ( self , uid_evento : str ) -> bool : \"\"\" Borra el evento del calendario con la uid correspondiente Args: uid_evento: uid del evento que se desea borrar Returns: Devuelve True si lo borr\u00f3, False si no \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): evento_buscado . Event . delete () return True else : return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def tomar_evento ( self , correo_usuario : str , uid_evento : str ) -> Evento | None : \"\"\" Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Args: correo_usuario: Correo del usuario que tomar\u00e1 la plaza libre del evento uid_evento: Identificador \u00fanico del evento Returns: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ) != True and evento_buscado . get_sitios_libres () > 0 : evento_buscado . set_asistente ( correo_usuario , rol = \"NON-PARTICIPANT\" ) evento_tomado = self . set_evento ( evento_buscado ) if evento_tomado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"Calendario"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.__init__","text":"Constructor de Calendario Parameters: Name Type Description Default url str La nombre del calendario que cargaremos None Source code in modulos\\gestor_calendario.py 416 417 418 419 420 421 422 423 424 425 def __init__ ( self , url : str = None ): \"\"\" Constructor de Calendario Args: url (str): La nombre del calendario que cargaremos \"\"\" self . url = url self . calendario = None self . cargar_calendario ( self . url )","title":"__init__()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.asentar_cambios","text":"Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Parameters: Name Type Description Default uid_evento str Identificador \u00fanico del evento required Returns: Type Description tuple [ list [ str ], list [ str ], Evento ] Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento Source code in modulos\\gestor_calendario.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def asentar_cambios ( self , uid_evento : str ) -> tuple [ list [ str ], list [ str ], Evento ]: \"\"\" Asienta los cambios de un evento. Para ello, borra los usuarios de OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT. Esta funci\u00f3n se utiliza desde el calendario de propuestas normalmente. Args: uid_evento: Identificador \u00fanico del evento Returns: Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados, y el evento \"\"\" try : evento = self . get_evento ( uid_evento ) ( borrados , asentados ) = evento . asienta_asistentes () return ( borrados , asentados , evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ([],[], None )","title":"asentar_cambios()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.borrar_evento","text":"Borra el evento del calendario con la uid correspondiente Parameters: Name Type Description Default uid_evento str uid del evento que se desea borrar required Returns: Type Description bool Devuelve True si lo borr\u00f3, False si no Source code in modulos\\gestor_calendario.py 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 def borrar_evento ( self , uid_evento : str ) -> bool : \"\"\" Borra el evento del calendario con la uid correspondiente Args: uid_evento: uid del evento que se desea borrar Returns: Devuelve True si lo borr\u00f3, False si no \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): evento_buscado . Event . delete () return True else : return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"borrar_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.cancelar_evento","text":"Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default correo_usuario str Correo del usuario que se est\u00e1 tratando de cambiar el rol required uid_evento str UID del evento que se est\u00e1 buscando en el calendario required evento Evento Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento None Returns: Name Type Description Evento Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 def cancelar_evento ( self , correo_usuario : str , uid_evento : str , evento : Evento = None ) -> Evento | None : \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Esta acci\u00f3n depende del usuario que la env\u00ede. Si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento. Si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el caso de que sea un OPT-PARTICIPANT, se evaluar\u00e1 si quedan sitios libres Si no queda ningun usuario en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: Evento: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" evento_cancelado = False try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): rol_asistente = evento_buscado . get_rol_asistente ( asistente = correo_usuario ) if rol_asistente == \"OPT-PARTICIPANT\" : ofertantes = evento_buscado . get_cuenta_ofertantes () demandantes = evento_buscado . get_cuenta_demandantes () asistentes = evento_buscado . get_cuenta_asistentes () if ofertantes > demandantes : evento_buscado . set_asistente ( correo_usuario , rol = \"REQ-PARTICIPANT\" ) evento_cancelado = self . set_evento ( evento_buscado ) if ofertantes <= demandantes : pass \"\"\"Se env\u00eda un mensaje al usuario indicando que no puede realizar esta acci\u00f3n\"\"\" ofertantes = evento_buscado . get_cuenta_ofertantes () if ofertantes == 0 : evento_buscado . Event . delete () evento_cancelado = True if rol_asistente == \"NON-PARTICIPANT\" : evento_buscado . borrar_asistente ( correo_usuario ) evento_cancelado = self . set_evento ( evento_buscado ) if evento_cancelado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"cancelar_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.cargar_calendario","text":"Inicializaci\u00f3n del calendario mediante cliente calDAV Parameters: Name Type Description Default nombre str nombre del calendario perteneciente al usuario de calDAV required Source code in modulos\\gestor_calendario.py 427 428 429 430 431 432 433 434 435 436 def cargar_calendario ( self , nombre : str ): \"\"\" Inicializaci\u00f3n del calendario mediante cliente calDAV Args: nombre: nombre del calendario perteneciente al usuario de calDAV \"\"\" global cliente self . calendario = cliente . principal () . calendar ( cal_id = nombre )","title":"cargar_calendario()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.ceder_evento","text":"Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT y guarda el evento en el calendario Parameters: Name Type Description Default correo_usuario str Correo del usuario que se est\u00e1 tratando de cambiar el rol required uid_evento str UID del evento que se est\u00e1 buscando en el calendario required evento Evento Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento None Returns: Name Type Description Evento Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 def ceder_evento ( self , correo_usuario : str , uid_evento : str , evento : Evento = None ) -> Evento | None : \"\"\" Busca un evento con la uid concretada en el calendario designado. Si no lo encuentra, usar\u00e1 el evento que se le pase por par\u00e1metros Cambia el rol al asistente a OPT-PARTICIPANT y guarda el evento en el calendario Args: correo_usuario: Correo del usuario que se est\u00e1 tratando de cambiar el rol uid_evento: UID del evento que se est\u00e1 buscando en el calendario evento: Evento que se pretende introducir en el calendario para casos en los que no se encuentra el evento Returns: Evento: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : logging . getLogger ( __name__ ) . debug ( \"Tipo de evento: \" + str ( type ( evento ))) evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ): evento_buscado . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" ) evento_cedido = self . set_evento ( evento_buscado ) if evento_cedido == True : return evento_buscado if isinstance ( evento , Evento ) and not isinstance ( evento_buscado , Evento ) : if evento . get_comprobar_asistente ( correo_usuario ): evento . set_asistente ( correo_usuario , rol = \"OPT-PARTICIPANT\" ) evento_cedido = self . set_evento ( evento ) if evento_cedido == True : return self . get_evento ( uid_evento = uid_evento ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"ceder_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_evento","text":"Obtiene un evento a partir de la uid del evento Parameters: Name Type Description Default uid_evento str identificador \u00fanico del evento required Returns: Type Description Evento | None Evento con uid=uid_evento o None en caso de no encontrarse Source code in modulos\\gestor_calendario.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 def get_evento ( self , uid_evento : str ) -> Evento | None : \"\"\" Obtiene un evento a partir de la uid del evento Args: uid_evento: identificador \u00fanico del evento Returns: Evento con uid=uid_evento o None en caso de no encontrarse \"\"\" try : return Evento ( self . calendario . event_by_uid ( uid = uid_evento )) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"get_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_eventos","text":"Obtiene los eventos de un calendario en el periodo del mes actual. Parameters: Name Type Description Default attendee str | None Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. None rol str Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante '' Returns: Type Description list [ Evento ] Lista de Evento Source code in modulos\\gestor_calendario.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 def get_eventos ( self , attendee : str | None = None , rol : str = \"\" , completos : bool = False ) -> list [ Evento ]: \"\"\" Obtiene los eventos de un calendario en el periodo del mes actual. Args: attendee: Asistente para quien estamos obteniendo lista de eventos. Si es None, obtenemos todos los eventos del periodo Si tiene un valor, obtenemos solo los eventos con este asistente suscrito. rol: Rol del asistente. Se utiliza para buscar eventos con cierto rol del participante Returns: Lista de Evento \"\"\" lista_eventos = [] lista_eventos_aux = [] no_pedido = False sitios_libres = 0 sin_sitio = False try : eventosmes = self . calendario . date_search ( start = self . get_fecha_inicio_mes (), end = self . get_fecha_fin_mes (), expand = True ) for x in eventosmes : lista_eventos_aux . append ( Evento ( x )) for e in lista_eventos_aux : fecha = e . get_fecha_datetime () if self . get_fecha_fin_mes () > datetime . datetime ( fecha . year , fecha . month , fecha . day , 0 , 0 , 0 , 0 , pytz . timezone ( 'Europe/Madrid' )) > self . get_fecha_inicio_mes (): logging . getLogger ( __name__ ) . debug ( \"Evento en el periodo actual \" + str ( e )) if ( completos == True ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos para aprobar o denegar\" ) if e . get_cuenta_demandantes () == e . get_cuenta_ofertantes () and e . get_sitios_libres () == 0 : lista_eventos . append ( e ) elif ( attendee == None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos libres\" ) if e . get_sitios_libres () > 0 : lista_eventos . append ( e ) elif ( attendee != None and completos == False ): logging . getLogger ( __name__ ) . info ( \"Se ha pedido lista de eventos de una persona\" ) if e . get_comprobar_asistente ( attendee , rol = rol ): lista_eventos . append ( e ) logging . getLogger ( __name__ ) . debug ( \"Lista de eventos en get_eventos:\" + str ( lista_eventos )) lista_ordenada = self . ordenar_eventos ( lista_eventos ) return lista_ordenada except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) print ( \"Error cargando eventos: \" + str ( e )) return None","title":"get_eventos()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_fecha_fin_mes","text":"Funci\u00f3n para calcular fecha fin mes Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 449 450 451 452 453 454 455 456 457 @staticmethod def get_fecha_fin_mes () -> datetime . datetime : \"\"\" Funci\u00f3n para calcular fecha fin mes Returns: Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . ceil ( 'month' ) . datetime","title":"get_fecha_fin_mes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.get_fecha_inicio_mes","text":"Funci\u00f3n para calcular fecha inicio mes Returns: Type Description datetime . datetime Fecha en formato datetime Source code in modulos\\gestor_calendario.py 438 439 440 441 442 443 444 445 446 @staticmethod def get_fecha_inicio_mes () -> datetime . datetime : \"\"\" Funci\u00f3n para calcular fecha inicio mes Returns: Fecha en formato datetime \"\"\" return arrow . utcnow () . to ( 'Europe/Madrid' ) . floor ( 'month' ) . datetime","title":"get_fecha_inicio_mes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.ordenar_eventos","text":"Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Parameters: Name Type Description Default lista_eventos list [ Evento ] Lista de eventos a ordenar por fecha required Returns: Type Description list [ Evento ] | None Lista ordenada de eventos Source code in modulos\\gestor_calendario.py 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 @staticmethod def ordenar_eventos ( lista_eventos : list [ Evento ]) -> list [ Evento ] | None : \"\"\" Ordena por fecha de evento de atr\u00e1s a delante la lista de eventos que se indica en la entrada Args: lista_eventos: Lista de eventos a ordenar por fecha Returns: Lista ordenada de eventos \"\"\" lista_ordenada : list [ Evento ] = lista_eventos try : lista_ordenada = sorted ( lista_eventos , key = lambda x : x . get_fecha_str ()) except BaseException as exception : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , exception )) return None finally : return lista_ordenada","title":"ordenar_eventos()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.set_evento","text":"Guarda un evento en el calendario Parameters: Name Type Description Default evento Evento (gestor_calendario.Evento) Evento a guardar required Returns: Type Description bool Verdadero si pudo hacerlo, falso si no Source code in modulos\\gestor_calendario.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def set_evento ( self , evento : Evento ) -> bool : \"\"\" Guarda un evento en el calendario Args: evento: (gestor_calendario.Evento) Evento a guardar Returns: Verdadero si pudo hacerlo, falso si no \"\"\" try : evento_encontrado = self . calendario . event_by_uid ( uid = evento . get_uid ()) if isinstance ( evento_encontrado , caldav . Event ): evento_encontrado . data = evento . Event . data self . calendario . save_event ( evento_encontrado . data ) return True except caldav . lib . error . NotFoundError as e : logging . getLogger ( __name__ ) . debug ( \"Evento {} no existente en calendario. Funci\u00f3n ejecutada {} \" . format ( evento . get_uid (), sys . _getframe ( 1 ) . f_code . co_name )) logging . getLogger ( __name__ ) . debug ( \"Evento a introducir {} en calendario {} con data {} \" . format ( str ( evento ), str ( self . calendario . canonical_url ), str ( evento . Event . data ))) self . calendario . save_event ( evento . Event . data ) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"set_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Calendario.tomar_evento","text":"Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Parameters: Name Type Description Default correo_usuario str Correo del usuario que tomar\u00e1 la plaza libre del evento required uid_evento str Identificador \u00fanico del evento required Returns: Type Description Evento | None Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. Source code in modulos\\gestor_calendario.py 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 def tomar_evento ( self , correo_usuario : str , uid_evento : str ) -> Evento | None : \"\"\" Busca un evento en el calendario y a\u00f1ade el correo_usuario con el rol NON-PARTICIPANT Args: correo_usuario: Correo del usuario que tomar\u00e1 la plaza libre del evento uid_evento: Identificador \u00fanico del evento Returns: Evento que se ha podido guardar en el calendario o None en caso de Excepci\u00f3n. \"\"\" try : evento_buscado = self . get_evento ( uid_evento = uid_evento ) if isinstance ( evento_buscado , Evento ): if evento_buscado . get_comprobar_asistente ( correo_usuario ) != True and evento_buscado . get_sitios_libres () > 0 : evento_buscado . set_asistente ( correo_usuario , rol = \"NON-PARTICIPANT\" ) evento_tomado = self . set_evento ( evento_buscado ) if evento_tomado == True : return evento_buscado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"tomar_evento()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento","text":"Clase que envuelve a un objeto de clase caldav.Event Genera m\u00e9todos que permitan operar con este objeto con m\u00e1s facilidad En el objeto caldav.Event Attendee es un diccionario de diccionarios. La clave es el correo del asistente, y da como resultado un diccionario que contiene rol y tipo de asistente. Los envuelve en listas, pero con esta clase vamos a convertirlo en un diccionario de diccionarios. Los roles del asistente son: REQ-PARTICIPANT: Significa asistente obligatorio al calendario OPT-PARTICIPANT: Empleado que pretende ceder este turno NON-PARTICIPANT: Empleado que quiere tomar este turno Los tipos del asistente son: INDIVIDUAL: Se usa para indicar cesiones. GROUP: Se usa para indicar intercambio. RESOURCE: Sin uso. ROOM: Sin uso. Ejemplos: { correo1: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE}, correo2: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE} } Attributes: Name Type Description Event caldav . Event Evento tipo caldav.Event asistentes dict [ dict ] Diccionario de asistentes Source code in modulos\\gestor_calendario.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 class Evento : \"\"\" Clase que envuelve a un objeto de clase caldav.Event Genera m\u00e9todos que permitan operar con este objeto con m\u00e1s facilidad En el objeto caldav.Event Attendee es un diccionario de diccionarios. La clave es el correo del asistente, y da como resultado un diccionario que contiene rol y tipo de asistente. Los envuelve en listas, pero con esta clase vamos a convertirlo en un diccionario de diccionarios. ``` Los roles del asistente son: REQ-PARTICIPANT: Significa asistente obligatorio al calendario OPT-PARTICIPANT: Empleado que pretende ceder este turno NON-PARTICIPANT: Empleado que quiere tomar este turno Los tipos del asistente son: INDIVIDUAL: Se usa para indicar cesiones. GROUP: Se usa para indicar intercambio. RESOURCE: Sin uso. ROOM: Sin uso. Ejemplos: { correo1: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE}, correo2: {rol: ROL_DEL_ASISTENTE,tipo: TIPO_DEL_ASISTENTE} } ``` Attributes: Event (caldav.Event): Evento tipo caldav.Event asistentes (dict[dict]): Diccionario de asistentes \"\"\" def __init__ ( self , evento : caldav . Event ): \"\"\" Constructor de Evento. Crea atributos: - Event: caldav.Event - asistentes: diccionario de asistentes {correo1,correo2,...} Args: evento: Evento tipo caldav.Event \"\"\" self . Event = evento self . asistentes = {} self . get_asistentes () def get_summary ( self ) -> str : \"\"\" Obtiene nombre de evento o summary Returns: Cadena con nombre del evento \"\"\" return str ( self . Event . vobject_instance . vevent . summary . value ) def get_uid ( self ) -> str : \"\"\" Obtiene uid del evento Returns: Uid del evento \"\"\" return str ( self . Event . vobject_instance . vevent . uid . value ) def get_asistentes ( self , rol : str = \"\" ) -> dict [ dict ]: \"\"\" Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Args: rol: El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT Returns: Devuelve un diccionario de diccionarios con clave principal el correo del usuario. \"\"\" if self . asistentes == {}: if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): for asistente in self . Event . vobject_instance . vevent . contents [ 'attendee' ]: if 'ROLE' in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) elif 'ROLE' in asistente . params . keys () and 'CUTYPE' not in asistente . params . keys (): if asistente . params [ 'ROLE' ] == [ 'null' ]: self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) else : self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : 'INDIVIDUAL' }}) elif 'ROLE' not in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) else : self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) if rol != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == rol : diccionario_aux . update ( self . asistentes [ asistente ]) cuenta_aux += 1 return diccionario_aux else : return self . asistentes def set_asistente ( self , correo_asistente : str , rol : str = \"\" , tipo : str = 'INDIVIDUAL' ) -> int : \"\"\" Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Args: correo_asistente: Correo del asistente que estamos queriendo actualizar rol: Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba tipo: Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. Returns: int: 0 si es correcto, -1 si sucede una Excepci\u00f3n \"\"\" try : asistente = self . asistentes [ correo_asistente ] except KeyError as k : self . asistentes [ correo_asistente ] = {} except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 finally : if rol != \"\" : self . asistentes [ correo_asistente ][ 'rol' ] = rol self . asistentes [ correo_asistente ][ 'tipo' ] = tipo if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == correo_asistente : self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'ROLE' : [ asistente [ 'rol' ]]}) self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'CUTYPE' : [ asistente [ 'tipo' ]]}) existente = True if not existente : try : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 else : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) return 0 def borrar_asistente ( self , asistente : str ) -> bool : \"\"\" Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Args: asistente: correo del asistente a borrar Returns: True si lo borra con \u00e9xito, False si no \"\"\" result = False try : del self . asistentes [ asistente ] existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == asistente : del self . Event . vobject_instance . vevent . attendee_list [ i ] existente = True result = True except KeyError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} . El correo del asistente no est\u00e1 incluido en el evento\" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def asienta_asistentes ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados \"\"\" lista_asentados = [] para_borrar = [] lista_borrados = [] try : for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : self . set_asistente ( asistente , rol = 'REQ-PARTICIPANT' ) lista_asentados . append ( asistente ) if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : para_borrar . append ( asistente ) for asistente in para_borrar : self . borrar_asistente ( asistente ) lista_borrados . append ( asistente ) return ( lista_borrados , lista_asentados ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False def get_rol_asistente ( self , asistente : str ) -> str : \"\"\" Devuelve el rol del asistente que se pasa por par\u00e1metro Args: asistente: Correo del asistente Returns: rol del asistente en cadena \"\"\" return self . asistentes [ asistente ][ 'rol' ] def get_cuenta_asistentes ( self ) -> int : \"\"\" Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: Cantidad de asistentes requeridos a un evento. \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"REQ-PARTICIPANT\" : cuenta += 1 return cuenta def get_cuenta_ofertantes ( self ) -> int : \"\"\" Obtiene cuenta de ofertantes de un evento Returns: Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"OPT-PARTICIPANT\" : cuenta += 1 return cuenta def get_cuenta_demandantes ( self ) -> int : \"\"\" Obtiene cantidad de demandantes de un evento Returns: Obtiene cantidad de asistentes con el rol NON-PARTICIPANT \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"NON-PARTICIPANT\" : cuenta += 1 return cuenta def get_fecha_str ( self ) -> str : \"\"\" Obtiene la fecha de inicio del evento en formato cadena Returns: str: Fecha en formato [dia-mes-a\u00f1o horas-minutos] \"\"\" return str ( self . Event . vobject_instance . vevent . dtstart . value . strftime ( ' %d -%m-%Y %H:%M' )) def get_fecha_datetime ( self ) -> datetime . datetime : \"\"\" Obtiene la fecha de inicio del evento en formato datetime Returns: Fecha de inicio del evento \"\"\" return self . Event . vobject_instance . vevent . dtstart . value def get_sitios_libres ( self ) -> int : \"\"\" Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: Cantidad de puestos libres \"\"\" sitios_libres = 0 if self . asistentes != {}: for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'Optativo' en un evento. Significa que ya alguien pidi\u00f3 ceder el evento\" ) sitios_libres += 1 if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'No Participante' en un evento. Significa que ya alguien pidi\u00f3 obtener el evento que alguien cedi\u00f3\" ) sitios_libres -= 1 return sitios_libres def get_comprobar_asistente ( self , asistente : str , rol : str = \"\" ) -> bool : \"\"\" Comprueba si un asistente est\u00e1 en un evento Args: asistente: Correo del asistente que se comprueba rol: Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento Returns: True si est\u00e1 ( con el rol en concreto si es especificado), False si no \"\"\" resultado = False for attendee in self . asistentes : if ( asistente == attendee ): logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido Atendee {} \" . format ( str ( asistente ))) if rol == \"\" : resultado = True elif self . asistentes [ asistente ][ 'rol' ] == rol : resultado = True return resultado","title":"Evento"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.__init__","text":"Constructor de Evento. Crea atributos Event: caldav.Event asistentes: diccionario de asistentes {correo1,correo2,...} Parameters: Name Type Description Default evento caldav . Event Evento tipo caldav.Event required Source code in modulos\\gestor_calendario.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def __init__ ( self , evento : caldav . Event ): \"\"\" Constructor de Evento. Crea atributos: - Event: caldav.Event - asistentes: diccionario de asistentes {correo1,correo2,...} Args: evento: Evento tipo caldav.Event \"\"\" self . Event = evento self . asistentes = {} self . get_asistentes ()","title":"__init__()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.asienta_asistentes","text":"Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: Type Description tuple [ list [ str ], list [ str ]] Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados Source code in modulos\\gestor_calendario.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def asienta_asistentes ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Asienta los cambios en un evento. Borra los usuarios con rol OPT-PARTICIPANT y convierte los NON-PARTICIPANT en REQ-PARTICIPANT Returns: Tupla que contiene dos listas, lista de correos de usuarios borrados y lista de correos de usuarios asentados \"\"\" lista_asentados = [] para_borrar = [] lista_borrados = [] try : for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : self . set_asistente ( asistente , rol = 'REQ-PARTICIPANT' ) lista_asentados . append ( asistente ) if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : para_borrar . append ( asistente ) for asistente in para_borrar : self . borrar_asistente ( asistente ) lista_borrados . append ( asistente ) return ( lista_borrados , lista_asentados ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"asienta_asistentes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.borrar_asistente","text":"Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Parameters: Name Type Description Default asistente str correo del asistente a borrar required Returns: Type Description bool True si lo borra con \u00e9xito, False si no Source code in modulos\\gestor_calendario.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def borrar_asistente ( self , asistente : str ) -> bool : \"\"\" Borra al asistente de un evento. Se usa cuando se cancela una propuesta por parte de un demandante o cuando se asienta un evento propuesto. Comprueba si el asistente est\u00e1 en el evento y lo borra del calendario. Args: asistente: correo del asistente a borrar Returns: True si lo borra con \u00e9xito, False si no \"\"\" result = False try : del self . asistentes [ asistente ] existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == asistente : del self . Event . vobject_instance . vevent . attendee_list [ i ] existente = True result = True except KeyError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} . El correo del asistente no est\u00e1 incluido en el evento\" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"borrar_asistente()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_asistentes","text":"Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Parameters: Name Type Description Default rol str El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT '' Returns: Type Description dict [ dict ] Devuelve un diccionario de diccionarios con clave principal el correo del usuario. Source code in modulos\\gestor_calendario.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def get_asistentes ( self , rol : str = \"\" ) -> dict [ dict ]: \"\"\" Obtiene un diccionario de diccionarios, con clave el correo del usuario La primera vez que se ejecuta, crea el diccionario completo. Si se introduce un rol, obtiene un diccionario con los roles de asistentes indicados en el par\u00e1metro rol Args: rol: El rol de asistente que se quiere obtener. Pueden ser OPT-PARTICIPANT, REQ-PARTICIPANT o NON-PARTICIPANT Returns: Devuelve un diccionario de diccionarios con clave principal el correo del usuario. \"\"\" if self . asistentes == {}: if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): for asistente in self . Event . vobject_instance . vevent . contents [ 'attendee' ]: if 'ROLE' in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) elif 'ROLE' in asistente . params . keys () and 'CUTYPE' not in asistente . params . keys (): if asistente . params [ 'ROLE' ] == [ 'null' ]: self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) else : self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : asistente . params [ 'ROLE' ][ 0 ], \"tipo\" : 'INDIVIDUAL' }}) elif 'ROLE' not in asistente . params . keys () and 'CUTYPE' in asistente . params . keys (): self . asistentes . update ({ str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : asistente . params [ 'CUTYPE' ][ 0 ]}}) else : self . asistentes . update ( { str ( urlparse ( asistente . value ) . path ): { \"rol\" : 'REQ-PARTICIPANT' , \"tipo\" : 'INDIVIDUAL' }}) if rol != \"\" : diccionario_aux = {} cuenta_aux = 0 for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == rol : diccionario_aux . update ( self . asistentes [ asistente ]) cuenta_aux += 1 return diccionario_aux else : return self . asistentes","title":"get_asistentes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_comprobar_asistente","text":"Comprueba si un asistente est\u00e1 en un evento Parameters: Name Type Description Default asistente str Correo del asistente que se comprueba required rol str Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento '' Returns: Type Description bool True si est\u00e1 ( con el rol en concreto si es especificado), False si no Source code in modulos\\gestor_calendario.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def get_comprobar_asistente ( self , asistente : str , rol : str = \"\" ) -> bool : \"\"\" Comprueba si un asistente est\u00e1 en un evento Args: asistente: Correo del asistente que se comprueba rol: Par\u00e1metro opcional. Sirve para comprobar si un usuario tiene cierto rol en concreto en el evento Returns: True si est\u00e1 ( con el rol en concreto si es especificado), False si no \"\"\" resultado = False for attendee in self . asistentes : if ( asistente == attendee ): logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido Atendee {} \" . format ( str ( asistente ))) if rol == \"\" : resultado = True elif self . asistentes [ asistente ][ 'rol' ] == rol : resultado = True return resultado","title":"get_comprobar_asistente()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_cuenta_asistentes","text":"Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: Type Description int Cantidad de asistentes requeridos a un evento. Source code in modulos\\gestor_calendario.py 299 300 301 302 303 304 305 306 307 308 309 310 311 def get_cuenta_asistentes ( self ) -> int : \"\"\" Obtiene la cuenta de asistentes a un evento con el rol REQ-PARTICIPANT Returns: Cantidad de asistentes requeridos a un evento. \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"REQ-PARTICIPANT\" : cuenta += 1 return cuenta","title":"get_cuenta_asistentes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_cuenta_demandantes","text":"Obtiene cantidad de demandantes de un evento Returns: Type Description int Obtiene cantidad de asistentes con el rol NON-PARTICIPANT Source code in modulos\\gestor_calendario.py 326 327 328 329 330 331 332 333 334 335 336 337 338 def get_cuenta_demandantes ( self ) -> int : \"\"\" Obtiene cantidad de demandantes de un evento Returns: Obtiene cantidad de asistentes con el rol NON-PARTICIPANT \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"NON-PARTICIPANT\" : cuenta += 1 return cuenta","title":"get_cuenta_demandantes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_cuenta_ofertantes","text":"Obtiene cuenta de ofertantes de un evento Returns: Type Description int Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento Source code in modulos\\gestor_calendario.py 312 313 314 315 316 317 318 319 320 321 322 323 324 def get_cuenta_ofertantes ( self ) -> int : \"\"\" Obtiene cuenta de ofertantes de un evento Returns: Obtiene cantidad de asistentes con rol OPT-PARTICIPANT de un evento \"\"\" cuenta = 0 self . get_asistentes () for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == \"OPT-PARTICIPANT\" : cuenta += 1 return cuenta","title":"get_cuenta_ofertantes()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_fecha_datetime","text":"Obtiene la fecha de inicio del evento en formato datetime Returns: Type Description datetime . datetime Fecha de inicio del evento Source code in modulos\\gestor_calendario.py 349 350 351 352 353 354 355 356 def get_fecha_datetime ( self ) -> datetime . datetime : \"\"\" Obtiene la fecha de inicio del evento en formato datetime Returns: Fecha de inicio del evento \"\"\" return self . Event . vobject_instance . vevent . dtstart . value","title":"get_fecha_datetime()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_fecha_str","text":"Obtiene la fecha de inicio del evento en formato cadena Returns: Name Type Description str str Fecha en formato [dia-mes-a\u00f1o horas-minutos] Source code in modulos\\gestor_calendario.py 340 341 342 343 344 345 346 347 def get_fecha_str ( self ) -> str : \"\"\" Obtiene la fecha de inicio del evento en formato cadena Returns: str: Fecha en formato [dia-mes-a\u00f1o horas-minutos] \"\"\" return str ( self . Event . vobject_instance . vevent . dtstart . value . strftime ( ' %d -%m-%Y %H:%M' ))","title":"get_fecha_str()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_rol_asistente","text":"Devuelve el rol del asistente que se pasa por par\u00e1metro Parameters: Name Type Description Default asistente str Correo del asistente required Returns: Type Description str rol del asistente en cadena Source code in modulos\\gestor_calendario.py 287 288 289 290 291 292 293 294 295 296 297 298 def get_rol_asistente ( self , asistente : str ) -> str : \"\"\" Devuelve el rol del asistente que se pasa por par\u00e1metro Args: asistente: Correo del asistente Returns: rol del asistente en cadena \"\"\" return self . asistentes [ asistente ][ 'rol' ]","title":"get_rol_asistente()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_sitios_libres","text":"Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: Type Description int Cantidad de puestos libres Source code in modulos\\gestor_calendario.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def get_sitios_libres ( self ) -> int : \"\"\" Obtiene la cantidad de puestos disponibles de un Evento. Esto es, que tengan asistentes de rol \"OPT-PARTICIPANT\" Los \"NON-PARTICIPANT\" cuentan como sitios ya solicitados Returns: Cantidad de puestos libres \"\"\" sitios_libres = 0 if self . asistentes != {}: for asistente in self . asistentes : if self . asistentes [ asistente ][ 'rol' ] == 'OPT-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'Optativo' en un evento. Significa que ya alguien pidi\u00f3 ceder el evento\" ) sitios_libres += 1 if self . asistentes [ asistente ][ 'rol' ] == 'NON-PARTICIPANT' : logging . getLogger ( __name__ ) . debug ( \"Hay un asistente 'No Participante' en un evento. Significa que ya alguien pidi\u00f3 obtener el evento que alguien cedi\u00f3\" ) sitios_libres -= 1 return sitios_libres","title":"get_sitios_libres()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_summary","text":"Obtiene nombre de evento o summary Returns: Type Description str Cadena con nombre del evento Source code in modulos\\gestor_calendario.py 110 111 112 113 114 115 116 117 def get_summary ( self ) -> str : \"\"\" Obtiene nombre de evento o summary Returns: Cadena con nombre del evento \"\"\" return str ( self . Event . vobject_instance . vevent . summary . value )","title":"get_summary()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.get_uid","text":"Obtiene uid del evento Returns: Type Description str Uid del evento Source code in modulos\\gestor_calendario.py 119 120 121 122 123 124 125 126 def get_uid ( self ) -> str : \"\"\" Obtiene uid del evento Returns: Uid del evento \"\"\" return str ( self . Event . vobject_instance . vevent . uid . value )","title":"get_uid()"},{"location":"gestor_calendario/#modulos.gestor_calendario.Evento.set_asistente","text":"Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Parameters: Name Type Description Default correo_asistente str Correo del asistente que estamos queriendo actualizar required rol str Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba '' tipo str Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. 'INDIVIDUAL' Returns: Name Type Description int int 0 si es correcto, -1 si sucede una Excepci\u00f3n Source code in modulos\\gestor_calendario.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def set_asistente ( self , correo_asistente : str , rol : str = \"\" , tipo : str = 'INDIVIDUAL' ) -> int : \"\"\" Actualiza lista de asistentes en el evento caldav.Event y el propio diccionario de gestor_calendario.Evento Args: correo_asistente: Correo del asistente que estamos queriendo actualizar rol: Valor de rol a definir para el asistente. Si no se incluye, se mantiene como estaba tipo: Valor de tipo del asistente. Si no se define, se mantiene como estaba originalmente. Returns: int: 0 si es correcto, -1 si sucede una Excepci\u00f3n \"\"\" try : asistente = self . asistentes [ correo_asistente ] except KeyError as k : self . asistentes [ correo_asistente ] = {} except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 finally : if rol != \"\" : self . asistentes [ correo_asistente ][ 'rol' ] = rol self . asistentes [ correo_asistente ][ 'tipo' ] = tipo if hasattr ( self . Event . vobject_instance . vevent , 'attendee' ): existente = False for i , attendee in enumerate ( self . Event . vobject_instance . vevent . attendee_list ): if str ( urlparse ( attendee . value ) . path ) == correo_asistente : self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'ROLE' : [ asistente [ 'rol' ]]}) self . Event . vobject_instance . vevent . attendee_list [ i ] . params . update ( { 'CUTYPE' : [ asistente [ 'tipo' ]]}) existente = True if not existente : try : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return - 1 else : self . Event . vobject_instance . vevent . add ( 'attendee;cutype= {} ;role= {} ;partstat=NEEDS-ACTION;SCHEDULE-STATUS=3.7' . format ( tipo , rol ) ) . value = \"mailto: {} \" . format ( correo_asistente ) return 0","title":"set_asistente()"},{"location":"gestor_calendario/#modulos.gestor_calendario.start","text":"M\u00e9todo de m\u00f3dulo para cargar el cliente caldav en una variable de m\u00e9todo Parameters: Name Type Description Default url_servicio str url donde se encuentra el servidor caldav required usuario str usuario para acceder al servicio caldav None contrasena str contrase\u00f1a del servicio None Source code in modulos\\gestor_calendario.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def start ( url_servicio : str , usuario : str = None , contrasena : str = None ): \"\"\" M\u00e9todo de m\u00f3dulo para cargar el cliente caldav en una variable de m\u00e9todo Args: url_servicio: url donde se encuentra el servidor caldav usuario: usuario para acceder al servicio caldav contrasena: contrase\u00f1a del servicio \"\"\" global cliente try : cliente = caldav . DAVClient ( url = url_servicio , username = usuario , password = contrasena ) logging . getLogger ( __name__ ) . debug ( \"Iniciado url_servicio CALDAV\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e ))","title":"start()"},{"location":"servicio_rest/","text":"M\u00f3dulo para agregar manejo del servicio REST para obtener datos del servicio Guardianes Contiene las variables de m\u00f3dulo: url_inserta : Contiene la URL para insertar la ID de telegram utilizando la ID de usuario en la BBDD del servicio REST url_getID : Contiene la URL para obtener la ID del doctor en la BBDD del servicio REST a partir del email url_getnombre : Contiene la URL para obtener el nombre y apellido del doctor a partir de la ID del doctor en la BBDD del servicio REST url_getIDrestporIDtel : Contiene la URL para obtener la ID del doctor en la BBDD del servicio REST a partir de la ID de usuario de Telegram url_getroles : Contiene la URL para obtener los roles de un doctor a partir del correo del doctor url_getIDtelporIDrest : Contiene la URL para obtener la ID de usuario de Telegram del doctor a partir de la ID en la BBDD del servicio REST usuario : Usuario para el servicio REST password : Password para el servicio REST Estas variables son con acceso de lectura desde cualquier funci\u00f3n del m\u00f3dulo. Para poder escribir en ellas, es necesario declararla como global dentro de la funci\u00f3n GetAdmins () Obtiene una lista de administradores en la BBDD del servicio REST Returns: Type Description list [ str ] Lista con los correos de los administradores, o lista vac\u00eda si no los encuentra. Source code in modulos\\servicio_rest.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def GetAdmins () -> list [ str ]: \"\"\" Obtiene una lista de administradores en la BBDD del servicio REST Returns: Lista con los correos de los administradores, o lista vac\u00eda si no los encuentra. \"\"\" respuesta = None admines = [] try : #Obtenemos la respuesta de solicitar los roles respuesta = requests . get ( url_getroles , auth = HTTPBasicAuth ( usuario , password ), params = { 'rol' : \"Administrador\" } ) if respuesta . status_code == 200 : admines = respuesta . text . strip ( '][' ) . split ( ', ' ) return admines except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Error obteniendo roles del doctor \" + str ( e )) raise Exception except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return admines GetEmailPorID ( id ) Obtiene el correo de un usuario a partir de su ID del servicio REST Parameters: Name Type Description Default id str | int ID del servicio REST del usuario required Returns: Type Description str | None Correo del usuario o None en caso contrario Source code in modulos\\servicio_rest.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def GetEmailPorID ( id : str | int ) -> str | None : \"\"\" Obtiene el correo de un usuario a partir de su ID del servicio REST Args: id: ID del servicio REST del usuario Returns: Correo del usuario o None en caso contrario \"\"\" respuesta = None email = None try : respuesta = requests . get ( url_getnombre + '/' + str ( id ), auth = HTTPBasicAuth ( usuario , password ) ) respuestajson = respuesta . json () logging . getLogger ( __name__ ) . debug ( \"Respuesta de NombrePorID: \" + str ( respuestajson )) email = str ( respuestajson . get ( 'email' )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception return email GetIDPorEmail ( email ) Obteiene la ID del usuario en el servicio REST a partir de su correo electr\u00f3nico Parameters: Name Type Description Default email str Correo electr\u00f3nico del usuario required Returns: Type Description str Devuelve la cadena Email not found si no encuentra el correo, o la ID en el servicio REST si lo encontr\u00f3 Source code in modulos\\servicio_rest.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def GetIDPorEmail ( email : str ) -> str : \"\"\" Obteiene la ID del usuario en el servicio REST a partir de su correo electr\u00f3nico Args: email: Correo electr\u00f3nico del usuario Returns: Devuelve la cadena `Email not found` si no encuentra el correo, o la ID en el servicio REST si lo encontr\u00f3 \"\"\" try : respuesta = requests . get ( url_getID , auth = HTTPBasicAuth ( usuario , password ), params = { 'email' : email }) logging . getLogger ( __name__ ) . debug ( respuesta . text ) idrest = str ( respuesta . text ) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idrest if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" GetNombrePorID ( id ) Obtiene el nombre y apellido de un usuario en el servicio REST a partir de su ID Parameters: Name Type Description Default id str | int ID del usuario en el servicio REST required Returns: Type Description str El nombre y apellido en caso de encontrar al doctor o el mensaje \"Email not found\" Source code in modulos\\servicio_rest.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def GetNombrePorID ( id : str | int ) -> str : \"\"\" Obtiene el nombre y apellido de un usuario en el servicio REST a partir de su ID Args: id: ID del usuario en el servicio REST Returns: El nombre y apellido en caso de encontrar al doctor o el mensaje \"Email not found\" \"\"\" respuesta = None nombre = None try : respuesta = requests . get ( url_getnombre + '/' + str ( id ), auth = HTTPBasicAuth ( usuario , password ) ) respuestajson = respuesta . json () logging . getLogger ( __name__ ) . debug ( \"Respuesta de NombrePorID: \" + str ( respuestajson )) nombre = str ( respuestajson . get ( 'firstName' )) + \" \" + str ( respuestajson . get ( 'lastNames' )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Error obteniendo nombre del doctor \" + str ( e )) raise Exception if respuesta . status_code == 200 : return nombre if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" GetRolesPorEmail ( mail ) Obtiene los roles de un usuario Parameters: Name Type Description Default mail str Correo del usuario required Returns: Type Description list [ str ] Lista de roles que tenga el usuario, o lista vac\u00eda si no los encuentra. Source code in modulos\\servicio_rest.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def GetRolesPorEmail ( mail : str ) -> list [ str ]: \"\"\" Obtiene los roles de un usuario Args: mail: Correo del usuario Returns: Lista de roles que tenga el usuario, o lista vac\u00eda si no los encuentra. \"\"\" respuesta = None roles = [] try : respuesta = requests . get ( url_getroles + '/' + str ( mail ), auth = HTTPBasicAuth ( usuario , password ) ) if respuesta . status_code == 200 : if \"Nombre rol=Doctor\" in respuesta . text : roles . append ( \"Doctor\" ) if \"Nombre rol=Administrador\" in respuesta . text : roles . append ( \"Administrador\" ) if \"Nombre rol=Administrativo\" in respuesta . text : roles . append ( \"Administrativo\" ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de GetRolesPorEmail: \" + str ( roles )) if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Error obteniendo roles del doctor \" + str ( e )) raise Exception except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return roles GetidRESTPorIDTel ( id ) Obtiene la ID del servicio REST de un usuario a partir de su ID en Telegram Parameters: Name Type Description Default id str | int ID de Telegram del usuario required Returns: Type Description str Obtiene la ID del usuario en el servicio REST o el mensaje \"Email not found\" Source code in modulos\\servicio_rest.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def GetidRESTPorIDTel ( id : str | int ) -> str : \"\"\" Obtiene la ID del servicio REST de un usuario a partir de su ID en Telegram Args: id: ID de Telegram del usuario Returns: Obtiene la ID del usuario en el servicio REST o el mensaje \"Email not found\" \"\"\" respuesta = None nombre = None try : respuesta = requests . get ( url_getIDrestporIDtel , auth = HTTPBasicAuth ( usuario , password ), params = { 'idTel' : str ( id )} ) idRest = str ( respuesta . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de idRESTPorIDTel: \" + str ( respuesta . text )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idRest if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" GetidTelPoridREST ( id ) Obtiene la ID de telegram de un usuario a partir de su ID del servicio REST Parameters: Name Type Description Default id str | int ID de servicio REST de un usuario required Returns: Type Description str La ID de Telegram de un usuario, o \"Email not found\" en caso de no existir. Source code in modulos\\servicio_rest.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def GetidTelPoridREST ( id : str | int ) -> str : \"\"\" Obtiene la ID de telegram de un usuario a partir de su ID del servicio REST Args: id: ID de servicio REST de un usuario Returns: La ID de Telegram de un usuario, o \"Email not found\" en caso de no existir. \"\"\" respuesta = None nombre = None idTel = '0' try : respuesta = requests . get ( url_getIDtelporIDrest , auth = HTTPBasicAuth ( usuario , password ), params = { 'id' : str ( id )} ) idTel = str ( respuesta . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de idRESTPorIDTel: \" + str ( respuesta . text )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idTel if \"Could not find the doctor\" in respuesta . text : return \"Email not found\" InsertaTelegramID ( idusuario , chatid ) Inserta la ID de telegram del usuario, utilizando la ID REST del mismo Parameters: Name Type Description Default idusuario str | int ID del usuario en el servicio REST required chatid str | int ID del usuario en Telegram required Returns: Type Description str | None Devuelve el mensaje de ID de Telegram actualizado si se completa, o None si hay un fallo. Source code in modulos\\servicio_rest.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def InsertaTelegramID ( idusuario : str | int , chatid : str | int ) -> str | None : \"\"\" Inserta la ID de telegram del usuario, utilizando la ID REST del mismo Args: idusuario: ID del usuario en el servicio REST chatid: ID del usuario en Telegram Returns: Devuelve el mensaje de ID de Telegram actualizado si se completa, o None si hay un fallo. \"\"\" respuesta = None try : respuesta = requests . put ( url_inserta + '/' + idusuario , auth = HTTPBasicAuth ( usuario , password ), headers = { 'Content-Type' : 'text/plain' }, data = str ( chatid )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return respuesta . text start ( user , contrasena , inserta_id_tel_por_id_rest , get_id_por_email , get_nombre_por_id_rest , get_id_rest_por_id_tel , get_rol_por_email , get_id_tel_por_id_rest ) Funci\u00f3n para inicializar el m\u00f3dulo. Rellena las urls de acceso a la API REST y las credenciales. Parameters: Name Type Description Default user str Usuario para acceder a la API REST required contrasena str Password para acceder a la API REST required inserta_id_tel_por_id_rest str URL para insertar la ID de telegram en la BBDD required get_id_por_email str URL para obtener la ID del servicio REST a partir del email required get_nombre_por_id_rest str URL para obtener el nombre del doctor a partir de la ID del servicio REST required get_id_rest_por_id_tel str URL para obtener la ID del servicio REST a partir de la ID de Telegram required get_rol_por_email str URL para obtener los roles de un doctor a partir de su email required get_id_tel_por_id_rest str URL para obtener la ID de Telegram a partir de la ID del servicio REST required Source code in modulos\\servicio_rest.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def start ( user : str , contrasena : str , inserta_id_tel_por_id_rest : str , get_id_por_email : str , get_nombre_por_id_rest : str , get_id_rest_por_id_tel : str , get_rol_por_email : str , get_id_tel_por_id_rest : str ) -> None : \"\"\" Funci\u00f3n para inicializar el m\u00f3dulo. Rellena las urls de acceso a la API REST y las credenciales. Args: user: Usuario para acceder a la API REST contrasena: Password para acceder a la API REST inserta_id_tel_por_id_rest: URL para insertar la ID de telegram en la BBDD get_id_por_email: URL para obtener la ID del servicio REST a partir del email get_nombre_por_id_rest: URL para obtener el nombre del doctor a partir de la ID del servicio REST get_id_rest_por_id_tel: URL para obtener la ID del servicio REST a partir de la ID de Telegram get_rol_por_email: URL para obtener los roles de un doctor a partir de su email get_id_tel_por_id_rest: URL para obtener la ID de Telegram a partir de la ID del servicio REST \"\"\" global url_inserta , url_getID , usuario , password , url_getnombre , url_getIDrestporIDtel , url_getroles , url_getIDtelporIDrest url_inserta = inserta_id_tel_por_id_rest url_getID = get_id_por_email url_getnombre = get_nombre_por_id_rest url_getIDrestporIDtel = get_id_rest_por_id_tel url_getroles = get_rol_por_email url_getIDtelporIDrest = get_id_tel_por_id_rest usuario = user password = contrasena logging . getLogger ( __name__ ) . debug ( \"Inicializado el objeto REST con valores: \" + \" URL_INSERTA: \" + url_inserta + \" URL_OBTENER: \" + url_getID + \" URL_GET_NOMBRE \" + url_getnombre + \" URL_GET_ID\" + url_getIDrestporIDtel + \" USUARIO: \" + usuario + \" PASSWORD: \" + password )","title":"servicio_rest"},{"location":"servicio_rest/#modulos.servicio_rest.GetAdmins","text":"Obtiene una lista de administradores en la BBDD del servicio REST Returns: Type Description list [ str ] Lista con los correos de los administradores, o lista vac\u00eda si no los encuentra. Source code in modulos\\servicio_rest.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def GetAdmins () -> list [ str ]: \"\"\" Obtiene una lista de administradores en la BBDD del servicio REST Returns: Lista con los correos de los administradores, o lista vac\u00eda si no los encuentra. \"\"\" respuesta = None admines = [] try : #Obtenemos la respuesta de solicitar los roles respuesta = requests . get ( url_getroles , auth = HTTPBasicAuth ( usuario , password ), params = { 'rol' : \"Administrador\" } ) if respuesta . status_code == 200 : admines = respuesta . text . strip ( '][' ) . split ( ', ' ) return admines except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Error obteniendo roles del doctor \" + str ( e )) raise Exception except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return admines","title":"GetAdmins()"},{"location":"servicio_rest/#modulos.servicio_rest.GetEmailPorID","text":"Obtiene el correo de un usuario a partir de su ID del servicio REST Parameters: Name Type Description Default id str | int ID del servicio REST del usuario required Returns: Type Description str | None Correo del usuario o None en caso contrario Source code in modulos\\servicio_rest.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def GetEmailPorID ( id : str | int ) -> str | None : \"\"\" Obtiene el correo de un usuario a partir de su ID del servicio REST Args: id: ID del servicio REST del usuario Returns: Correo del usuario o None en caso contrario \"\"\" respuesta = None email = None try : respuesta = requests . get ( url_getnombre + '/' + str ( id ), auth = HTTPBasicAuth ( usuario , password ) ) respuestajson = respuesta . json () logging . getLogger ( __name__ ) . debug ( \"Respuesta de NombrePorID: \" + str ( respuestajson )) email = str ( respuestajson . get ( 'email' )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception return email","title":"GetEmailPorID()"},{"location":"servicio_rest/#modulos.servicio_rest.GetIDPorEmail","text":"Obteiene la ID del usuario en el servicio REST a partir de su correo electr\u00f3nico Parameters: Name Type Description Default email str Correo electr\u00f3nico del usuario required Returns: Type Description str Devuelve la cadena Email not found si no encuentra el correo, o la ID en el servicio REST si lo encontr\u00f3 Source code in modulos\\servicio_rest.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def GetIDPorEmail ( email : str ) -> str : \"\"\" Obteiene la ID del usuario en el servicio REST a partir de su correo electr\u00f3nico Args: email: Correo electr\u00f3nico del usuario Returns: Devuelve la cadena `Email not found` si no encuentra el correo, o la ID en el servicio REST si lo encontr\u00f3 \"\"\" try : respuesta = requests . get ( url_getID , auth = HTTPBasicAuth ( usuario , password ), params = { 'email' : email }) logging . getLogger ( __name__ ) . debug ( respuesta . text ) idrest = str ( respuesta . text ) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idrest if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\"","title":"GetIDPorEmail()"},{"location":"servicio_rest/#modulos.servicio_rest.GetNombrePorID","text":"Obtiene el nombre y apellido de un usuario en el servicio REST a partir de su ID Parameters: Name Type Description Default id str | int ID del usuario en el servicio REST required Returns: Type Description str El nombre y apellido en caso de encontrar al doctor o el mensaje \"Email not found\" Source code in modulos\\servicio_rest.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def GetNombrePorID ( id : str | int ) -> str : \"\"\" Obtiene el nombre y apellido de un usuario en el servicio REST a partir de su ID Args: id: ID del usuario en el servicio REST Returns: El nombre y apellido en caso de encontrar al doctor o el mensaje \"Email not found\" \"\"\" respuesta = None nombre = None try : respuesta = requests . get ( url_getnombre + '/' + str ( id ), auth = HTTPBasicAuth ( usuario , password ) ) respuestajson = respuesta . json () logging . getLogger ( __name__ ) . debug ( \"Respuesta de NombrePorID: \" + str ( respuestajson )) nombre = str ( respuestajson . get ( 'firstName' )) + \" \" + str ( respuestajson . get ( 'lastNames' )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Error obteniendo nombre del doctor \" + str ( e )) raise Exception if respuesta . status_code == 200 : return nombre if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\"","title":"GetNombrePorID()"},{"location":"servicio_rest/#modulos.servicio_rest.GetRolesPorEmail","text":"Obtiene los roles de un usuario Parameters: Name Type Description Default mail str Correo del usuario required Returns: Type Description list [ str ] Lista de roles que tenga el usuario, o lista vac\u00eda si no los encuentra. Source code in modulos\\servicio_rest.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def GetRolesPorEmail ( mail : str ) -> list [ str ]: \"\"\" Obtiene los roles de un usuario Args: mail: Correo del usuario Returns: Lista de roles que tenga el usuario, o lista vac\u00eda si no los encuentra. \"\"\" respuesta = None roles = [] try : respuesta = requests . get ( url_getroles + '/' + str ( mail ), auth = HTTPBasicAuth ( usuario , password ) ) if respuesta . status_code == 200 : if \"Nombre rol=Doctor\" in respuesta . text : roles . append ( \"Doctor\" ) if \"Nombre rol=Administrador\" in respuesta . text : roles . append ( \"Administrador\" ) if \"Nombre rol=Administrativo\" in respuesta . text : roles . append ( \"Administrativo\" ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de GetRolesPorEmail: \" + str ( roles )) if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\" except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Error obteniendo roles del doctor \" + str ( e )) raise Exception except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return roles","title":"GetRolesPorEmail()"},{"location":"servicio_rest/#modulos.servicio_rest.GetidRESTPorIDTel","text":"Obtiene la ID del servicio REST de un usuario a partir de su ID en Telegram Parameters: Name Type Description Default id str | int ID de Telegram del usuario required Returns: Type Description str Obtiene la ID del usuario en el servicio REST o el mensaje \"Email not found\" Source code in modulos\\servicio_rest.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def GetidRESTPorIDTel ( id : str | int ) -> str : \"\"\" Obtiene la ID del servicio REST de un usuario a partir de su ID en Telegram Args: id: ID de Telegram del usuario Returns: Obtiene la ID del usuario en el servicio REST o el mensaje \"Email not found\" \"\"\" respuesta = None nombre = None try : respuesta = requests . get ( url_getIDrestporIDtel , auth = HTTPBasicAuth ( usuario , password ), params = { 'idTel' : str ( id )} ) idRest = str ( respuesta . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de idRESTPorIDTel: \" + str ( respuesta . text )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idRest if \"Could not fing a doctor\" in respuesta . text : return \"Email not found\"","title":"GetidRESTPorIDTel()"},{"location":"servicio_rest/#modulos.servicio_rest.GetidTelPoridREST","text":"Obtiene la ID de telegram de un usuario a partir de su ID del servicio REST Parameters: Name Type Description Default id str | int ID de servicio REST de un usuario required Returns: Type Description str La ID de Telegram de un usuario, o \"Email not found\" en caso de no existir. Source code in modulos\\servicio_rest.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def GetidTelPoridREST ( id : str | int ) -> str : \"\"\" Obtiene la ID de telegram de un usuario a partir de su ID del servicio REST Args: id: ID de servicio REST de un usuario Returns: La ID de Telegram de un usuario, o \"Email not found\" en caso de no existir. \"\"\" respuesta = None nombre = None idTel = '0' try : respuesta = requests . get ( url_getIDtelporIDrest , auth = HTTPBasicAuth ( usuario , password ), params = { 'id' : str ( id )} ) idTel = str ( respuesta . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta de idRESTPorIDTel: \" + str ( respuesta . text )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return idTel if \"Could not find the doctor\" in respuesta . text : return \"Email not found\"","title":"GetidTelPoridREST()"},{"location":"servicio_rest/#modulos.servicio_rest.InsertaTelegramID","text":"Inserta la ID de telegram del usuario, utilizando la ID REST del mismo Parameters: Name Type Description Default idusuario str | int ID del usuario en el servicio REST required chatid str | int ID del usuario en Telegram required Returns: Type Description str | None Devuelve el mensaje de ID de Telegram actualizado si se completa, o None si hay un fallo. Source code in modulos\\servicio_rest.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def InsertaTelegramID ( idusuario : str | int , chatid : str | int ) -> str | None : \"\"\" Inserta la ID de telegram del usuario, utilizando la ID REST del mismo Args: idusuario: ID del usuario en el servicio REST chatid: ID del usuario en Telegram Returns: Devuelve el mensaje de ID de Telegram actualizado si se completa, o None si hay un fallo. \"\"\" respuesta = None try : respuesta = requests . put ( url_inserta + '/' + idusuario , auth = HTTPBasicAuth ( usuario , password ), headers = { 'Content-Type' : 'text/plain' }, data = str ( chatid )) except requests . exceptions . HTTPError as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) raise Exception if respuesta . status_code == 200 : return respuesta . text","title":"InsertaTelegramID()"},{"location":"servicio_rest/#modulos.servicio_rest.start","text":"Funci\u00f3n para inicializar el m\u00f3dulo. Rellena las urls de acceso a la API REST y las credenciales. Parameters: Name Type Description Default user str Usuario para acceder a la API REST required contrasena str Password para acceder a la API REST required inserta_id_tel_por_id_rest str URL para insertar la ID de telegram en la BBDD required get_id_por_email str URL para obtener la ID del servicio REST a partir del email required get_nombre_por_id_rest str URL para obtener el nombre del doctor a partir de la ID del servicio REST required get_id_rest_por_id_tel str URL para obtener la ID del servicio REST a partir de la ID de Telegram required get_rol_por_email str URL para obtener los roles de un doctor a partir de su email required get_id_tel_por_id_rest str URL para obtener la ID de Telegram a partir de la ID del servicio REST required Source code in modulos\\servicio_rest.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def start ( user : str , contrasena : str , inserta_id_tel_por_id_rest : str , get_id_por_email : str , get_nombre_por_id_rest : str , get_id_rest_por_id_tel : str , get_rol_por_email : str , get_id_tel_por_id_rest : str ) -> None : \"\"\" Funci\u00f3n para inicializar el m\u00f3dulo. Rellena las urls de acceso a la API REST y las credenciales. Args: user: Usuario para acceder a la API REST contrasena: Password para acceder a la API REST inserta_id_tel_por_id_rest: URL para insertar la ID de telegram en la BBDD get_id_por_email: URL para obtener la ID del servicio REST a partir del email get_nombre_por_id_rest: URL para obtener el nombre del doctor a partir de la ID del servicio REST get_id_rest_por_id_tel: URL para obtener la ID del servicio REST a partir de la ID de Telegram get_rol_por_email: URL para obtener los roles de un doctor a partir de su email get_id_tel_por_id_rest: URL para obtener la ID de Telegram a partir de la ID del servicio REST \"\"\" global url_inserta , url_getID , usuario , password , url_getnombre , url_getIDrestporIDtel , url_getroles , url_getIDtelporIDrest url_inserta = inserta_id_tel_por_id_rest url_getID = get_id_por_email url_getnombre = get_nombre_por_id_rest url_getIDrestporIDtel = get_id_rest_por_id_tel url_getroles = get_rol_por_email url_getIDtelporIDrest = get_id_tel_por_id_rest usuario = user password = contrasena logging . getLogger ( __name__ ) . debug ( \"Inicializado el objeto REST con valores: \" + \" URL_INSERTA: \" + url_inserta + \" URL_OBTENER: \" + url_getID + \" URL_GET_NOMBRE \" + url_getnombre + \" URL_GET_ID\" + url_getIDrestporIDtel + \" USUARIO: \" + usuario + \" PASSWORD: \" + password )","title":"start()"},{"location":"telegram_tools/","text":"M\u00f3dulo para agregar manejo del servicio de Telegram y aportar funcionalidad para el servicio de Guardianes Contiene las variables de m\u00f3dulo: bot : Contiene un objeto tipo telegram.Bot tokenbot : Contiene una cadena con el token del bot de Telegram cal_principal : Contiene un objeto gestor_calendario.Calendario que define el calendario principal del servicio cal_propuestas : Contiene un objeto gestor_calendario.Calendario que define el calendario de propuestas del servicio canalid : Contiene una cadena con la id del canal de avisos de guardias del servicio canalid_admin : Contiene una cadena con la id del canal de avisos para administradores Estas variables son con acceso de lectura desde cualquier funci\u00f3n del m\u00f3dulo. Para poder escribir en ellas, es necesario declararla como global dentro de la funci\u00f3n autenticar ( func ) M\u00e9todo para autenticar usuario al usar las funciones. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def autenticar ( func : function ): \"\"\" M\u00e9todo para autenticar usuario al usar las funciones. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func: Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = args [ 0 ] . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): func ( * args , ** kwargs ) elif \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper autenticar_admin ( func ) M\u00e9todo para autenticar usuario al usar las funciones del bot. Verifica si es un administrador. Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def autenticar_admin ( func : function ): \"\"\" M\u00e9todo para autenticar usuario al usar las funciones del bot. Verifica si es un administrador. Se utiliza como un decorador Args: func: Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = args [ 0 ] . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : func ( * args , ** kwargs ) else : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No tiene el rol adecuado para esta funci\u00f3n.\" \"Verifique sus permisos con el administrador del sistema\" ) if \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper autenticar_retorno ( func ) M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def autenticar_retorno ( func : function ): \"\"\" M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func: Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = str ( args [ 0 ] . callback_query . from_user . id ) id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): func ( * args , ** kwargs ) elif \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper autenticar_retorno_admin ( func ) M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def autenticar_retorno_admin ( func : function ): \"\"\" M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func: Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = str ( args [ 0 ] . callback_query . from_user . id ) id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : func ( * args , ** kwargs ) else : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No tiene el rol adecuado para esta funci\u00f3n.\" \"Verifique sus permisos con el administrador del sistema\" ) if \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper borrar_mensaje ( id_chat , id_mensaje ) Funci\u00f3n para borrar un mensaje cuando se ha cursado la petici\u00f3n de tomar un evento Parameters: Name Type Description Default id_chat str | int Id del chat de donde se hace la acci\u00f3n de tomar evento required id_mensaje str | int ID del mensaje a borrar required Returns: Type Description bool Verdadero si pudo completarlo, falso si no Source code in modulos\\telegram_tools.py 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 def borrar_mensaje ( id_chat : str | int , id_mensaje : str | int ) -> bool : \"\"\" Funci\u00f3n para borrar un mensaje cuando se ha cursado la petici\u00f3n de tomar un evento Args: id_chat: Id del chat de donde se hace la acci\u00f3n de tomar evento id_mensaje: ID del mensaje a borrar Returns: Verdadero si pudo completarlo, falso si no \"\"\" terminado : bool = False try : terminado = bot . deleteMessage ( chat_id = id_chat , message_id = id_mensaje ) return terminado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return terminado botones ( update , context ) Funci\u00f3n para mostrar los botones en el chat que ejecutar\u00e1n las funciones para el usuario Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 @autenticar def botones ( update : telegram . Update , context : telegram . ext . CallbackContext ): \"\"\" Funci\u00f3n para mostrar los botones en el chat que ejecutar\u00e1n las funciones para el usuario Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" id_user = update . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : kb = [ [ telegram . KeyboardButton ( 'Guardias disponibles para solicitar cambio' ), telegram . KeyboardButton ( 'Guardias propias' ) ], [ telegram . KeyboardButton ( 'Guardias pendientes de ser aprobadas o denegadas' ), ], [ telegram . KeyboardButton ( 'Aprobar o denegar guardias' ) ] ] else : kb = [ [ telegram . KeyboardButton ( 'Guardias disponibles para solicitar cambio' ), telegram . KeyboardButton ( 'Guardias propias' ) ], [ telegram . KeyboardButton ( 'Guardias pendientes de ser aprobadas o denegadas' ) ] ] kb_markup = telegram . ReplyKeyboardMarkup ( kb , resize_keyboard = True ) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Seleccione una opcion\" , reply_markup = kb_markup ) cancelar_propuesta_evento ( uid , attendee ) Funci\u00f3n para que un usuario pueda cancelar su propuesta de cambio Parameters: Name Type Description Default uid str | int Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a cancelar su propuesta required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 def cancelar_propuesta_evento ( uid : str | int , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda cancelar su propuesta de cambio Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a cancelar su propuesta Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento_cancelado = cal_propuestas . cancelar_evento ( correo_usuario = attendee , uid_evento = uid ) if isinstance ( evento_cancelado , gestor_calendario . Evento ): return evento_cancelado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None ceder_evento ( uid , attendee ) Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a ceder su puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def ceder_evento ( uid : str , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a ceder su puesto en una guardia Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_principal . get_evento ( uid ) evento_cedido = cal_propuestas . ceder_evento ( correo_usuario = attendee , evento = evento , uid_evento = uid ) if isinstance ( evento_cedido , gestor_calendario . Evento ): return evento_cedido except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None editar_datos_evento ( evento , id_chat , id_mensaje , accion = 'nada' ) Funci\u00f3n para editar un mensaje de Telegram con los datos de un evento. Utilizada para actualizar los mensajes en el canal de publicaci\u00f3n de guardias Parameters: Name Type Description Default evento gestor_calendario . Evento Evento que se va a actualizar required id_chat str Identificador del chat donde se edita el mensaje required id_mensaje str Identificador del mensaje que se va a editar required accion str Acci\u00f3n que se incluye en el bot\u00f3n que est\u00e1 debajo de la publicaci\u00f3n del mensaje, que luego interacciona con los retornos 'nada' Source code in modulos\\telegram_tools.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def editar_datos_evento ( evento : gestor_calendario . Evento , id_chat : str , id_mensaje : str , accion : str = \"nada\" ): \"\"\" Funci\u00f3n para editar un mensaje de Telegram con los datos de un evento. Utilizada para actualizar los mensajes en el canal de publicaci\u00f3n de guardias Args: evento: Evento que se va a actualizar id_chat: Identificador del chat donde se edita el mensaje id_mensaje: Identificador del mensaje que se va a editar accion: Acci\u00f3n que se incluye en el bot\u00f3n que est\u00e1 debajo de la publicaci\u00f3n del mensaje, que luego interacciona con los retornos \"\"\" reply_markup = [] mensaje = None if accion == \"cancelar\" : texto = \"Cancelar propuesta de cambio\" if accion == \"tomar\" : texto = \"Pedir esta actividad cedida\" if accion == \"ceder\" : texto = \"Ofrecer esta actividad\" if accion == \"aprobar_denegar\" : texto = \"Aprobar este cambio de actividad\" if accion == \"permutar\" : texto = \"Pedir esta actividad para intercambio\" if accion == \"rechazar\" : texto = \"Rechazar intercambio\" if accion == \"escoger\" : texto = \"Escoger esta actividad para intercambio\" boton_callback = [[ telegram . InlineKeyboardButton ( text = \" {} \" . format ( texto ), callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()) ) ]] cadena = \"<b> {} </b> \\n Fecha: {} \\n Sitios libres: {} \" . format ( evento . get_summary (), evento . get_fecha_str (), evento . get_sitios_libres ()) if accion != \"nada\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . editMessageText ( chat_id = id_chat , message_id = id_mensaje , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) guardias_aprobar_denegar ( update , context ) Funci\u00f3n para obtener las guardias que est\u00e1n pendientes de aprobar o denegar y dar la posibilidad de aceptar o denegar el cambio Se imprimir\u00e1n las guardias y se colocar\u00e1n botones para aprobar o denegar el cambio, bajo el mensaje con los datos del evento. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 @autenticar_admin def guardias_aprobar_denegar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias que est\u00e1n pendientes de aprobar o denegar y dar la posibilidad de aceptar o denegar el cambio Se imprimir\u00e1n las guardias y se colocar\u00e1n botones para aprobar o denegar el cambio, bajo el mensaje con los datos del evento. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas # reply_markup=telegram.InlineKeyboardMarkup([]) cadena = \"\" lista_eventos = [] try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos = cal_propuestas . get_eventos ( completos = True ) # Aqui pediriamos el nombre del usuario a traves de REST, usando el id de Telegram como dato # hace falta una funci\u00f3n de obtener la ID por la ID de Telegram logging . getLogger ( __name__ ) . debug ( \"El usuario {} ha solicitado las guardias para aprobar o denegar. Fecha actual {} \" . format ( nombre_usuario , datetime . date . today ())) if lista_eventos == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay eventos pendientes de aceptar o denegar\" ) # key=lambda fecha: e.vobject_instance.vevent.dstart for e in lista_eventos : logging . getLogger ( __name__ ) . debug ( \"Evento para denegar o aprobar: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"aprobar_denegar\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error recogiendo las guardias propias, por favor, p\u00f3ngase en contacto con el administrador\" ) guardias_disponibles ( update , context ) Funci\u00f3n para obtener las guardias en las que hay al menos un puesto con propuesta de cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 @autenticar def guardias_disponibles ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias en las que hay al menos un puesto con propuesta de cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas reply_markup = [] lista_botones = [] cadena = \"\" lista_eventos : list [ gestor_calendario . Evento ] = cal_propuestas . get_eventos () evento_ya_suscrito = 0 try : for e in lista_eventos : if e . get_comprobar_asistente ( servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ))) != True : mostrar_datos_evento ( \"resumen\" , evento = e , id_chat = update . message . chat_id , accion = \"tomar\" ) else : evento_ya_suscrito += 1 if lista_eventos == [] or evento_ya_suscrito == len ( lista_eventos ): context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay guardias disponibles\" ) logging . getLogger ( __name__ ) . debug ( \"No hay guardias disponibles\" ) logging . getLogger ( __name__ ) . debug ( cadena ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) guardias_pendientes ( update , context ) Funci\u00f3n para obtener las guardias en las que el usuario est\u00e1 demandando turno pero a\u00fan no se ha aprobado el cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 @autenticar def guardias_pendientes ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias en las que el usuario est\u00e1 demandando turno pero a\u00fan no se ha aprobado el cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas reply_markup = [] lista_botones = [] cadena = \"\" try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos_ofertados = cal_propuestas . get_eventos ( attendee = email_usuario , rol = \"OPT-PARTICIPANT\" ) lista_eventos_demandados = cal_propuestas . get_eventos ( attendee = email_usuario , rol = \"NON-PARTICIPANT\" ) if lista_eventos_ofertados == [] and lista_eventos_demandados == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay guardias pendientes de ser aprobadas o denegadas\" ) logging . getLogger ( __name__ ) . debug ( \"No hay guardias pendientes de ser aprobadas o denegadas\" ) else : for e in lista_eventos_ofertados : if e . get_sitios_libres () > 0 : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar\" ) else : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"nada\" ) for e in lista_eventos_demandados : if e . get_sitios_libres () > 0 : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar\" ) else : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"nada\" ) logging . getLogger ( __name__ ) . debug ( cadena ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) guardias_propias ( update , context ) Funci\u00f3n para obtener las guardias propias del usuario actualmente establecidas. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 @autenticar def guardias_propias ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias propias del usuario actualmente establecidas. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas # reply_markup=telegram.InlineKeyboardMarkup([]) cadena = \"\" lista_eventos : list [ gestor_calendario . Evento ] = [] evento_ya_ofrecido = 0 try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos = cal_principal . get_eventos ( email_usuario ) # Aqui pediriamos el nombre del usuario a traves de REST, usando el id de Telegram como dato #hace falta una funci\u00f3n de obtener la ID por la ID de Telegram logging . getLogger ( __name__ ) . debug ( \"El usuario {} ha solicitado sus propias guardias. Fecha actual {} \" . format ( nombre_usuario , datetime . date . today ())) if lista_eventos == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay eventos asignados a usted\" ) else : for e in lista_eventos : evento_aux = cal_propuestas . get_evento ( uid_evento = e . get_uid ()) if isinstance ( evento_aux , gestor_calendario . Evento ): if evento_aux . get_comprobar_asistente ( asistente = email_usuario , rol = \"OPT-PARTICIPANT\" ) == True : logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id ) else : logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"ceder_intercambiar\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error recogiendo las guardias propias, por favor, p\u00f3ngase en contacto con el administrador\" ) mostrar_datos_evento ( modo , evento , id_chat , accion = 'nada' ) Funci\u00f3n para presentar datos de un evento en un chat de telegram. Env\u00eda una mensaje al chat indicado por id_chat con los datos del evento y los botones contextuales si procede. Parameters: Name Type Description Default modo str Modo en el que se presenta el evento: \u00b7\u00b7\u00b7resumen: Solo muestra nombre, puestos libres y fecha del evento \u00b7\u00b7\u00b7completo: Muestra nombre, fecha e integrantes del evento required evento gestor_calendario . Evento Objeto gestor_calendario.Evento que contiene los datos del evento a representar. required id_chat str Identificador del chat donde se van a mostrar los datos del evento required accion str Accion que se pone en el mensaje de retorno cuando se pulsa un bot\u00f3n de un mensaje con un evento. Si la acci\u00f3n es nada, no se pone un bot\u00f3n 'nada' Returns: Type Description str Devuelve la id del mensaje enviado Source code in modulos\\telegram_tools.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def mostrar_datos_evento ( modo : str , evento : gestor_calendario . Evento , id_chat : str , accion : str = \"nada\" ) -> str : \"\"\" Funci\u00f3n para presentar datos de un evento en un chat de telegram. Env\u00eda una mensaje al chat indicado por id_chat con los datos del evento y los botones contextuales si procede. Args: modo: Modo en el que se presenta el evento: \u00b7\u00b7\u00b7resumen: Solo muestra nombre, puestos libres y fecha del evento \u00b7\u00b7\u00b7completo: Muestra nombre, fecha e integrantes del evento evento: Objeto gestor_calendario.Evento que contiene los datos del evento a representar. id_chat: Identificador del chat donde se van a mostrar los datos del evento accion: Accion que se pone en el mensaje de retorno cuando se pulsa un bot\u00f3n de un mensaje con un evento. Si la acci\u00f3n es nada, no se pone un bot\u00f3n Returns: Devuelve la id del mensaje enviado \"\"\" reply_markup = [] mensaje : telegram . Message = None texto = \"\" if accion == \"cancelar\" : texto = \"Cancelar propuesta de cambio\" if accion == \"tomar\" : texto = \"Pedir esta actividad cedida\" if accion == \"ceder\" : texto = \"Ofrecer esta actividad\" if accion == \"aprobar_denegar\" : texto = \"Aprobar este cambio de actividad\" if accion == \"permutar\" : texto = \"Pedir esta actividad para intercambio\" if modo == \"resumen\" : boton_callback = [[ telegram . InlineKeyboardButton ( text = \" {} \" . format ( texto ), callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()) ) ]] cadena = \"<b> {} </b> \\n Fecha: {} \\n Sitios libres: {} \" . format ( evento . get_summary (), evento . get_fecha_str (), evento . get_sitios_libres ()) if accion != \"nada\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) else : cadena = \"Evento en el que se ha inscrito a la espera de aprobaci\u00f3n \\n\\n \" + cadena mensaje = bot . send_message ( chat_id = id_chat , text = cadena , parse_mode = \"HTML\" ) if modo == \"completo\" : cadena = \"<b> {} </b> \\n \" . format ( evento . get_summary ()) if evento . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) if evento . get_cuenta_ofertantes () > 0 : cadena += \" \\n <i>Ofertantes de la guardia</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"OPT-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) if evento . get_cuenta_demandantes () > 0 : cadena += \" \\n <i>Demandantes de la guardia</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"NON-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) cadena += \" \\n en fecha: <b> {} </b>\" . format ( evento . get_fecha_str ()) boton_callback = [[ telegram . InlineKeyboardButton ( text = texto , callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()))]] if accion != \"nada\" and accion != \"aprobar_denegar\" and accion != \"ceder_intercambiar\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) elif accion == \"aprobar_denegar\" : boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Aprobar este cambio de guardia\" , callback_data = \" {} ; {} \" . format ( \"aprobar\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Denegar este cambio de guardia\" , callback_data = \" {} ; {} \" . format ( \"denegar\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) elif accion == \"ceder_intercambiar\" : boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Ceder esta guardia\" , callback_data = \" {} ; {} \" . format ( \"ceder\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Intercambiar esta guardia\" , callback_data = \" {} ; {} \" . format ( \"intercambiar\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) if accion == \"nada\" : mensaje = bot . send_message ( chat_id = id_chat , text = cadena , parse_mode = \"HTML\" ) return mensaje . message_id notificar_aprobar_propuesta ( borrados , asentados , evento ) Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Parameters: Name Type Description Default borrados list [ str ] Usuarios que se borran del evento required asentados list [ str ] Usuarios que se agregan al evento required evento gestor_calendario . Evento Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 def notificar_aprobar_propuesta ( borrados : list [ str ], asentados : list [ str ], evento : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Args: borrados: Usuarios que se borran del evento asentados: Usuarios que se agregan al evento evento: Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : for borrado in borrados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( borrado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido aprobado. Ha sido usted excluido de la guardia {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) for asentado in asentados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( asentado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido aprobado. Ha sido usted incluido en la guardia {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False notificar_denegar_propuesta ( borrados , mantenidos , evento ) Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Parameters: Name Type Description Default borrados list [ str ] Usuarios que se borran del evento required mantenidos list [ str ] Usuarios que se agregan al evento required evento gestor_calendario . Evento Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 def notificar_denegar_propuesta ( borrados : list [ str ], mantenidos : list [ str ], evento : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Args: borrados: Usuarios que se borran del evento mantenidos: Usuarios que se agregan al evento evento: Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : for borrado in borrados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( borrado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Ha sido usted excluido de la guardia {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) for mantenido in mantenidos : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( mantenido )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Se mantiene usted en la guardia {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False registro_paso1 ( update , context ) Primer paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Returns: Type Description int Devuelve estado actual del registro_paso1. Paso 1 completo Source code in modulos\\telegram_tools.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def registro_paso1 ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> int : \"\"\" Primer paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram Returns: Devuelve estado actual del registro_paso1. Paso 1 completo \"\"\" context . bot . send_message ( chat_id = update . message . chat_id , text = \"Introduce tu correo electronico para registrarte en la plataforma\" , reply_markup = telegram . ForceReply ()) return 1 registro_paso2 ( update , context ) Segundo paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Returns: Type Description int Devuelve estado actual del registro_paso1. O bien vuelta a empezar este paso o fin de avance en estados Source code in modulos\\telegram_tools.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def registro_paso2 ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> int : \"\"\" Segundo paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram Returns: Devuelve estado actual del registro_paso1. O bien vuelta a empezar este paso o fin de avance en estados \"\"\" logging . getLogger ( __name__ ) . debug ( update . message . text ) idusuario = False if ( \"@\" in update . message . text ): try : # Aqui pedimos a la API Rest la ID del usuario con su email respuesta = servicio_rest . GetIDPorEmail ( email = update . message . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta a GETIDPorEmail es:\" + str ( respuesta ) + \" tipo \" + str ( respuesta . isdigit ())) if respuesta . isdigit (): idusuario = respuesta elif respuesta == \"Email not found\" : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Su correo no ha sido encontrado en la plataforma. \\n Por favor, consulte al \" \"administrador de su sistema para comprobar que sus datos estan adecuadamente \" \"agregados\" ) return ConversationHandler . END if idusuario != False : logging . getLogger ( __name__ ) . debug ( idusuario ) logging . getLogger ( __name__ ) . debug ( update . effective_chat . id ) respuesta = servicio_rest . InsertaTelegramID ( idusuario = str ( idusuario ), chatid = update . effective_chat . id ) logging . getLogger ( __name__ ) . debug ( \"Valor de respuesta \" + str ( respuesta )) # Aqui har\u00edamos la consulta a REST para preguntar si existe ese correo electr\u00f3nico. Si es el caso, # enviar\u00edamos el id if respuesta == 'ID de telegram actualizado' : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha sido registrado en la plataforma, {} \" . format ( servicio_rest . GetNombrePorID ( idusuario ))) # Imprimimos su nombre else : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) botones ( update , context ) return ConversationHandler . END except Exception as e : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ConversationHandler . END else : update . message . reply_text ( \"La cadena no tiene un @. Intente de nuevo enviar su correo\" ) return 1 retorno_aprobar ( update , context ) Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 @autenticar_retorno_admin def retorno_aprobar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"aprobar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) ( borrados , asentados , evento ) = cal_propuestas . asentar_cambios ( uid_evento ) if isinstance ( evento , gestor_calendario . Evento ): if cal_principal . set_evento ( evento ): cal_propuestas . borrar_evento ( uid_evento ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) cadena_borrados = \"\" cadena_asentados = \"\" for borrado in borrados : cadena_borrados = \" \\n - \" + servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( borrado )) + cadena_borrados for asentado in asentados : cadena_asentados = \" \\n - \" + servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asentado )) + cadena_asentados texto_final = \"La propuesta de cambio del turno {} con fecha {} ha sido aprobada. \\n Se han excluido a los usuarios: \\n {} \\n\\n Se han incluido a los usuarios: \\n {} \" \\ . format ( evento . get_summary (), evento . get_fecha_str (), cadena_borrados , cadena_asentados ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final ) notificar_aprobar_propuesta ( borrados , asentados , evento ) else : logging . getLogger ( __name__ ) . debug ( \"El evento {} se ha borrado del calendario de propuestas\" . format ( uid_evento )) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) retorno_cancelar ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 @autenticar_retorno def retorno_cancelar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"cancelar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cancelado = cancelar_propuesta_evento ( uid_evento , correo ) if isinstance ( cancelado , gestor_calendario . Evento ): borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha cancelado con \u00e9xito la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str () ) ) cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { cancelado . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () if idmensaje == []: if cancelado . get_sitios_libres () > 0 : idmensaje = mostrar_datos_evento ( \"resumen\" , cancelado , canalid , \"tomar\" ) cursor . execute ( f \"\"\"INSERT OR REPLACE INTO relaciones_id (Idevento,Idmessage) VALUES ( COALESCE((SELECT Idevento FROM relaciones_id WHERE Idevento=\" { cancelado . get_uid () } \"),\" { cancelado . get_uid () } \"),\" { idmensaje } \");\"\"\" ) relacion . commit () else : \"\"\"El evento no tiene sitios libres\u00bfse avisa o se borra del calendario?\"\"\" pass else : idmensaje = idmensaje [ 0 ][ 0 ] editar_datos_evento ( cancelado , canalid , idmensaje , \"tomar\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_ceder ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es ceder, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 @autenticar_retorno def retorno_ceder ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es ceder, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"ceder\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cedido = ceder_evento ( uid_evento , correo ) if isinstance ( cedido , gestor_calendario . Evento ): borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha cedido con \u00e9xito el evento {} en fecha {} \" . format ( cedido . get_summary (), cedido . get_fecha_str ())) cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { cedido . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () if idmensaje == []: idmensaje = mostrar_datos_evento ( \"resumen\" , cedido , canalid , \"tomar\" ) cursor . execute ( f \"\"\"INSERT OR REPLACE INTO relaciones_id (Idevento,Idmessage) VALUES ( COALESCE((SELECT Idevento FROM relaciones_id WHERE Idevento=\" { cedido . get_uid () } \"),\" { cedido . get_uid () } \"),\" { idmensaje } \");\"\"\" ) relacion . commit () else : idmensaje = idmensaje [ 0 ][ 0 ] editar_datos_evento ( cedido , canalid , idmensaje , \"tomar\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_denegar ( update , context ) Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 @autenticar_retorno_admin def retorno_denegar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"denegar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento = cal_propuestas . get_evento ( uid_evento ) evento_original = cal_principal . get_evento ( uid_evento ) denegado = cal_propuestas . borrar_evento ( uid_evento ) if denegado == True : texto_final = \"Se ha denegado con \u00e9xito el turno. El turno actual queda de la forma siguiente\" context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final ) mostrar_datos_evento ( \"completo\" , evento_original , update . callback_query . from_user . id , \"nada\" ) cal_propuestas . borrar_evento ( uid_evento ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) notificar_denegar_propuesta ( borrados = evento . get_asistentes ( rol = \"NON-PARTICIPANT\" ), mantenidos = evento . get_asistentes ( rol = \"OPT-PARTICIPANT\" )) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Ha habido un problema a la hora de inscribirse en el evento.\" \"P\u00f3ngase en contacto con un administrador\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_intercambiar ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es intercambiar, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 @autenticar_retorno def retorno_intercambiar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es intercambiar, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"intercambiar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cedido = ceder_evento ( uid_evento , correo ) if isinstance ( cedido , gestor_calendario . Evento ): context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha ofrecido con \u00e9xito el evento {} con fecha {} \" . format ( cedido . get_summary (), cedido . get_fecha_str ())) cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { cedido . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () if idmensaje == []: idmensaje = mostrar_datos_evento ( \"resumen\" , cedido , canalid , \"aceptar_intercambio\" ) cursor . execute ( f \"\"\"INSERT OR REPLACE INTO relaciones_id (Idevento,Idmessage) VALUES ( COALESCE((SELECT Idevento FROM relaciones_id WHERE Idevento=\" { cedido . get_uid () } \"),\" { cedido . get_uid () } \"),\" { idmensaje } \");\"\"\" ) relacion . commit () else : idmensaje = idmensaje [ 0 ][ 0 ] editar_datos_evento ( cedido , canalid , idmensaje , \"tomar\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () retorno_tomar ( update , context ) Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es tomar, a\u00f1ade al usuario con el rol NON-PARTICIPANT al evento en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 @autenticar_retorno def retorno_tomar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es tomar, a\u00f1ade al usuario con el rol NON-PARTICIPANT al evento en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid , canalid_admin relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () idmensaje = None try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"tomar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento = cal_principal . get_evento ( uid_evento ) if evento . get_comprobar_asistente ( correo ) != True : tomado = tomar_evento ( uid_evento , correo ) if isinstance ( tomado , gestor_calendario . Evento ): context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Evento en el que se ha inscrito\" ) mostrar_datos_evento ( \"completo\" , tomado , update . callback_query . from_user . id , \"nada\" ) if tomado . get_sitios_libres () == 0 : if update . callback_query . message . chat_id != canalid : borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { tomado . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = idmensaje ) cursor . execute ( f \"\"\"DELETE FROM relaciones_id where Idevento=\" { tomado . get_uid () } \";\"\"\" ) relacion . commit () context . bot . send_message ( chat_id = canalid_admin , text = \"Se ha hecho una propuesta de cambio para aprobar o denegar.\" ) mostrar_datos_evento ( \"completo\" , tomado , canalid_admin , accion = \"aprobar_denegar\" ) else : borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) cursor . execute ( f \"\"\"DELETE FROM relaciones_id where Idevento=\" { tomado . get_uid () } \";\"\"\" ) relacion . commit () context . bot . send_message ( chat_id = canalid_admin , text = \"Se ha hecho una propuesta de cambio para aprobar o denegar.\" ) mostrar_datos_evento ( \"completo\" , tomado , canalid_admin , accion = \"aprobar_denegar\" ) else : cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { tomado . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () idmensaje = idmensaje [ 0 ][ 0 ] editar_datos_evento ( tomado , canalid , idmensaje , \"tomar\" ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Ha habido un problema a la hora de inscribirse en el evento.\" \"P\u00f3ngase en contacto con un administrador\" ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se puede usted inscribir en el evento porque ya est\u00e1 inscrito\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close () start ( token_bot , cal_prim , cal_prop , canal_id , canal_id_admin , path_sqlite ) Funci\u00f3n de inicializaci\u00f3n del bot de Telegram Parameters: Name Type Description Default token_bot str Token de Telegram para autenticar el bot en el sistema de Telegram required cal_prim str Calendario principal que se utiliza en el servicio de guardias required cal_prop str Calendario de propuestas de cambio en el servicio de guardias required canal_id str Id para el canal de publicaci\u00f3n de guardias. required Source code in modulos\\telegram_tools.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def start ( token_bot : str , cal_prim : str , cal_prop : str , canal_id : str , canal_id_admin : str , path_sqlite : str ): \"\"\" Funci\u00f3n de inicializaci\u00f3n del bot de Telegram Args: token_bot: Token de Telegram para autenticar el bot en el sistema de Telegram cal_prim: Calendario principal que se utiliza en el servicio de guardias cal_prop: Calendario de propuestas de cambio en el servicio de guardias canal_id: Id para el canal de publicaci\u00f3n de guardias. \"\"\" global tokenbot , bot , cal_principal , cal_propuestas , canalid , canalid_admin , path_sqlite3 cal_principal = cal_prim cal_propuestas = cal_prop canalid = canal_id canalid_admin = canal_id_admin tokenbot = token_bot path_sqlite3 = path_sqlite bot = telegram . Bot ( token = token_bot ) tomar_evento ( uid , attendee ) Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str | int Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a ceder su puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 def tomar_evento ( uid : str | int , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a ceder su puesto en una guardia Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_propuestas . get_evento ( uid ) if isinstance ( evento , gestor_calendario . Evento ): evento_tomado = cal_propuestas . tomar_evento ( correo_usuario = attendee , uid_evento = uid ) if evento_tomado : return evento_tomado else : return None else : return None except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"telegram_tools"},{"location":"telegram_tools/#modulos.telegram_tools.autenticar","text":"M\u00e9todo para autenticar usuario al usar las funciones. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def autenticar ( func : function ): \"\"\" M\u00e9todo para autenticar usuario al usar las funciones. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func: Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = args [ 0 ] . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): func ( * args , ** kwargs ) elif \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper","title":"autenticar()"},{"location":"telegram_tools/#modulos.telegram_tools.autenticar_admin","text":"M\u00e9todo para autenticar usuario al usar las funciones del bot. Verifica si es un administrador. Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def autenticar_admin ( func : function ): \"\"\" M\u00e9todo para autenticar usuario al usar las funciones del bot. Verifica si es un administrador. Se utiliza como un decorador Args: func: Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = args [ 0 ] . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : func ( * args , ** kwargs ) else : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No tiene el rol adecuado para esta funci\u00f3n.\" \"Verifique sus permisos con el administrador del sistema\" ) if \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper","title":"autenticar_admin()"},{"location":"telegram_tools/#modulos.telegram_tools.autenticar_retorno","text":"M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def autenticar_retorno ( func : function ): \"\"\" M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func: Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = str ( args [ 0 ] . callback_query . from_user . id ) id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): func ( * args , ** kwargs ) elif \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper","title":"autenticar_retorno()"},{"location":"telegram_tools/#modulos.telegram_tools.autenticar_retorno_admin","text":"M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Parameters: Name Type Description Default func function Funci\u00f3n a la que envuelve este m\u00e9todo required Source code in modulos\\telegram_tools.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def autenticar_retorno_admin ( func : function ): \"\"\" M\u00e9todo para autenticar usuario al usar el retorno. Verifica si el usuario est\u00e1 inscrito en el servicio REST Se utiliza como un decorador Args: func: Funci\u00f3n a la que envuelve este m\u00e9todo \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): id_user = str ( args [ 0 ] . callback_query . from_user . id ) id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : func ( * args , ** kwargs ) else : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No tiene el rol adecuado para esta funci\u00f3n.\" \"Verifique sus permisos con el administrador del sistema\" ) if \"Email not found\" in id_rest : args [ 1 ] . bot . send_message ( chat_id = id_user , text = \"No se encuentra identificado y registrado en la plataforma.\" \"Por favor, reg\u00edstrese con la funci\u00f3n /start\" ) return wrapper","title":"autenticar_retorno_admin()"},{"location":"telegram_tools/#modulos.telegram_tools.borrar_mensaje","text":"Funci\u00f3n para borrar un mensaje cuando se ha cursado la petici\u00f3n de tomar un evento Parameters: Name Type Description Default id_chat str | int Id del chat de donde se hace la acci\u00f3n de tomar evento required id_mensaje str | int ID del mensaje a borrar required Returns: Type Description bool Verdadero si pudo completarlo, falso si no Source code in modulos\\telegram_tools.py 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 def borrar_mensaje ( id_chat : str | int , id_mensaje : str | int ) -> bool : \"\"\" Funci\u00f3n para borrar un mensaje cuando se ha cursado la petici\u00f3n de tomar un evento Args: id_chat: Id del chat de donde se hace la acci\u00f3n de tomar evento id_mensaje: ID del mensaje a borrar Returns: Verdadero si pudo completarlo, falso si no \"\"\" terminado : bool = False try : terminado = bot . deleteMessage ( chat_id = id_chat , message_id = id_mensaje ) return terminado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) finally : return terminado","title":"borrar_mensaje()"},{"location":"telegram_tools/#modulos.telegram_tools.botones","text":"Funci\u00f3n para mostrar los botones en el chat que ejecutar\u00e1n las funciones para el usuario Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 @autenticar def botones ( update : telegram . Update , context : telegram . ext . CallbackContext ): \"\"\" Funci\u00f3n para mostrar los botones en el chat que ejecutar\u00e1n las funciones para el usuario Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" id_user = update . message . chat_id id_rest = servicio_rest . GetidRESTPorIDTel ( id_user ) if id_rest . isdigit (): email = servicio_rest . GetEmailPorID ( id_rest ) roles = servicio_rest . GetRolesPorEmail ( email ) if \"Administrador\" in roles : kb = [ [ telegram . KeyboardButton ( 'Guardias disponibles para solicitar cambio' ), telegram . KeyboardButton ( 'Guardias propias' ) ], [ telegram . KeyboardButton ( 'Guardias pendientes de ser aprobadas o denegadas' ), ], [ telegram . KeyboardButton ( 'Aprobar o denegar guardias' ) ] ] else : kb = [ [ telegram . KeyboardButton ( 'Guardias disponibles para solicitar cambio' ), telegram . KeyboardButton ( 'Guardias propias' ) ], [ telegram . KeyboardButton ( 'Guardias pendientes de ser aprobadas o denegadas' ) ] ] kb_markup = telegram . ReplyKeyboardMarkup ( kb , resize_keyboard = True ) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Seleccione una opcion\" , reply_markup = kb_markup )","title":"botones()"},{"location":"telegram_tools/#modulos.telegram_tools.cancelar_propuesta_evento","text":"Funci\u00f3n para que un usuario pueda cancelar su propuesta de cambio Parameters: Name Type Description Default uid str | int Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a cancelar su propuesta required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 def cancelar_propuesta_evento ( uid : str | int , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda cancelar su propuesta de cambio Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a cancelar su propuesta Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento_cancelado = cal_propuestas . cancelar_evento ( correo_usuario = attendee , uid_evento = uid ) if isinstance ( evento_cancelado , gestor_calendario . Evento ): return evento_cancelado except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"cancelar_propuesta_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.ceder_evento","text":"Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a ceder su puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def ceder_evento ( uid : str , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a ceder su puesto en una guardia Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_principal . get_evento ( uid ) evento_cedido = cal_propuestas . ceder_evento ( correo_usuario = attendee , evento = evento , uid_evento = uid ) if isinstance ( evento_cedido , gestor_calendario . Evento ): return evento_cedido except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"ceder_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.editar_datos_evento","text":"Funci\u00f3n para editar un mensaje de Telegram con los datos de un evento. Utilizada para actualizar los mensajes en el canal de publicaci\u00f3n de guardias Parameters: Name Type Description Default evento gestor_calendario . Evento Evento que se va a actualizar required id_chat str Identificador del chat donde se edita el mensaje required id_mensaje str Identificador del mensaje que se va a editar required accion str Acci\u00f3n que se incluye en el bot\u00f3n que est\u00e1 debajo de la publicaci\u00f3n del mensaje, que luego interacciona con los retornos 'nada' Source code in modulos\\telegram_tools.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def editar_datos_evento ( evento : gestor_calendario . Evento , id_chat : str , id_mensaje : str , accion : str = \"nada\" ): \"\"\" Funci\u00f3n para editar un mensaje de Telegram con los datos de un evento. Utilizada para actualizar los mensajes en el canal de publicaci\u00f3n de guardias Args: evento: Evento que se va a actualizar id_chat: Identificador del chat donde se edita el mensaje id_mensaje: Identificador del mensaje que se va a editar accion: Acci\u00f3n que se incluye en el bot\u00f3n que est\u00e1 debajo de la publicaci\u00f3n del mensaje, que luego interacciona con los retornos \"\"\" reply_markup = [] mensaje = None if accion == \"cancelar\" : texto = \"Cancelar propuesta de cambio\" if accion == \"tomar\" : texto = \"Pedir esta actividad cedida\" if accion == \"ceder\" : texto = \"Ofrecer esta actividad\" if accion == \"aprobar_denegar\" : texto = \"Aprobar este cambio de actividad\" if accion == \"permutar\" : texto = \"Pedir esta actividad para intercambio\" if accion == \"rechazar\" : texto = \"Rechazar intercambio\" if accion == \"escoger\" : texto = \"Escoger esta actividad para intercambio\" boton_callback = [[ telegram . InlineKeyboardButton ( text = \" {} \" . format ( texto ), callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()) ) ]] cadena = \"<b> {} </b> \\n Fecha: {} \\n Sitios libres: {} \" . format ( evento . get_summary (), evento . get_fecha_str (), evento . get_sitios_libres ()) if accion != \"nada\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . editMessageText ( chat_id = id_chat , message_id = id_mensaje , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" )","title":"editar_datos_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.guardias_aprobar_denegar","text":"Funci\u00f3n para obtener las guardias que est\u00e1n pendientes de aprobar o denegar y dar la posibilidad de aceptar o denegar el cambio Se imprimir\u00e1n las guardias y se colocar\u00e1n botones para aprobar o denegar el cambio, bajo el mensaje con los datos del evento. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 @autenticar_admin def guardias_aprobar_denegar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias que est\u00e1n pendientes de aprobar o denegar y dar la posibilidad de aceptar o denegar el cambio Se imprimir\u00e1n las guardias y se colocar\u00e1n botones para aprobar o denegar el cambio, bajo el mensaje con los datos del evento. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas # reply_markup=telegram.InlineKeyboardMarkup([]) cadena = \"\" lista_eventos = [] try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos = cal_propuestas . get_eventos ( completos = True ) # Aqui pediriamos el nombre del usuario a traves de REST, usando el id de Telegram como dato # hace falta una funci\u00f3n de obtener la ID por la ID de Telegram logging . getLogger ( __name__ ) . debug ( \"El usuario {} ha solicitado las guardias para aprobar o denegar. Fecha actual {} \" . format ( nombre_usuario , datetime . date . today ())) if lista_eventos == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay eventos pendientes de aceptar o denegar\" ) # key=lambda fecha: e.vobject_instance.vevent.dstart for e in lista_eventos : logging . getLogger ( __name__ ) . debug ( \"Evento para denegar o aprobar: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"aprobar_denegar\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error recogiendo las guardias propias, por favor, p\u00f3ngase en contacto con el administrador\" )","title":"guardias_aprobar_denegar()"},{"location":"telegram_tools/#modulos.telegram_tools.guardias_disponibles","text":"Funci\u00f3n para obtener las guardias en las que hay al menos un puesto con propuesta de cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 @autenticar def guardias_disponibles ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias en las que hay al menos un puesto con propuesta de cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas reply_markup = [] lista_botones = [] cadena = \"\" lista_eventos : list [ gestor_calendario . Evento ] = cal_propuestas . get_eventos () evento_ya_suscrito = 0 try : for e in lista_eventos : if e . get_comprobar_asistente ( servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ))) != True : mostrar_datos_evento ( \"resumen\" , evento = e , id_chat = update . message . chat_id , accion = \"tomar\" ) else : evento_ya_suscrito += 1 if lista_eventos == [] or evento_ya_suscrito == len ( lista_eventos ): context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay guardias disponibles\" ) logging . getLogger ( __name__ ) . debug ( \"No hay guardias disponibles\" ) logging . getLogger ( __name__ ) . debug ( cadena ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" )","title":"guardias_disponibles()"},{"location":"telegram_tools/#modulos.telegram_tools.guardias_pendientes","text":"Funci\u00f3n para obtener las guardias en las que el usuario est\u00e1 demandando turno pero a\u00fan no se ha aprobado el cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 @autenticar def guardias_pendientes ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias en las que el usuario est\u00e1 demandando turno pero a\u00fan no se ha aprobado el cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas reply_markup = [] lista_botones = [] cadena = \"\" try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos_ofertados = cal_propuestas . get_eventos ( attendee = email_usuario , rol = \"OPT-PARTICIPANT\" ) lista_eventos_demandados = cal_propuestas . get_eventos ( attendee = email_usuario , rol = \"NON-PARTICIPANT\" ) if lista_eventos_ofertados == [] and lista_eventos_demandados == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay guardias pendientes de ser aprobadas o denegadas\" ) logging . getLogger ( __name__ ) . debug ( \"No hay guardias pendientes de ser aprobadas o denegadas\" ) else : for e in lista_eventos_ofertados : if e . get_sitios_libres () > 0 : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar\" ) else : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"nada\" ) for e in lista_eventos_demandados : if e . get_sitios_libres () > 0 : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"cancelar\" ) else : mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"nada\" ) logging . getLogger ( __name__ ) . debug ( cadena ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" )","title":"guardias_pendientes()"},{"location":"telegram_tools/#modulos.telegram_tools.guardias_propias","text":"Funci\u00f3n para obtener las guardias propias del usuario actualmente establecidas. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 @autenticar def guardias_propias ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para obtener las guardias propias del usuario actualmente establecidas. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas # reply_markup=telegram.InlineKeyboardMarkup([]) cadena = \"\" lista_eventos : list [ gestor_calendario . Evento ] = [] evento_ya_ofrecido = 0 try : idrest = servicio_rest . GetidRESTPorIDTel ( update . message . chat_id ) nombre_usuario = servicio_rest . GetNombrePorID ( id = idrest ) email_usuario = servicio_rest . GetEmailPorID ( id = idrest ) lista_eventos = cal_principal . get_eventos ( email_usuario ) # Aqui pediriamos el nombre del usuario a traves de REST, usando el id de Telegram como dato #hace falta una funci\u00f3n de obtener la ID por la ID de Telegram logging . getLogger ( __name__ ) . debug ( \"El usuario {} ha solicitado sus propias guardias. Fecha actual {} \" . format ( nombre_usuario , datetime . date . today ())) if lista_eventos == []: context . bot . send_message ( chat_id = update . message . chat_id , text = \"No hay eventos asignados a usted\" ) else : for e in lista_eventos : evento_aux = cal_propuestas . get_evento ( uid_evento = e . get_uid ()) if isinstance ( evento_aux , gestor_calendario . Evento ): if evento_aux . get_comprobar_asistente ( asistente = email_usuario , rol = \"OPT-PARTICIPANT\" ) == True : logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id ) else : logging . getLogger ( __name__ ) . debug ( \"Evento con el usuario incluido: {} \" . format ( e )) mostrar_datos_evento ( \"completo\" , evento = e , id_chat = update . message . chat_id , accion = \"ceder_intercambiar\" ) except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error recogiendo las guardias propias, por favor, p\u00f3ngase en contacto con el administrador\" )","title":"guardias_propias()"},{"location":"telegram_tools/#modulos.telegram_tools.mostrar_datos_evento","text":"Funci\u00f3n para presentar datos de un evento en un chat de telegram. Env\u00eda una mensaje al chat indicado por id_chat con los datos del evento y los botones contextuales si procede. Parameters: Name Type Description Default modo str Modo en el que se presenta el evento: \u00b7\u00b7\u00b7resumen: Solo muestra nombre, puestos libres y fecha del evento \u00b7\u00b7\u00b7completo: Muestra nombre, fecha e integrantes del evento required evento gestor_calendario . Evento Objeto gestor_calendario.Evento que contiene los datos del evento a representar. required id_chat str Identificador del chat donde se van a mostrar los datos del evento required accion str Accion que se pone en el mensaje de retorno cuando se pulsa un bot\u00f3n de un mensaje con un evento. Si la acci\u00f3n es nada, no se pone un bot\u00f3n 'nada' Returns: Type Description str Devuelve la id del mensaje enviado Source code in modulos\\telegram_tools.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def mostrar_datos_evento ( modo : str , evento : gestor_calendario . Evento , id_chat : str , accion : str = \"nada\" ) -> str : \"\"\" Funci\u00f3n para presentar datos de un evento en un chat de telegram. Env\u00eda una mensaje al chat indicado por id_chat con los datos del evento y los botones contextuales si procede. Args: modo: Modo en el que se presenta el evento: \u00b7\u00b7\u00b7resumen: Solo muestra nombre, puestos libres y fecha del evento \u00b7\u00b7\u00b7completo: Muestra nombre, fecha e integrantes del evento evento: Objeto gestor_calendario.Evento que contiene los datos del evento a representar. id_chat: Identificador del chat donde se van a mostrar los datos del evento accion: Accion que se pone en el mensaje de retorno cuando se pulsa un bot\u00f3n de un mensaje con un evento. Si la acci\u00f3n es nada, no se pone un bot\u00f3n Returns: Devuelve la id del mensaje enviado \"\"\" reply_markup = [] mensaje : telegram . Message = None texto = \"\" if accion == \"cancelar\" : texto = \"Cancelar propuesta de cambio\" if accion == \"tomar\" : texto = \"Pedir esta actividad cedida\" if accion == \"ceder\" : texto = \"Ofrecer esta actividad\" if accion == \"aprobar_denegar\" : texto = \"Aprobar este cambio de actividad\" if accion == \"permutar\" : texto = \"Pedir esta actividad para intercambio\" if modo == \"resumen\" : boton_callback = [[ telegram . InlineKeyboardButton ( text = \" {} \" . format ( texto ), callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()) ) ]] cadena = \"<b> {} </b> \\n Fecha: {} \\n Sitios libres: {} \" . format ( evento . get_summary (), evento . get_fecha_str (), evento . get_sitios_libres ()) if accion != \"nada\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) else : cadena = \"Evento en el que se ha inscrito a la espera de aprobaci\u00f3n \\n\\n \" + cadena mensaje = bot . send_message ( chat_id = id_chat , text = cadena , parse_mode = \"HTML\" ) if modo == \"completo\" : cadena = \"<b> {} </b> \\n \" . format ( evento . get_summary ()) if evento . get_cuenta_asistentes () > 0 : cadena += \"<i>Asignado a</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"REQ-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) if evento . get_cuenta_ofertantes () > 0 : cadena += \" \\n <i>Ofertantes de la guardia</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"OPT-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) if evento . get_cuenta_demandantes () > 0 : cadena += \" \\n <i>Demandantes de la guardia</i>: \\n \" for asistente in evento . get_asistentes (): if evento . get_rol_asistente ( asistente ) == \"NON-PARTICIPANT\" : nombre = servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asistente )) cadena += \" - <b> {} </b> (<i> {} </i>) \\n \" . format ( nombre , asistente ) cadena += \" \\n en fecha: <b> {} </b>\" . format ( evento . get_fecha_str ()) boton_callback = [[ telegram . InlineKeyboardButton ( text = texto , callback_data = \" {} ; {} \" . format ( accion , evento . get_uid ()))]] if accion != \"nada\" and accion != \"aprobar_denegar\" and accion != \"ceder_intercambiar\" : reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) elif accion == \"aprobar_denegar\" : boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Aprobar este cambio de guardia\" , callback_data = \" {} ; {} \" . format ( \"aprobar\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Denegar este cambio de guardia\" , callback_data = \" {} ; {} \" . format ( \"denegar\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) elif accion == \"ceder_intercambiar\" : boton_callback = [ [ telegram . InlineKeyboardButton ( text = \"Ceder esta guardia\" , callback_data = \" {} ; {} \" . format ( \"ceder\" , evento . get_uid ()) ), telegram . InlineKeyboardButton ( text = \"Intercambiar esta guardia\" , callback_data = \" {} ; {} \" . format ( \"intercambiar\" , evento . get_uid ()) ) ]] reply_markup = telegram . InlineKeyboardMarkup ( boton_callback ) mensaje = bot . send_message ( chat_id = id_chat , text = cadena , reply_markup = reply_markup , parse_mode = \"HTML\" ) if accion == \"nada\" : mensaje = bot . send_message ( chat_id = id_chat , text = cadena , parse_mode = \"HTML\" ) return mensaje . message_id","title":"mostrar_datos_evento()"},{"location":"telegram_tools/#modulos.telegram_tools.notificar_aprobar_propuesta","text":"Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Parameters: Name Type Description Default borrados list [ str ] Usuarios que se borran del evento required asentados list [ str ] Usuarios que se agregan al evento required evento gestor_calendario . Evento Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 def notificar_aprobar_propuesta ( borrados : list [ str ], asentados : list [ str ], evento : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de un cambio de guardia. Args: borrados: Usuarios que se borran del evento asentados: Usuarios que se agregan al evento evento: Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : for borrado in borrados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( borrado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido aprobado. Ha sido usted excluido de la guardia {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) for asentado in asentados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( asentado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido aprobado. Ha sido usted incluido en la guardia {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"notificar_aprobar_propuesta()"},{"location":"telegram_tools/#modulos.telegram_tools.notificar_denegar_propuesta","text":"Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Parameters: Name Type Description Default borrados list [ str ] Usuarios que se borran del evento required mantenidos list [ str ] Usuarios que se agregan al evento required evento gestor_calendario . Evento Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen required Returns: Type Description bool Devuelve verdadero si completa la acci\u00f3n, falso si hay un error Source code in modulos\\telegram_tools.py 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 def notificar_denegar_propuesta ( borrados : list [ str ], mantenidos : list [ str ], evento : gestor_calendario . Evento ) -> bool : \"\"\" Funci\u00f3n para notificar a los usuarios afectados de una denegaci\u00f3n de cambio de guardia. Args: borrados: Usuarios que se borran del evento mantenidos: Usuarios que se agregan al evento evento: Evento del que se hace el cambio. Necesario para obtener las fechas y el resumen Returns: Devuelve verdadero si completa la acci\u00f3n, falso si hay un error \"\"\" global bot try : for borrado in borrados : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( borrado )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Ha sido usted excluido de la guardia {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) for mantenido in mantenidos : id_chat = servicio_rest . GetidTelPoridREST ( servicio_rest . GetIDPorEmail ( mantenido )) if id_chat != \"Email not found\" and id_chat != '0' : bot . send_message ( chat_id = id_chat , text = \"El cambio ha sido denegado. Se mantiene usted en la guardia {} en fecha {} \" . format ( evento . get_summary (), evento . get_fecha_str ())) return True except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return False","title":"notificar_denegar_propuesta()"},{"location":"telegram_tools/#modulos.telegram_tools.registro_paso1","text":"Primer paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Returns: Type Description int Devuelve estado actual del registro_paso1. Paso 1 completo Source code in modulos\\telegram_tools.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def registro_paso1 ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> int : \"\"\" Primer paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram Returns: Devuelve estado actual del registro_paso1. Paso 1 completo \"\"\" context . bot . send_message ( chat_id = update . message . chat_id , text = \"Introduce tu correo electronico para registrarte en la plataforma\" , reply_markup = telegram . ForceReply ()) return 1","title":"registro_paso1()"},{"location":"telegram_tools/#modulos.telegram_tools.registro_paso2","text":"Segundo paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Returns: Type Description int Devuelve estado actual del registro_paso1. O bien vuelta a empezar este paso o fin de avance en estados Source code in modulos\\telegram_tools.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def registro_paso2 ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> int : \"\"\" Segundo paso para registrar ID del usuario en Telegram en el servicio REST de Guardianes. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram Returns: Devuelve estado actual del registro_paso1. O bien vuelta a empezar este paso o fin de avance en estados \"\"\" logging . getLogger ( __name__ ) . debug ( update . message . text ) idusuario = False if ( \"@\" in update . message . text ): try : # Aqui pedimos a la API Rest la ID del usuario con su email respuesta = servicio_rest . GetIDPorEmail ( email = update . message . text ) logging . getLogger ( __name__ ) . debug ( \"Respuesta a GETIDPorEmail es:\" + str ( respuesta ) + \" tipo \" + str ( respuesta . isdigit ())) if respuesta . isdigit (): idusuario = respuesta elif respuesta == \"Email not found\" : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Su correo no ha sido encontrado en la plataforma. \\n Por favor, consulte al \" \"administrador de su sistema para comprobar que sus datos estan adecuadamente \" \"agregados\" ) return ConversationHandler . END if idusuario != False : logging . getLogger ( __name__ ) . debug ( idusuario ) logging . getLogger ( __name__ ) . debug ( update . effective_chat . id ) respuesta = servicio_rest . InsertaTelegramID ( idusuario = str ( idusuario ), chatid = update . effective_chat . id ) logging . getLogger ( __name__ ) . debug ( \"Valor de respuesta \" + str ( respuesta )) # Aqui har\u00edamos la consulta a REST para preguntar si existe ese correo electr\u00f3nico. Si es el caso, # enviar\u00edamos el id if respuesta == 'ID de telegram actualizado' : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha sido registrado en la plataforma, {} \" . format ( servicio_rest . GetNombrePorID ( idusuario ))) # Imprimimos su nombre else : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) botones ( update , context ) return ConversationHandler . END except Exception as e : context . bot . send_message ( chat_id = update . message . chat_id , text = \"Ha habido un error en la plataforma \\n Contacte por favor con soporte\" ) logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return ConversationHandler . END else : update . message . reply_text ( \"La cadena no tiene un @. Intente de nuevo enviar su correo\" ) return 1","title":"registro_paso2()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_aprobar","text":"Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 @autenticar_retorno_admin def retorno_aprobar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es aprobar, toma el evento en el calendario de propuestas, lo coloca en el lugar del calendario principal y lo borra del calendario de propuestas. Informa a los participantes Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"aprobar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) ( borrados , asentados , evento ) = cal_propuestas . asentar_cambios ( uid_evento ) if isinstance ( evento , gestor_calendario . Evento ): if cal_principal . set_evento ( evento ): cal_propuestas . borrar_evento ( uid_evento ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) cadena_borrados = \"\" cadena_asentados = \"\" for borrado in borrados : cadena_borrados = \" \\n - \" + servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( borrado )) + cadena_borrados for asentado in asentados : cadena_asentados = \" \\n - \" + servicio_rest . GetNombrePorID ( servicio_rest . GetIDPorEmail ( asentado )) + cadena_asentados texto_final = \"La propuesta de cambio del turno {} con fecha {} ha sido aprobada. \\n Se han excluido a los usuarios: \\n {} \\n\\n Se han incluido a los usuarios: \\n {} \" \\ . format ( evento . get_summary (), evento . get_fecha_str (), cadena_borrados , cadena_asentados ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final ) notificar_aprobar_propuesta ( borrados , asentados , evento ) else : logging . getLogger ( __name__ ) . debug ( \"El evento {} se ha borrado del calendario de propuestas\" . format ( uid_evento )) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e ))","title":"retorno_aprobar()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_cancelar","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 @autenticar_retorno def retorno_cancelar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es cancelar, si es un usuario que estaba en NON-PARTICIPANT, lo borra del evento, y si es un usuario OPT-PARTICIPANT, lo vuelve a poner REQ-PARTICIPANT En el segundo caso,se evaluar\u00e1 si quedan sitios libres, si no queda ninguno en OPT-PARTICIPANT y se est\u00e1 demandando el turno, se borrar\u00e1 el evento, avisando previamente a los usuarios afectados Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"cancelar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cancelado = cancelar_propuesta_evento ( uid_evento , correo ) if isinstance ( cancelado , gestor_calendario . Evento ): borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha cancelado con \u00e9xito la propuesta de {} en fecha {} \" . format ( cancelado . get_summary (), cancelado . get_fecha_str () ) ) cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { cancelado . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () if idmensaje == []: if cancelado . get_sitios_libres () > 0 : idmensaje = mostrar_datos_evento ( \"resumen\" , cancelado , canalid , \"tomar\" ) cursor . execute ( f \"\"\"INSERT OR REPLACE INTO relaciones_id (Idevento,Idmessage) VALUES ( COALESCE((SELECT Idevento FROM relaciones_id WHERE Idevento=\" { cancelado . get_uid () } \"),\" { cancelado . get_uid () } \"),\" { idmensaje } \");\"\"\" ) relacion . commit () else : \"\"\"El evento no tiene sitios libres\u00bfse avisa o se borra del calendario?\"\"\" pass else : idmensaje = idmensaje [ 0 ][ 0 ] editar_datos_evento ( cancelado , canalid , idmensaje , \"tomar\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_cancelar()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_ceder","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es ceder, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 @autenticar_retorno def retorno_ceder ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es ceder, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"ceder\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cedido = ceder_evento ( uid_evento , correo ) if isinstance ( cedido , gestor_calendario . Evento ): borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha cedido con \u00e9xito el evento {} en fecha {} \" . format ( cedido . get_summary (), cedido . get_fecha_str ())) cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { cedido . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () if idmensaje == []: idmensaje = mostrar_datos_evento ( \"resumen\" , cedido , canalid , \"tomar\" ) cursor . execute ( f \"\"\"INSERT OR REPLACE INTO relaciones_id (Idevento,Idmessage) VALUES ( COALESCE((SELECT Idevento FROM relaciones_id WHERE Idevento=\" { cedido . get_uid () } \"),\" { cedido . get_uid () } \"),\" { idmensaje } \");\"\"\" ) relacion . commit () else : idmensaje = idmensaje [ 0 ][ 0 ] editar_datos_evento ( cedido , canalid , idmensaje , \"tomar\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_ceder()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_denegar","text":"Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 @autenticar_retorno_admin def retorno_denegar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del administrador cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es denegar, toma el evento en el calendario de propuestas, y lo elimina. Informa a los participantes del evento de este cambio. Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"denegar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento = cal_propuestas . get_evento ( uid_evento ) evento_original = cal_principal . get_evento ( uid_evento ) denegado = cal_propuestas . borrar_evento ( uid_evento ) if denegado == True : texto_final = \"Se ha denegado con \u00e9xito el turno. El turno actual queda de la forma siguiente\" context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = texto_final ) mostrar_datos_evento ( \"completo\" , evento_original , update . callback_query . from_user . id , \"nada\" ) cal_propuestas . borrar_evento ( uid_evento ) borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) notificar_denegar_propuesta ( borrados = evento . get_asistentes ( rol = \"NON-PARTICIPANT\" ), mantenidos = evento . get_asistentes ( rol = \"OPT-PARTICIPANT\" )) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Ha habido un problema a la hora de inscribirse en el evento.\" \"P\u00f3ngase en contacto con un administrador\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_denegar()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_intercambiar","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es intercambiar, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 @autenticar_retorno def retorno_intercambiar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid. La acci\u00f3n es intercambiar, cambia el rol del usuario a OPT-PARTICIPANT para designar un hueco libre en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"intercambiar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) cedido = ceder_evento ( uid_evento , correo ) if isinstance ( cedido , gestor_calendario . Evento ): context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Se ha ofrecido con \u00e9xito el evento {} con fecha {} \" . format ( cedido . get_summary (), cedido . get_fecha_str ())) cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { cedido . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () if idmensaje == []: idmensaje = mostrar_datos_evento ( \"resumen\" , cedido , canalid , \"aceptar_intercambio\" ) cursor . execute ( f \"\"\"INSERT OR REPLACE INTO relaciones_id (Idevento,Idmessage) VALUES ( COALESCE((SELECT Idevento FROM relaciones_id WHERE Idevento=\" { cedido . get_uid () } \"),\" { cedido . get_uid () } \"),\" { idmensaje } \");\"\"\" ) relacion . commit () else : idmensaje = idmensaje [ 0 ][ 0 ] editar_datos_evento ( cedido , canalid , idmensaje , \"tomar\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_intercambiar()"},{"location":"telegram_tools/#modulos.telegram_tools.retorno_tomar","text":"Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es tomar, a\u00f1ade al usuario con el rol NON-PARTICIPANT al evento en el calendario de propuestas Parameters: Name Type Description Default update telegram . Update Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot required context telegram . ext . CallbackContext Objeto con funciones de contexto del bot de telegram required Source code in modulos\\telegram_tools.py 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 @autenticar_retorno def retorno_tomar ( update : telegram . Update , context : telegram . ext . CallbackContext ) -> None : \"\"\" Funci\u00f3n para recibir datos del usuario cuando aprieta botones integrados en el propio chat y tratarlos adecuadamente. Toma una acci\u00f3n a realizar con un evento y su uid La acci\u00f3n es tomar, a\u00f1ade al usuario con el rol NON-PARTICIPANT al evento en el calendario de propuestas Args: update: Objeto con par\u00e1metros del mensaje que env\u00eda el usuario al bot context: Objeto con funciones de contexto del bot de telegram \"\"\" global cal_principal , cal_propuestas , bot , canalid , canalid_admin relacion = sqlite3 . connect ( path_sqlite3 ) cursor = relacion . cursor () idmensaje = None try : if update . callback_query . answer (): logging . getLogger ( __name__ ) . debug ( \"Callback: \" + update . callback_query . data ) accion , uid_evento = update . callback_query . data . split ( ';' ) if accion == \"tomar\" : correo = servicio_rest . GetEmailPorID ( servicio_rest . GetidRESTPorIDTel ( update . callback_query . from_user . id )) evento = cal_principal . get_evento ( uid_evento ) if evento . get_comprobar_asistente ( correo ) != True : tomado = tomar_evento ( uid_evento , correo ) if isinstance ( tomado , gestor_calendario . Evento ): context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Evento en el que se ha inscrito\" ) mostrar_datos_evento ( \"completo\" , tomado , update . callback_query . from_user . id , \"nada\" ) if tomado . get_sitios_libres () == 0 : if update . callback_query . message . chat_id != canalid : borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { tomado . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = idmensaje ) cursor . execute ( f \"\"\"DELETE FROM relaciones_id where Idevento=\" { tomado . get_uid () } \";\"\"\" ) relacion . commit () context . bot . send_message ( chat_id = canalid_admin , text = \"Se ha hecho una propuesta de cambio para aprobar o denegar.\" ) mostrar_datos_evento ( \"completo\" , tomado , canalid_admin , accion = \"aprobar_denegar\" ) else : borrar_mensaje ( id_chat = update . callback_query . message . chat_id , id_mensaje = update . callback_query . message . message_id ) cursor . execute ( f \"\"\"DELETE FROM relaciones_id where Idevento=\" { tomado . get_uid () } \";\"\"\" ) relacion . commit () context . bot . send_message ( chat_id = canalid_admin , text = \"Se ha hecho una propuesta de cambio para aprobar o denegar.\" ) mostrar_datos_evento ( \"completo\" , tomado , canalid_admin , accion = \"aprobar_denegar\" ) else : cursor . execute ( f \"\"\"SELECT Idmessage FROM relaciones_id where Idevento=\" { tomado . get_uid () } \";\"\"\" ) idmensaje = cursor . fetchall () idmensaje = idmensaje [ 0 ][ 0 ] editar_datos_evento ( tomado , canalid , idmensaje , \"tomar\" ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"Ha habido un problema a la hora de inscribirse en el evento.\" \"P\u00f3ngase en contacto con un administrador\" ) else : context . bot . send_message ( chat_id = update . callback_query . from_user . id , text = \"No se puede usted inscribir en el evento porque ya est\u00e1 inscrito\" ) logging . getLogger ( __name__ ) . debug ( \"UID del evento es: {} por el usuario {} \" . format ( uid_evento , update . callback_query . from_user . id )) cursor . close () relacion . close () except BaseException as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . UID del evento: {} . Valor de Callback_query: {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , uid_evento , update . callback_query , e )) cursor . close () relacion . close ()","title":"retorno_tomar()"},{"location":"telegram_tools/#modulos.telegram_tools.start","text":"Funci\u00f3n de inicializaci\u00f3n del bot de Telegram Parameters: Name Type Description Default token_bot str Token de Telegram para autenticar el bot en el sistema de Telegram required cal_prim str Calendario principal que se utiliza en el servicio de guardias required cal_prop str Calendario de propuestas de cambio en el servicio de guardias required canal_id str Id para el canal de publicaci\u00f3n de guardias. required Source code in modulos\\telegram_tools.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def start ( token_bot : str , cal_prim : str , cal_prop : str , canal_id : str , canal_id_admin : str , path_sqlite : str ): \"\"\" Funci\u00f3n de inicializaci\u00f3n del bot de Telegram Args: token_bot: Token de Telegram para autenticar el bot en el sistema de Telegram cal_prim: Calendario principal que se utiliza en el servicio de guardias cal_prop: Calendario de propuestas de cambio en el servicio de guardias canal_id: Id para el canal de publicaci\u00f3n de guardias. \"\"\" global tokenbot , bot , cal_principal , cal_propuestas , canalid , canalid_admin , path_sqlite3 cal_principal = cal_prim cal_propuestas = cal_prop canalid = canal_id canalid_admin = canal_id_admin tokenbot = token_bot path_sqlite3 = path_sqlite bot = telegram . Bot ( token = token_bot )","title":"start()"},{"location":"telegram_tools/#modulos.telegram_tools.tomar_evento","text":"Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Parameters: Name Type Description Default uid str | int Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario required attendee str Correo del usuario que va a ceder su puesto en una guardia required Returns: Type Description gestor_calendario . Evento | None Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None Source code in modulos\\telegram_tools.py 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 def tomar_evento ( uid : str | int , attendee : str ) -> gestor_calendario . Evento | None : \"\"\" Funci\u00f3n para que un usuario pueda ceder su puesto en una guardia y guardar dicha propuesta en el calendario de propuestas Args: uid: Identificador \u00fanico de un evento, que se utilizar\u00e1 para buscar el evento en el calendario attendee: Correo del usuario que va a ceder su puesto en una guardia Returns: Devuelve un Evento si es de clase Evento. En caso de haber excepci\u00f3n devuelve None \"\"\" try : evento = cal_propuestas . get_evento ( uid ) if isinstance ( evento , gestor_calendario . Evento ): evento_tomado = cal_propuestas . tomar_evento ( correo_usuario = attendee , uid_evento = uid ) if evento_tomado : return evento_tomado else : return None else : return None except Exception as e : logging . getLogger ( __name__ ) . error ( \"Excepci\u00f3n en funci\u00f3n {} . Motivo: {} \" . format ( sys . _getframe ( 1 ) . f_code . co_name , e )) return None","title":"tomar_evento()"}]}